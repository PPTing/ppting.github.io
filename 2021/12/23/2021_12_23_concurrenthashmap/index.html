<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ConcurrentHashMap 源码阅读笔记 - PPTing&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="PPTing&#039;s Blog"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="PPTing&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文基于 JDK 1.8 分析  HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失 而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理"><meta property="og:type" content="blog"><meta property="og:title" content="ConcurrentHashMap 源码阅读笔记"><meta property="og:url" content="https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/"><meta property="og:site_name" content="PPTing&#039;s Blog"><meta property="og:description" content="本文基于 JDK 1.8 分析  HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失 而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2021/12/23/vQgJ7Bea1GO5mu2.png"><meta property="og:image" content="https://s2.loli.net/2021/12/23/7uBlQZRbcPYH3Fm.png"><meta property="article:published_time" content="2021-12-22T16:00:00.000Z"><meta property="article:modified_time" content="2022-02-12T08:17:24.000Z"><meta property="article:author" content="PPTing"><meta property="article:tag" content="Map"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.loli.net/2021/12/23/vQgJ7Bea1GO5mu2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/"},"headline":"ConcurrentHashMap 源码阅读笔记","image":["https://s2.loli.net/2021/12/23/vQgJ7Bea1GO5mu2.png","https://s2.loli.net/2021/12/23/7uBlQZRbcPYH3Fm.png"],"datePublished":"2021-12-22T16:00:00.000Z","dateModified":"2022-02-12T08:17:24.000Z","author":{"@type":"Person","name":"PPTing"},"publisher":{"@type":"Organization","name":"PPTing's Blog","logo":{"@type":"ImageObject","url":"https://ppting.me/favicon.ico"}},"description":"本文基于 JDK 1.8 分析  HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失 而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理"}</script><link rel="canonical" href="https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-51029889-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-51029889-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
        <script>
            function switchTab(element) {
                const id = element.parentElement.id;
                const tabElements = element.parentElement.parentElement.children;
                const contentElements = element.parentElement.parentElement.parentElement.parentElement.children[1].children;
                for (let i = 0; i < tabElements.length; i++) {
                    const $tab = tabElements[i];
                    const $content = contentElements[i];
                    if ($tab.id === id) {
                        $tab.classList.add('is-active');
                    } else {
                        $tab.classList.remove('is-active');
                    }
                    if ($content.id === id) {
                        $content.classList.remove('is-hidden');
                    } else {
                        $content.classList.add('is-hidden');
                    }
                }
            }
        </script>
        <!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="PPTing's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-22T16:00:00.000Z" title="12/23/2021, 12:00:00 AM">2021-12-23</time>发表</span><span class="level-item"><time dateTime="2022-02-12T08:17:24.000Z" title="2/12/2022, 4:17:24 PM">2022-02-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span> / </span><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span> / </span><a class="link-muted" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="level-item">1 小时读完 (大约8788个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">ConcurrentHashMap 源码阅读笔记</h1><div class="content"><br>

<blockquote>
<p>本文基于 JDK 1.8 分析</p>
</blockquote>
<p>HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失</p>
<p>而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理</p>
<span id="more"></span>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>先大概对 ConcurrentHashMap 的数据结构模型有个大概的了解</p>
<p>跟 HashMap 一样，由一个数组和多个链表&#x2F;红黑树组成</p>
<p><img src="https://s2.loli.net/2021/12/23/vQgJ7Bea1GO5mu2.png" alt="concurrenthashmap.png"></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><em><code>MAXIMUM_CAPACITY</code> &#x3D; 1 &lt;&lt; 30</em></p>
<p>最大的容量，因为 32 位的 hash 值的前两位为控制位，所以最大只到 1&lt;&lt;30</p>
<p><em><code>DEFAULT_CAPACITY</code></em>  &#x3D; 16</p>
<p>默认初始容量，必须为2的次幂，最低位 1，最大为 <em><code>MAXIMUM_CAPACITY</code></em></p>
<p><em><code>DEFAULT_CONCURRENCY_LEVEL</code> &#x3D; 16</em></p>
<p>默认的并发级别</p>
<p><em><code>LOAD_FACTOR</code> &#x3D; 0.75</em> </p>
<p>负载因子</p>
<p><em><code>TREEIFY_THRESHOLD</code> &#x3D; 8</em></p>
<p><em><code>MIN_TREEIFY_CAPACITY</code> &#x3D; 64</em></p>
<p>当插入时，链表上的节点数量超过 <code>TREEIFY_THRESHOLD</code> ，且 table 的长度也超过了 <code>MIN_TREEIFY_CAPACITY</code>，则会将链表转为树</p>
<p>否则进行扩容操作</p>
<h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><p>sizeCtl 字段是用来表示 table 的初始化状态或者用来控制 table 数组的容量</p>
<p>如果 sizeCtl 为负数，则表示 table 正在初始化或者在调整容量</p>
<p>如果 sizeCtl 不为负数，如果 table 为 null，则保存初始化 ConcurrentHashMap 时的容量，为0或者默认值</p>
<p>初始化以后，则保存的是要进行扩容的阈值</p>
<p><strong>sizeCtl &#x3D; -1</strong> 表示正在初始化</p>
<p><strong>sizeCtl &lt; 0 &amp;&amp; sizeCtl! &#x3D; -1</strong> 表示正在扩容中，且 sizeCtl 的低16位的值表示正在扩容的线程数 + 1，高16位为扩容标识，是由数组长度计算得到的值</p>
<p><strong>sizeCtl ≥ 0 &amp;&amp; table &#x3D;&#x3D; null</strong> 表示初始化时计算出的默认容量</p>
<p>s<strong>izeCtl ≥ 0 &amp;&amp; table !&#x3D; null</strong> 表示需要扩容的阈值</p>
<h3 id="Node-lt-K-V-gt"><a href="#Node-lt-K-V-gt" class="headerlink" title="Node&lt;K,V&gt;"></a>Node&lt;K,V&gt;</h3><p><code>Node&lt;K,V&gt;</code> 是 ConcurrentHashMap 的一个静态内部类，实现了 <code>Map.Entry&lt;K,V&gt;</code> 接口，用来保存键值对信息，注意这里的 <code>val</code> 和 <code>next</code> 字段都是用了 <code>volatile</code> 修饰，以保证其线程间的可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      <span class="keyword">volatile</span> V val;</span><br><span class="line">      <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p> ConcurrentHashMap 有多个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>initialCapacity:</strong> 传入的初始容量</p>
<p><strong>loadFactor</strong>: 负载因子</p>
<p>在构造方法中，实际上，是想通过传入的 <em>initialCapacity</em> 参数，并根据 loadFactor 计算出数组的初始化容量 cap，并且数组的阈值要大于 <em>initialCapacity ，</em>在 <code>initTable()</code> 方法中会使用这个 sizeCtl 值初始化 table 数组的容量</p>
<p><em><strong>But，但是</strong></em></p>
<p>这里的 <code>public ConcurrentHashMap(int initialCapacity)</code> 实际上是有 bug 的，在某些情况下，和下面三个参数的构造方法计算出来的 cap 值并不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ConcurrentHashMap(<span class="number">22</span>)</span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap(<span class="number">22</span>,<span class="number">0.75</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>在一个参数的构造方法中，计算出来的 cap 值为 64，而三参数的构造方法计算所得到的 cap 为 32</p>
<p>这个问题直到 JDK 12 才被修复</p>
<p><a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8202422">value of ‘sizeCtl’ in ConcurrentHashMap varies with the constructor called</a></p>
<h3 id="tableSizeFor-int-size"><a href="#tableSizeFor-int-size" class="headerlink" title="tableSizeFor(int size)"></a>tableSizeFor(int size)</h3><p><code>tableSizeFor(int size)</code> 会返回大于等于 size 的最小的 2^n 的</p>
<p>例如：tableSizeFor(22) &#x3D; 32 ; tableSizeFor(3) &#x3D; 4</p>
<p>具体 <code>tableSizeFor(size)</code> 的方法可以参考</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039392972">HashMap之tableSizeFor方法图解</a></p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>final V putVal(K key , V value , boolean onlyIfAbsent) </p>
<aside>
💡 添加键值对，会进行初始化 table 数组、扩容、链表转树等操作
</aside>

<p>先看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果 key 和 value 都为 null 则抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录链表中节点的数量，用来控制扩容或者由链表转变为树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//死循环，直到满足某个条件后再退出</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//-------------①--------------------</span></span><br><span class="line">            <span class="comment">//如果 tab 为空或者 tab 的长度为 0，则初始化 table</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//-------------②--------------------</span></span><br><span class="line">            <span class="comment">//如果 hash 对应的索引处 i 的桶为空，则尝试 cas 插入</span></span><br><span class="line">            <span class="comment">//这里 i 被赋值为索引</span></span><br><span class="line">            <span class="comment">//f 被赋值为索引处的 node 对象</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">//插入数据成功，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//-------------③--------------------</span></span><br><span class="line">            <span class="comment">// i 处的 Node 不为 null 且其 hash 为 MOVED，即正在扩容中</span></span><br><span class="line">            <span class="comment">// 这里将 fh 赋值为 Node f 的 hash 值</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//-------------④--------------------</span></span><br><span class="line">            <span class="comment">//否则，即 i 处已经有 Node f 存在，并且不处于扩容中，那就应该插入到链表中</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//多 f 加锁，多线程访问</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//这里再次确认 i 处 Node 对象是否为 f</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 f 的 hash 大于等于 0 </span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//开始遍历链表，</span></span><br><span class="line">                            <span class="comment">//过程中如果找到 key 相同的，则替换 value 并退出遍历</span></span><br><span class="line">                            <span class="comment">//否则，遍历完链表，将节点插入链表尾部</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//如果 key 相等，则替换 value，退出循环</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//如果当前节点已经是树了，则将键值对插入树中</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//binCount 不为0，链表上的节点数量不为 0 ，即键值对插入了</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//节点上的数量超过了阈值，转为树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果旧值不为 null，即替换了某个键值对</span></span><br><span class="line">                    <span class="comment">//则 return 旧值，结束整个 put 流程</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">//否则，即 oldVal == null 的情况下</span></span><br><span class="line">                <span class="comment">//退出 for (Node&lt;K,V&gt;[] tab = table;;) 循环</span></span><br><span class="line">                <span class="comment">//走 addCount(1L,binCount) 处的逻辑并返回 null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加计数，扩容等</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="comment">//返回 null，代表是新增的键值对，并非 key 相同替换旧的 value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<p><strong>①. 初始化数组</strong></p>
<p>通过 spread 方法计算 hash 值，并开始死循环，直到插入成功后退出</p>
<p>如果 table 还未初始化，则先通过 initTable() 初始化数组 </p>
<p><strong>②. index 处为 null</strong></p>
<p>通过 spread() 方法计算出对应的索引 i ，如果数组 i 索引处的值为 null ，则通过 cas 的方式进行插入，如果 cas 失败，说明有别的线程在对该处进行操作，则进行下一次 for 循环，下一次 for 循环则会进入 3、4 步中</p>
<p><strong>③. 帮助扩容</strong></p>
<p>如果 index 处节点不为 null 且 index 处的节点 hash 值为 MOVED ，则进行 helpTransfer() 方法</p>
<p><strong>④. 普通插入</strong></p>
<p>上述几步都不满足，则说明 index 上有个普通的节点，或为链表，或为树，进行更新或者插入操作</p>
<p>这里需要注意的是，会将 f(即 index 处的节点) 进行加锁，并会再次检查此时的 table index 索引处的节点是否被改变了，如果改变了，则进入下一次循环，如果没有改变依旧为 f ，则进行更新或者插入操作</p>
<p>如果是链表，则遍历链表覆盖更新值或者在链表尾部插入新的键值对(binCount &#x3D; 原链表长度)</p>
<p>如果是树，则将键值对插入树中</p>
<p>添加完成后，判断该节点上的链表长度，如果超过阈值，则调用 treeifyBin 转为树或者扩容数组，最后调用 addCount 添加计数，视机扩容数组等</p>
<h3 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h3><p>💡 初始化 table 数组</p>
<p>接着看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//table 还没初始化，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// sizeCtl 小于 0 说明有别的线程在初始化，则让出 CPU 时间碎片</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//否则，通过 cas 将 sc 和 -1 进行 cas 操作</span></span><br><span class="line">            <span class="comment">//SIZECTL 是 sizeCtl 传入的对象 this</span></span><br><span class="line">            <span class="comment">//(即 sizeCtl 在 ConcurrentHashMap 这个对象中内存的偏移量)</span></span><br><span class="line">            <span class="comment">// sc 为期望值，此时值为 sizeCtl</span></span><br><span class="line">            <span class="comment">// -1 为要替换的值</span></span><br><span class="line">            <span class="comment">//总结来说就是将 sizeCtl 和 sc 进行比较，如果相等就将 -1 赋值给 sizeCtl，返回 true</span></span><br><span class="line">            <span class="comment">//否则不赋值返回 false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//走到这里说明 cas 成功了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果设置了容量大小则使用设置的容量，否则使用默认的容量</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//new 一个数组并赋值</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容的阈值 n - (n &gt;&gt;&gt; 2) 等同于 n * LOAD_FACTOR</span></span><br><span class="line">                    <span class="comment">//只不过使用位运算更快</span></span><br><span class="line">                    <span class="comment">//即 n * 0.75 = n * 3/4 = n * (1 - 1/4) = n - n/4</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将 sc 的值赋值给 sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新的 table 数组</span></span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">这个方法的作用是，读取传入的对象 o 在内存中偏移 offset 的值，并和 expected 比较</span></span></span><br><span class="line"><span class="params"><span class="function">如果相同，则将 x 赋值给内存中偏移 offset 位置的值，并返回 <span class="keyword">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">否则不赋值返回 <span class="keyword">false</span></span></span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>如果 sizeCtl  小于 0 则让出，则暂停自己的线程，以便其他线程去执行初始化操作</p>
<p>如果 sizeCtl 大于等于 0 则初始化一个 sizeCtl 大小的数组，并更新 sizeCtl 为自身的负载因子倍( * 0.75)</p>
<p>这里通过 Unsafe.compareAndSwapInt 保证了线程安全</p>
<p>假如有多个线程同时调用了 initTable 方法，只有一个线程的 <code>U.compareAndSwapInt(this, SIZECTL, sc, -1)</code> 会返回 true 走入该 if 中的代码去执行初始化操作，假如有第三个线程来了，则会走入到 Thread.yield() 这里去让出时间碎片</p>
<h3 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer"></a>helpTransfer</h3><p>如果在某个线程在进行转移节点数据，则进行判断，满足条件就帮助转移，并返回 table 数组，以便在下次循环中进行插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 tab 不为空，且其头节点为 fwd 节点，说明正在扩容迁移</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//满足 while 中的条件这里说明正在扩容</span></span><br><span class="line">            <span class="comment">//则循环，直到扩容结束</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//修改 sizeCtl 成功，修改扩容的线程数 +1，参与扩容</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容结束，返回新 table</span></span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头节点非 fwd 节点，则返回旧 table </span></span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resizeStamp-int-n"><a href="#resizeStamp-int-n" class="headerlink" title="resizeStamp(int n)"></a>resizeStamp(int n)</h3><blockquote>
<p>由于传入的参数 n 都是 2 的 n 次幂，这个方法实际上是用来将这个 n 通过算法将其记录在低16位中</p>
</blockquote>
<p><em>TL;DR</em> </p>
<blockquote>
<p><strong>返回值高16位记录为 0，低16位记录的是「扩容标识」，与数组长度有关</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS- <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>Integer.numberOfLeadingZeros(n)</code> 返回 n 在二进制中最高位的1前面0的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比方说 <span class="number">1</span> 的二进制为 </span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">则 `Integer.numberOfLeadingZeros(<span class="number">1</span>)` = <span class="number">31</span></span><br><span class="line">所以 Integer.numberOfLeadingZeros(<span class="keyword">int</span> n) 的值的范围为 <span class="number">0</span>-<span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>接着看后半段，*<code>RESIZE_STAMP_BITS</code> 值为  16，*所以 <code>(1 &lt;&lt; (*RESIZE_STAMP_BITS - 1 )*</code> 即1左移15位，得到 <code>0000 0000 0000 0000 1000 0000 0000 0000</code></p>
<p>最后进行 <code>|</code> 运算*(有1则为1)*</p>
<p>我们以 resizeStamp(16) 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(十进制 <span class="number">16</span>)                            == <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">Integer.numberOfLeadingZeros(<span class="number">16</span>) = <span class="number">27</span> == <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">              | 或运算</span><br><span class="line">(<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS- <span class="number">1</span>)  = <span class="number">1</span>&lt;&lt;<span class="number">15</span> == <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">              = 等于</span><br><span class="line">                                         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见 resizeStamp 方法会返回一个 高16为都为0，低16位为传入的参数 n 的 「最高位的1前面0的个数」</p>
<p>即高16位记录为 0，第16位为1，低15位记录的是「最高位的1前面0的个数」低16位构成一个「扩容标识」</p>
<p>可见该方法返回的值的取值范围为 [32769,32799]</p>
<h3 id="treeifyBin-Node-lt-K-V-gt-tab-int-index"><a href="#treeifyBin-Node-lt-K-V-gt-tab-int-index" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab,int index)"></a>treeifyBin(Node&lt;K,V&gt;[] tab,int index)</h3><p>在往 ConcurrentHashMap 中插入元素后，会调用该方法进行扩容或者将链表转为树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">//如果 tab 的长度小于 MIN_TREEIFY_CAPACITY(64)，则进行扩容操作</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//否则，如果 index 处的节点 b 不为空且 hash 值大于0</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                <span class="comment">//再次判断，tab 的 index 处是否为 b</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">//转为树，略过不表</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>当插入一个元素后，如果链表的长度超过<code>TREEIFY_THRESHOLD == 8</code>，但整个 table 数组长度小于  <code>MIN_TREEIFY_CAPACITY</code>&#x3D;&#x3D;64，则进行扩容操作，如果超过了 <code>MIN_TREEIFY_CAPACITY</code> 则将链表转为树</p>
<h3 id="tryPresize-int-size"><a href="#tryPresize-int-size" class="headerlink" title="tryPresize(int size)"></a>tryPresize(int size)</h3><p>💡 尝试预处理 table 数组的容量以容纳给定的数量的元素</p>
<p>这个方法只在 treeifyBin() 以及 putAll() 中被调用</p>
<p>treeifyBin() 方法传入的 size 为 <code>table.length &lt;&lt; 1</code></p>
<p>putAll() 传入的 size 为 <code>m.size()</code> 即原 Map 的节点数</p>
<p>以 table.length &#x3D;&#x3D; 16 为例，调用该方法时候，size &#x3D; table.length &lt;&lt; 1 即 32，计算出来的 c 为 64，直到 c ≤ sc 时才会退出循环，则 sc 至少需要为 128 * 0.75 &#x3D; 96 才会退出循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试调整 table 数组的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 需要调整到的容量</span></span><br><span class="line"><span class="comment"> * 这个方法只在 treeifyBin() 以及 putAll() 中被调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据 size 的值计算约束出为一个正确的 2的次幂值</span></span><br><span class="line">    <span class="comment">//为 MAXIMUM_CAPACITY 或者是大于等于 (size * 1.5 + 1) 的最小的 2次幂</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// sc 为 sizeCtl 在本方法中的临时变量</span></span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//-------①--------</span></span><br><span class="line">            <span class="comment">//如果 table 还未初始化，则进行初始化操作</span></span><br><span class="line">            <span class="comment">// n 为新的数组容量</span></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">//同理，if 中的语句会通过 cas 将 sizeCtl 更新为 -1，表示正在初始化</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        <span class="comment">//计算 sc，即 n - 0.25 * n = 0.75 * n</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置新的阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">//-------②--------</span></span><br><span class="line">            <span class="comment">// c &lt;= sc 说明数组的容量已经足够了</span></span><br><span class="line">            <span class="comment">// n &gt;= MAXIMUM_CAPACITY 说明已经超过最大容量了</span></span><br><span class="line">            <span class="comment">//则退出循环，不处理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">//-------③--------</span></span><br><span class="line">            <span class="comment">//进行扩容操作</span></span><br><span class="line">            <span class="comment">//走到这里说明①和②的情况已经被排除掉了，即已经 table 数组已经初始化过了</span></span><br><span class="line">            <span class="comment">//并且c &lt;= sc不成立，即 sc &lt; c ，说明还没扩容完成</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//n 为 table 的容量</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//sc &lt; 0 因为数组已经初始化了，说明有其他线程正在扩容</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//sc 右移16位后，高16位为0，低16位为数组长度计算出的扩容标识</span></span><br><span class="line">                <span class="comment">//(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs:扩容标识不同</span></span><br><span class="line">                <span class="comment">//说明数组长度发生了变化，可能是别的线程触发了第二次扩容</span></span><br><span class="line">                <span class="comment">//sc == rs + MAX_RESIZERS:已经达到最大的扩容线程数量了</span></span><br><span class="line">                <span class="comment">//(nt = nextTable) == null :nextTable 还没创建</span></span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 需要迁移的区间已经被别的线程分完了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//实际上这里有两个 bug</span></span><br><span class="line">                <span class="comment">//1. sc == rs + 1</span></span><br><span class="line">                <span class="comment">//sc 现在是个负数，rs 高16位都为 0，无论如何 rs + 1 都不会等于 sc</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//2. sc == rs + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = (1 &lt;&lt; 16) -1 = 65535</span></span><br><span class="line">                <span class="comment">//rs 的取值范围为 [32769,32799] 而 rs + MAX_RESIZERS &gt; 0 并且还没溢出为负数</span></span><br><span class="line">                <span class="comment">//也无论如何都不会相等</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//将 rs 左移 16位，其高16位才是扩容标识，低16为存储扩容的线程数 + 1</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//下面这里对 sizeCtl 加一，表示参与迁移的线程数 +1，并进行迁移</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明自己是第一个进行扩容的线程，则通过 cas 的方式，将 rs 左移 16位并加2，存储在 sizeCtl 中</span></span><br><span class="line">            <span class="comment">//通过前面的 resizeStamp 方法我们直到 rs 的高16位为0，这里左移16位，则低16位都为0，再加2</span></span><br><span class="line">            <span class="comment">//则用低16为表示正在扩容的线程数，并且用 2 表示第一个正在扩容的线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h3><p>transfer(Node&lt;K,V&gt; tab, Node&lt;K,V&gt;[] nextTab)<br>💡 将旧数组的数据迁移到新的数组中，支持多线程迁移</p>
<h4 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a><strong>字段说明</strong></h4><p><code>transferIndex</code> 是个全局变量，通过 volatile 修饰，并通过 cas 的方式进行修改，用来表示当前线程应该从哪个地方开始往前遍历，如果 transferIndex &lt;&#x3D; 0 说明对数组的转移已经到头了，不需要再继续处理了</p>
<p><code>i</code> 字段表示当前线程在迁移的桶的索引</p>
<p><code>bound</code> 字段表示当前线程的需要迁移的区间的上边界</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>即每个线程的迁移区间为 [bound,transferIndex)，并通过 i 在该区间从后往前遍历桶进行迁移处理，遍历区间完成后，会继续竞争下一个区间</p>
<p>为了高效的进行迁移数据，这里允许多个线程进入，但是给每个线程分配了旧数组的一段区间进行迁移，避免多个线程同时迁移同个区间，代码中通过 cas 的方式，</p>
<p>让多个线程通过 cas 的操作竞争 transferIndex 字段，并通过 transferIndex 字段和 stride 计算出每个线程的迁移区间，所以线程在处理完竞争到的某个区间后，会不停地往前竞争处理下一个区间，直到处理到数组最前面的区间，比如说[0,16) 的区间后，transferIndex 等于 0，所以 i &#x3D; -1，</p>
<p>就会将 sizeCtl 中低16位中存储的线程数减1后 return，退出迁移，等到所有的线程对所有的区间处理完毕后，其他线程都退出迁移操作了，最后一个线程会将 finish 设置为 true，</p>
<p>再进行下一次循环后会将新的 nextTab 赋值给 table 并将 nextTable 置为空</p>
<p>从 HashMap 的迁移算法中我们也可以直到，对于一个节点，在扩容迁移后，要么还在原来的桶(假设索引为 index)中，要么就在索引为 2 * index 的桶处</p>
<p>同理在 ConcurrentHashMap 中也是这样子，所以不会造成多个线程同时转移到同一个桶中</p>
<p>首先会计算每个线程需要进行迁移的步长 stride，即迁移的桶的数量，至少为 16</p>
<p>在进行迁移时，会从后往前对 table 数组进行遍历，逐步对桶内的数据(链表或者树)进行迁移</p>
<p>由于篇幅太长，我们假设步长 stride 为4，举例进行说明</p>
<p><img src="https://s2.loli.net/2021/12/23/7uBlQZRbcPYH3Fm.png" alt="transfer_concurrenthashmap.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当第一个线程进行转移数据时，nextTab == null，否则为全局变量 nextTable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//计算步长 stride，至少为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="comment">//nextTab 为 null 说明是第一个线程进行转移</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个容量为旧数组容量两倍的新数组，并赋值给 nextTab</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">//如果产生 OOM 等异常，则直接退出，不转移了</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组赋值给 nextTable ，此时数组为一个没有数据的空数组</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//transferIndex 记录旧数组的长度，表示转移开始的索引值</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nextn 为新数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 是用来标识某个桶处正在转移的，存储了新数组</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//advance 是否前进，用来标记是否需要在区间内继续往前前进处理</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//finishing 是否扫描结束了，用来标记是否将所有的区间都迁移完成了</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="comment">//这里将 i 和 bound 初始化为 0，并开始死循环，直到数据转移成功后再退出循环</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在第一个线程第一次执行到这里时</span></span><br><span class="line">        <span class="comment">//--i == -1， bound == 0，第一个判断为 false</span></span><br><span class="line">        <span class="comment">//注意这里每次进入 while 循环都会做一次 --i 的操作，使得 i 不断的自减</span></span><br><span class="line">        <span class="comment">//nextIndex = transferIndex == n == tab.length 即旧数组的长度，大于0，第二个判断为 false</span></span><br><span class="line">        <span class="comment">//则走到第三个判断中</span></span><br><span class="line">        <span class="comment">//nextBound 为下一个线程需要进行转移的数组的下边界</span></span><br><span class="line">        <span class="comment">//计算 nextBound 的值，如果 nextIndex(即就数组的长度)大于步长 stride，</span></span><br><span class="line">        <span class="comment">//则 nextBound = nextIndex - stride，并通过 cas 的方式赋值</span></span><br><span class="line">        <span class="comment">//给全局变量 transferIndex，即下个线程需要转移的区间的下边界</span></span><br><span class="line">        <span class="comment">//下面的代码主要就是在第一次循环时，计算出来 [bound,transferIndex) 这个区间</span></span><br><span class="line">        <span class="comment">//在下一次 for 循环则会走到第一个判断中，直到 i &lt; bound 或者 finishing</span></span><br><span class="line">        <span class="comment">//当 i &lt; bound 时，即当前线程已经把分配给自己的区间里的桶都转移完毕了</span></span><br><span class="line">        <span class="comment">//如果此时别的线程还没有将整个数组转移完毕(transferIndex &lt;= 0 不成立)，</span></span><br><span class="line">        <span class="comment">//则当前线程会继续往前竞争下一个区间，这也就是如果只有一个线程的话，也可以迁移完成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="comment">//某个线程的第二次循环时候才会走到这里来，说明 i 还在该线程需要转移的区间内</span></span><br><span class="line">                <span class="comment">//[bound &lt;--&gt; i &lt;--&gt; transferIndex)</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明将已经到最前面了，将 i 赋值为 -1</span></span><br><span class="line">                <span class="comment">//则会走到 ③ 处执行，简单来说 ③ 处会做一些判断是否该线程要退出迁移操作</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//走到这里说明 i &lt; bound 且 transferIndex &gt; 0 (即整个 table 的转移还没处理完成)</span></span><br><span class="line">                <span class="comment">//通过 cas 继续认领一段区间进行转移</span></span><br><span class="line">                <span class="comment">//计算出当前线程所需要处理的区间</span></span><br><span class="line">                <span class="comment">//nextBound 就是下一个线程的下边界，也就是当先线程的上边界</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">//i 为索引值，所以需要 - 1</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//-----③----</span></span><br><span class="line">            <span class="comment">//如果 i &lt; 0 或者 i &gt;= n 说明已经超出了所需要处理的区间了</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//------①-----</span></span><br><span class="line">                <span class="comment">//如果 finishing 为 true ，说明所有的桶都处理完了</span></span><br><span class="line">                <span class="comment">//则将新的数组赋值给 table 并将 nextTable 置为空</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">//并且设置新的阈值，新数组的长度为 2n，所以阈值应该为 0.75 * 2n，即 2n - 0.5n</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//返回，结束迁移</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明 finishing 为 false，即还未处理完所有的桶</span></span><br><span class="line">            <span class="comment">//但当前线程需要处理的区间内的桶已经处理完了，所以将 sizeCtl 减一表示正在迁移的线程数 -1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//if 中为 true 说明当前线程不是最后一个在进行迁移的线程，返回，结束本线程的迁移</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//走到这里说明当前线程是第一个参与迁移的线程</span></span><br><span class="line">                <span class="comment">//将 finishing 和 advance 均设为 true</span></span><br><span class="line">                <span class="comment">//并把 i 设置为 n(即旧数组 table 的长度)</span></span><br><span class="line">                <span class="comment">//这样下一次循环就会走入 ① 处的逻辑结束迁移</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果索引为 i 的桶处为 null，则通过 cas 方式将 fwd 放在该桶处</span></span><br><span class="line">            <span class="comment">//接着将 advance 设置为 true，退出循环继续往前</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//如果索引为 i 处的桶上的数据不为空，且其 hash 值为 MOVED</span></span><br><span class="line">            <span class="comment">//代表该处的数据已经迁移过了，将 advance 设置为 true，退出循环继续往前</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，索引为 i 处的桶上有数据，则对桶处的头节点加锁</span></span><br><span class="line">            <span class="comment">//进行迁移，迁移完成后会将 advance 设置为 true</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//二次确认索引为 i 处的桶的节点为 f</span></span><br><span class="line">                    <span class="comment">//进行数据迁移，见后文细说</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表-x2F-树的转移"><a href="#链表-x2F-树的转移" class="headerlink" title="链表&#x2F;树的转移"></a>链表&#x2F;树的转移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果头节点 f 的 hash 值大于0，说明为链表</span></span><br><span class="line">        <span class="comment">//计算出 fh 和 n 的与运算的结果，由于 n 为数组的长度，是2的次幂，所以只有最高位为1，其他都为0</span></span><br><span class="line">        <span class="comment">//与运算计算出来后 runBit 要么为 0 ，要么为 n</span></span><br><span class="line">        <span class="comment">//如果 runBid == 0 说明扩容后 f 依旧在原来的 index 处，否则在 index + n 处</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">            <span class="comment">//遍历链表，找到第一个后面全部为相同的 runBit 的节点</span></span><br><span class="line">            <span class="comment">//举个例子</span></span><br><span class="line">            <span class="comment">//链表     ： A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G</span></span><br><span class="line">            <span class="comment">//runBit 值： n-&gt;0-&gt;n-&gt;0-&gt;0-&gt;0-&gt;0</span></span><br><span class="line">            <span class="comment">//则这个 for 循环跑完以后，lastRun 则为D，runBit = 0</span></span><br><span class="line">            <span class="comment">//后续则可以将这个 D 后面的所有节点都一起挪动过去，就不需要再一个一个处理</span></span><br><span class="line">            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                runBit = b;</span><br><span class="line">                lastRun = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 runBit == 0 说明这些节点还要放在相同 index 的桶里，赋值给 ln</span></span><br><span class="line">            ln = lastRun;</span><br><span class="line">            hn = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则 runBit == n 说明这些节点还要放在相同 index + n 的桶里，赋值给 hn</span></span><br><span class="line">            hn = lastRun;</span><br><span class="line">            ln = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">            <span class="comment">//循环，构建两个链表，将节点插入对应的链表的尾部</span></span><br><span class="line">            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 ln 插入新的 table 的 i 处</span></span><br><span class="line">        setTabAt(nextTab, i, ln);</span><br><span class="line">        <span class="comment">//将 ln 插入新的 table 的 i + n 处</span></span><br><span class="line">        setTabAt(nextTab, i + n, hn);</span><br><span class="line">        <span class="comment">//将旧的 table i 处置为 fwd</span></span><br><span class="line">        setTabAt(tab, i, fwd);</span><br><span class="line">        <span class="comment">//更新 advance 为 true，准备下次 for 循环</span></span><br><span class="line">        advance = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">        <span class="comment">//同理对 TreeBin 进行迁移</span></span><br><span class="line">        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    lo = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    loTail.next = p;</span><br><span class="line">                loTail = p;</span><br><span class="line">                ++lc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                    hi = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = p;</span><br><span class="line">                hiTail = p;</span><br><span class="line">                ++hc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">        setTabAt(nextTab, i, ln);</span><br><span class="line">        setTabAt(nextTab, i + n, hn);</span><br><span class="line">        setTabAt(tab, i, fwd);</span><br><span class="line">        advance = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="元素数量计数"><a href="#元素数量计数" class="headerlink" title="元素数量计数"></a>元素数量计数</h2><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><blockquote>
<p>获取 map 中键值对的数量</p>
</blockquote>
<p>返回 <code>sumCount</code> 方法的值，如果小于0，则返回0，如果超过了 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> n = sumCount();</span><br><span class="line">      <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">              (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">              (<span class="keyword">int</span>)n);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="sumCount"><a href="#sumCount" class="headerlink" title="sumCount()"></a>sumCount()</h3><p>返回 <code>baseCount</code> 和 <code>counterCells 列表中值的总和</code> 的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那这个 baseCount 和 counterCells 是什么呢，我们在前面 putVal 的流程中还没有介绍 addCount(1L,binCount) 这个方法。通过名字我们也能看出来这是个用来增加计数的方法</p>
<p>我们先来看这个方法</p>
<h3 id="addCount-long-x-int-check"><a href="#addCount-long-x-int-check" class="headerlink" title="addCount(long x,int check)"></a>addCount(long x,int check)</h3><p><code>x</code> 表示新增的节点数</p>
<p><code>check</code> 表示是否需要进行扩容检查，如果 &lt; 0 则不进行扩容</p>
<p>从前面 putVal 中我们可以知道，当一个键值对节点插入到链表中时， check 的值为链表的长度，当插入到红黑树中时，check 为 2</p>
<p>这个方法分为两个部分，前一部分是通过 LongAdder 的方式，进行计数，后半部分中会进行扩容迁移操作后，再进行计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//第一个判断：(as = counterCells) != null</span></span><br><span class="line">    <span class="comment">//表示 counterCells 已经被初始化了</span></span><br><span class="line">    <span class="comment">//第二个判断：将 baseCount 通过 cas 的方式修改为 baseCount + x</span></span><br><span class="line">    <span class="comment">//如果修改成功说明没有竞争</span></span><br><span class="line">    <span class="comment">//如果修改失败，说明存在竞争，则进入下面的逻辑对 counterCells 进行处理</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//前两个判断 as == null || (m = as.length - 1) &lt; 0 </span></span><br><span class="line">        <span class="comment">//判断 counterCells 是否初始化了，并且数组中是否有内容</span></span><br><span class="line">        <span class="comment">//如果为还未初始化或者数组中没有内容，则调用 fullAddCount(x, true)</span></span><br><span class="line">        <span class="comment">//第三个判断是在前两个判断都为 false 的基础上</span></span><br><span class="line">        <span class="comment">//进一步获取 counterCells 中当前线程所对应的 CounterCell 元素</span></span><br><span class="line">        <span class="comment">//如果为空，则调用 fullAddCount(x, true)</span></span><br><span class="line">        <span class="comment">//如果不为空，则尝试对 CounterCell 通过 cas 进行累加，累加成功则进行下一步</span></span><br><span class="line">        <span class="comment">//累加不成功说明存在竞争，则调用 fullAddCount(x, false)</span></span><br><span class="line">        <span class="comment">//uncontended 代表是否无竞争</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//详见后面的小节</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当 check &gt;= 0，则尝试是否需要扩容</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//当下面的三个条件都满足时，才会进入这里</span></span><br><span class="line">            <span class="comment">//1. 当 s (节点数量) &gt;= 阈值 sizeCtl 了</span></span><br><span class="line">            <span class="comment">//2. table 不为 null</span></span><br><span class="line">            <span class="comment">//3. table 的长度小于最大容量</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//rs 的高16位为0，低16为存储数组长度 n 计算出来的值</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;(</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//sc 右移16位后，高16位为0，低16位为数组长度计算出的扩容标识</span></span><br><span class="line">                <span class="comment">//(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs:扩容标识不同，</span></span><br><span class="line">                <span class="comment">//  说明数组长度发生了变化，可能是别的线程触发了第二次扩容</span></span><br><span class="line">                <span class="comment">//sc == rs + MAX_RESIZERS:已经达到最大的扩容线程数量了</span></span><br><span class="line">                <span class="comment">//(nt = nextTable) == null :nextTable 还没创建</span></span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 需要迁移的区间已经被别的线程分完了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//实际上这里有两个 bug</span></span><br><span class="line">                <span class="comment">//1. sc == rs + 1</span></span><br><span class="line">                <span class="comment">//sc 现在是个负数，rs 高16位都为 0，无论如何 rs + 1 都不会等于 sc</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//2. sc == rs + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = (1 &lt;&lt; 16) -1 = 65535</span></span><br><span class="line">                <span class="comment">//rs 的取值范围为 [32769,32799] 而 rs + MAX_RESIZERS &gt; 0 且还没溢出为负数</span></span><br><span class="line">                <span class="comment">//也无论如何都不会相等</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//将 rs 左移 16位，其高16位才是扩容标识，低16为存储扩容的线程数 + 1</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//不需要扩容</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//此时有别的线程在扩容了，则帮助进行扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//进行扩容，这里是第一个进行扩容的线程</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//进行计数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fullAddCount"><a href="#fullAddCount" class="headerlink" title="fullAddCount"></a>fullAddCount</h3><p>private final void fullAddCount(long x, boolean wasUncontended)</p>
<p><code>x</code>表示新增的节点数量</p>
<p><code>wasUncontented</code> 表示是否无竞争</p>
<pre><code>true == 表示没有竞争
false == 表示有竞争
</code></pre>
<p>在 ConcurrentHashMap 中，其实是复制了一份 LongAdder 的源码，在 ConcurrentHashMap 中，由于并发情况多，如果使用 AtomicLong 的方式进行记录，如果 N 个线程同时对 AtomicLong 进行修改，只有一个线程能修改成功，其他线程则会处于自旋等待状态，而 LongAdder 的方式是使用一个变量 baseCount+数组 CounterCell[]，让每个线程去维护自己的一个变量，减少碰撞冲突，每个线程维护数组中的一个对象，对象中存储一个值；从 CounterCell[] 中获取到对应的值并进行修改，如果修改失败，则尝试修改 baseCount 的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果还没有初始化，则进行初始化</span></span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        <span class="comment">//还没初始化，所以不存在竞争，将 wasUncontended 设置为 true</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//collide 表示是否多个线程 hash 到同一个 CounterCell 产生碰撞了</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 counterCells 不为 null 且 counterCells 长度大于 0</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//取到 counterCells 中对应线程的 CounterCell 为空</span></span><br><span class="line">                <span class="comment">//cellsBusy 字段为 1 说明 counterCells 正在初始化或者扩容</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//下面为尝试创建一个 CounterCell 对象并存到 counterCells 数组对应的索引处</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">//counterCells 为正常状态且修改 cellsBusy 为1 成功</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//j 是当前线程的 hash 值计算得出的索引</span></span><br><span class="line">                                <span class="comment">//对 counterCells 中 j 处的元素进行替换</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="comment">//创建成功，退出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//创建不成功，则进行下一次循环</span></span><br><span class="line">                        <span class="comment">//可能是因为 rs[j] != null，即该处有值了</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       </span><br><span class="line">                <span class="comment">// cas 失败了，则设置为 true，在下次循环的时候重新计算 hash 再进行分配</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="comment">//修改当前 CounterCell 中的 value 成功，则退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                <span class="comment">//counterCells != as 说明 counterCells 被扩容了</span></span><br><span class="line">                <span class="comment">//或者 as 大于等于 CPU 的数量了，等待下一轮重试</span></span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                <span class="comment">//上述条件都不满足，说明产生了碰撞，且竞争失败了</span></span><br><span class="line">                <span class="comment">//将值 collide 修改为 true，下一次循环就可以走到下个 if 中</span></span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//counterCells 处于正常状态，且修改 cellsBusy 值为1成功</span></span><br><span class="line">                <span class="comment">//则对 counterCells 进行扩容并迁移数据，</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新计算 hash 值</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;<span class="comment">//这里是 (as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0 这个条件结束的地方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//走到这里说明 counterCells 为空，则进行初始化，容量为2，并将 CounterCell 放进数组中</span></span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里说明 counterCells 为空，且竞争初始化失败了，则尝试将 x 加到 baseCount 上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们就看完了 ConcurrentHashMap 中的 put 的方法</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039055166">通俗易懂的JUC源码剖析-LongAdder&#x2F;LongAccumulator</a></li>
<li><a target="_blank" rel="noopener" href="https://xilidou.com/2018/11/27/LongAdder/">从 LongAdder 中窥见并发组件的设计思路
</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9x1V8DG3fv-4bgXYs5b6Hw">精妙绝伦的并发艺术品 — ConcurrentHashMap是如何保证线程安全的</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zerotomax/p/8687425.html">ConcurrentHashMap源码分析(1.8)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.meetkiki.com/archives/%E4%BB%8E%E6%AD%BB%E5%BE%AA%E7%8E%AFBUG%E6%9D%A5%E8%81%8A%E8%81%8AConcurrentHashMap%E7%9A%84%E6%89%A7%E8%A1%8C%E5%86%85%E5%B9%95(%E4%B8%8A)">从死循环BUG来聊聊ConcurrentHashMap的执行内幕（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hegongshan.com/2020/03/06/java-collections-api-concurrenthashmap/">Java容器探秘之旅 ConcurrentHashMap</a></li>
<li><a target="_blank" rel="noopener" href="http://ljh.gold/java-10/">ConcurrentHashMap</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>ConcurrentHashMap 源码阅读笔记</p><p><a href="https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/">https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>PPTing</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-12-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-02-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Map/">Map</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/02/17/2022_02_17_Java_Interrupt/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java 线程的中断机制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/11/24/2021_11_24_rxjava/"><span class="level-item">RxJava2 原理解析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f31447d117616c0f61c9bfc5d0753d49",
            repo: "ppting.github.io",
            owner: "PPTing",
            clientID: "8ee6c32324c60fd9fe83",
            clientSecret: "caabfe4dc60fd4b19575bcb4b754d5068a0f7a41",
            admin: ["PPTing"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/f10df62c29905b9b4ba7aaa81b28f152?s=128" alt="PPTing"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">PPTing</p><p class="is-size-6 is-block">Android Developer | Former Frisbee Player</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guangzhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">49</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">26</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PPTing" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:zhengkejian0@gmail.com"><i class="fas fa-inbox"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础知识"><span class="level-left"><span class="level-item">基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#常量"><span class="level-left"><span class="level-item">常量</span></span></a></li><li><a class="level is-mobile" href="#sizeCtl"><span class="level-left"><span class="level-item">sizeCtl</span></span></a></li><li><a class="level is-mobile" href="#Node-lt-K-V-gt"><span class="level-left"><span class="level-item">Node&lt;K,V&gt;</span></span></a></li><li><a class="level is-mobile" href="#构造方法"><span class="level-left"><span class="level-item">构造方法</span></span></a></li><li><a class="level is-mobile" href="#tableSizeFor-int-size"><span class="level-left"><span class="level-item">tableSizeFor(int size)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#添加元素"><span class="level-left"><span class="level-item">添加元素</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#put-方法"><span class="level-left"><span class="level-item">put 方法</span></span></a></li><li><a class="level is-mobile" href="#initTable"><span class="level-left"><span class="level-item">initTable()</span></span></a></li><li><a class="level is-mobile" href="#helpTransfer"><span class="level-left"><span class="level-item">helpTransfer</span></span></a></li><li><a class="level is-mobile" href="#resizeStamp-int-n"><span class="level-left"><span class="level-item">resizeStamp(int n)</span></span></a></li><li><a class="level is-mobile" href="#treeifyBin-Node-lt-K-V-gt-tab-int-index"><span class="level-left"><span class="level-item">treeifyBin(Node&lt;K,V&gt;[] tab,int index)</span></span></a></li><li><a class="level is-mobile" href="#tryPresize-int-size"><span class="level-left"><span class="level-item">tryPresize(int size)</span></span></a></li><li><a class="level is-mobile" href="#transfer"><span class="level-left"><span class="level-item">transfer()</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#字段说明"><span class="level-left"><span class="level-item">字段说明</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#链表-x2F-树的转移"><span class="level-left"><span class="level-item">链表/树的转移</span></span></a></li></ul></li><li><a class="level is-mobile" href="#元素数量计数"><span class="level-left"><span class="level-item">元素数量计数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#size"><span class="level-left"><span class="level-item">size()</span></span></a></li><li><a class="level is-mobile" href="#sumCount"><span class="level-left"><span class="level-item">sumCount()</span></span></a></li><li><a class="level is-mobile" href="#addCount-long-x-int-check"><span class="level-left"><span class="level-item">addCount(long x,int check)</span></span></a></li><li><a class="level is-mobile" href="#fullAddCount"><span class="level-left"><span class="level-item">fullAddCount</span></span></a></li></ul></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">小结</span></span></a></li><li><a class="level is-mobile" href="#参考链接"><span class="level-left"><span class="level-item">参考链接</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 PPTing</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>