<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Handler 消息机制 - PPTing&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="PPTing&#039;s Blog"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="PPTing&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在 Android 中，使用 Handler 主要用于不同线程间的通信 本文基于 Target 30 的 Android 源码进行分析"><meta property="og:type" content="blog"><meta property="og:title" content="Handler 消息机制"><meta property="og:url" content="https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/"><meta property="og:site_name" content="PPTing&#039;s Blog"><meta property="og:description" content="在 Android 中，使用 Handler 主要用于不同线程间的通信 本文基于 Target 30 的 Android 源码进行分析"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2021/06/08/7exYtmhbEU6k4IW.png"><meta property="og:image" content="https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png"><meta property="og:image" content="https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png"><meta property="article:published_time" content="2021-04-20T16:00:00.000Z"><meta property="article:modified_time" content="2023-11-17T02:32:56.014Z"><meta property="article:author" content="PPTing"><meta property="article:tag" content="Handler"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2021/06/08/7exYtmhbEU6k4IW.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/"},"headline":"Handler 消息机制","image":["https://i.loli.net/2021/06/08/7exYtmhbEU6k4IW.png","https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png","https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png"],"datePublished":"2021-04-20T16:00:00.000Z","dateModified":"2023-11-17T02:32:56.014Z","author":{"@type":"Person","name":"PPTing"},"publisher":{"@type":"Organization","name":"PPTing's Blog","logo":{"@type":"ImageObject","url":"https://ppting.me/favicon.ico"}},"description":"在 Android 中，使用 Handler 主要用于不同线程间的通信 本文基于 Target 30 的 Android 源码进行分析"}</script><link rel="canonical" href="https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-51029889-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-51029889-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
        <script>
            function switchTab(element) {
                const id = element.parentElement.id;
                const tabElements = element.parentElement.parentElement.children;
                const contentElements = element.parentElement.parentElement.parentElement.parentElement.children[1].children;
                for (let i = 0; i < tabElements.length; i++) {
                    const $tab = tabElements[i];
                    const $content = contentElements[i];
                    if ($tab.id === id) {
                        $tab.classList.add('is-active');
                    } else {
                        $tab.classList.remove('is-active');
                    }
                    if ($content.id === id) {
                        $content.classList.remove('is-hidden');
                    } else {
                        $content.classList.add('is-hidden');
                    }
                }
            }
        </script>
        <!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="PPTing's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-20T16:00:00.000Z" title="4/21/2021, 12:00:00 AM">2021-04-21</time>发表</span><span class="level-item"><time dateTime="2023-11-17T02:32:56.014Z" title="11/17/2023, 10:32:56 AM">2023-11-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span> / </span><a class="link-muted" href="/categories/Android/">Android</a><span> / </span><a class="link-muted" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></span><span class="level-item">43 分钟读完 (大约6391个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Handler 消息机制</h1><div class="content"><p>在 Android 中，使用 Handler 主要用于不同线程间的通信</p>
<p><em>本文基于 Target 30 的 Android 源码进行分析</em></p>
<span id="more"></span>
<p>先来看几个类</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Handler</strong> : 消息处理类，用来发送和处理 Message</p>
<p><strong>Looper</strong> : 循环器，将消息发送给 Handler 进行处理</p>
<p><strong>MessageQueue</strong> : 消息队列</p>
<p><strong>Message</strong> : 消息</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Handler-消息机制-UML-类图"><a href="#Handler-消息机制-UML-类图" class="headerlink" title="Handler 消息机制 UML 类图"></a>Handler 消息机制 UML 类图</h4><p><img src="https://i.loli.net/2021/06/08/7exYtmhbEU6k4IW.png" alt="Handler 消息机制 UML"></p>
<h4 id="消息机制类比图"><a href="#消息机制类比图" class="headerlink" title="消息机制类比图"></a>消息机制类比图</h4><p><img src="https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png" alt="Handler 消息机制.png"></p>
<h3 id="1-Example"><a href="#1-Example" class="headerlink" title="1. Example"></a>1. Example</h3><p>先来看个例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> button = Button(context)</span><br><span class="line">        setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT))</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                Looper.prepare()</span><br><span class="line">                <span class="keyword">val</span> looper = Looper.myLooper()!!</span><br><span class="line">                <span class="keyword">val</span> handler = MyHandler(looper)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> message = Message().apply &#123;</span><br><span class="line">                    what = <span class="number">1</span></span><br><span class="line">                    obj = <span class="string">&quot;message&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                handler.sendMessage(message)</span><br><span class="line"></span><br><span class="line">                Looper.loop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span></span>(looper: Looper) : Handler(looper)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">						<span class="comment">//①</span></span><br><span class="line">            Log.d(<span class="string">&quot;MyHandler&quot;</span>,<span class="string">&quot;thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span> msg.what is <span class="subst">$&#123;msg.what&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: thread is Thread-<span class="number">3</span></span><br><span class="line">MyHandler: thread is Thread-<span class="number">3</span> msg<span class="variable">.what</span> is <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>每点击一次按钮，会创建一个新的线程，并在该线程中通过 handler 将消息分发给 <code>MyHandler#handleMessage</code>  进行处理，在这个例子中，<code>MyHandler#handleMessage</code> 和 <code>thread&#123;&#125;</code></p>
<p>是同一个线程，并没有跨线程通信，所以对于线程间的通信来说，这个例子并没有什么意义，只是大概告知一下 Handler 的使用，但事实上，在 Android 的主线程(即 UI 线程、Main Thread) 就是通过这种方式对消息进行分发的</p>
<p>详见 <code>ActivityThread#main()</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......忽略一些细节</span></span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......忽略一些细节</span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在进行跨线程通信中，例如在子线程中做完耗时任务后，通知主线程更新UI</p>
<p>我们会在子线程中获取到主线程的 Looper <code>(Looper.getMainLooper())</code> 后，使用一个持有该 Looper 的 Handler 发送一个消息，而后在该 Handler 的 handlerMessage 方法中接收该消息进行更新UI 等操作</p>
<p>eg. 将上述例子中的 Handler 的 Looper 替换，则在 </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> handler = MyHandler(Looper.getMainLooper())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> message = Message().apply &#123;</span><br><span class="line">        what = <span class="number">1</span></span><br><span class="line">        obj = <span class="string">&quot;message&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    handler.sendMessage(message)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志如下：</p>
<ul>
<li>可见已经切换到主线程中接收到信息了</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: thread is Thread[main,<span class="number">5</span>,main]</span><br><span class="line">MyHandler: thread is main msg<span class="variable">.what</span> is <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过以上的例子，我们来分析 Android 中的消息机制到底是如何运作的</p>
<h2 id="2-Looper"><a href="#2-Looper" class="headerlink" title="2. Looper"></a>2. Looper</h2><h3 id="2-1-prepare"><a href="#2-1-prepare" class="headerlink" title="2.1 prepare()"></a>2.1 prepare()</h3><blockquote>
<p>将当前线程初始化为循环线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，第一次调用 prepare() 方法时会在当前线程中 new 一个 Looper 对象，并保存在该线程的 mThreadLocal 中</p>
<p>若在同个线程中多次调用 prepare 方法，则会走到 if 的 case 中抛出异常</p>
<p><em><strong>因此保证在同一个线程中只有一个 Looper 对象存在</strong></em></p>
<h3 id="2-2-myLooper"><a href="#2-2-myLooper" class="headerlink" title="2.2 myLooper()"></a>2.2 myLooper()</h3><blockquote>
<p>获取当前线程 looper 的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    returnsThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即返回在 <code>prepare()</code> 方法中保存的 Looper 对象</p>
<h3 id="2-3-loop"><a href="#2-3-loop" class="headerlink" title="2.3 loop()"></a>2.3 loop()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Looper 还没有初始化，则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me.mInLoop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                        + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//开始进入死循环</span></span><br><span class="line">            <span class="comment">//获取消息队列中的第一条消息，可能回阻塞</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果当前没有需要处理的消息，则返回，继续下一个循环</span></span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                        msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//消息不为空，分发给消息对应的 target(即 Handler)去处理</span></span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该消息处理完了，将其回收复用</span></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可见 loop() 方法中是一个 <code>for(;;)</code> 的死循环</p>
<p>大概分成：</p>
<ol>
<li>从当前 looper 对应的 messageQueue 中通过 ,mQueue.next() 方法获取下一个 Message[该方法可能会阻塞，详见 5.2 MessageQueue#next()]</li>
<li>分发给 Message 对应的 target (即 Handler)[ target 赋值见 4.3.1 android.os.Handler#enqueueMessage] 交由 Handler 的 dispatchMessage [见 4.4 android.os.Handler#dispatchMessage] 去处理</li>
<li>最后再将 Message 进行回收利用[见 3.3 Message#recycleUnchecked()]</li>
</ol>
<p>接着不断的重复这个过程</p>
<p>由于 loop() 方法中进行的是死循环，所以在 loop() 方法后的代码是不会被调用到的</p>
<p>loop() 方法中，获取下一条消息的方法 <code>messageQueue.next()</code> 是阻塞的，所以当 messageQueue 中没有新的消息了，loop() 会阻塞住[见 MessageQueue#next()]，所以不会造成 CPU 的高消耗</p>
<h2 id="3-Message"><a href="#3-Message" class="headerlink" title="3. Message"></a>3. Message</h2><p>Message 是整个消息分享机制中的「信使」，将信息从 A 带给 B</p>
<p>Message 类中包含以下一些字段</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>what</td>
<td>Int</td>
<td>开发者自定义的一个 code 字段，用来标识是什么类型的消息后续进行处理</td>
</tr>
<tr>
<td>arg1</td>
<td>Int</td>
<td>arg1 和 arg2 都是用来存储数据的备选方案，如果需要存储的数据不多而不想使用 data 的话，则可以考虑使用该字段</td>
</tr>
<tr>
<td>arg2</td>
<td>Int</td>
<td>同上</td>
</tr>
<tr>
<td>data</td>
<td>Bundle</td>
<td>用于在 Message 中存储自定义数据</td>
</tr>
<tr>
<td>obj</td>
<td>Object</td>
<td>用于发送给接受者的任意对象，注意，如果使用 Messager 在跨进程中的发送数据时，只能发送 framework 中的 Parcelable 对象，且不能为 null，不能发送自定义的 Parcelable 对象，要发送自定义的 Parcelable 对象应该使用 setData 方法</td>
</tr>
<tr>
<td>when</td>
<td>Long</td>
<td>Message 的目标发送处理时间，这个时间是基于系统开机时间计算的SystemClock#uptimeMillis</td>
</tr>
<tr>
<td>target</td>
<td>Handler</td>
<td>用于处理该消息的 Handler</td>
</tr>
<tr>
<td>callback</td>
<td>Runable</td>
<td>Runnable 类型</td>
</tr>
<tr>
<td>next</td>
<td>Message</td>
<td>Message 的下一个 Message，可见 Message 是一个单链表的数据结构</td>
</tr>
<tr>
<td>sPool</td>
<td>Message</td>
<td>用来做 Message 的缓存池</td>
</tr>
</tbody></table>
<h3 id="3-1-obtain"><a href="#3-1-obtain" class="headerlink" title="3.1 obtain()"></a>3.1 obtain()</h3><blockquote>
<p>从 Message 缓存池中获取一个 Message 对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sPoolSync 是一个锁对象，用来在对 Message 进行复用回收时候进行线程同步处理，避免多线程访问时的内存数据共享错误</p>
<p>首先通过上面的 Message#next 我们知道 Message 是一个单链表的数据结构</p>
<p>obtain() 方法判断当 sPool 不为空时，即已经有被创建出来的 Message 对象了，则赋值给 <code>m</code> 并将 <a target="_blank" rel="noopener" href="http://m.next/"><code>m.next</code></a>  赋值给 sPool，即将单链表中的第一个节点取出，并将第二个节点作为 sPool ，即剩下的链表继续作为缓存池，同时将缓存池的数量减一。最后将需要返回的 <code>m</code> 的 next 赋值为 null，清除 flag 等并返回 <code>m</code></p>
<h3 id="3-2-recycler"><a href="#3-2-recycler" class="headerlink" title="3.2 recycler()"></a>3.2 recycler()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先检查该 Message 是否还在被使用，如果还在被使用则抛出异常，否则对该 Message 进行回收，详见 <strong>3.3 recyclerUnchecked()</strong></p>
<h3 id="3-3-recyclerUnchecked"><a href="#3-3-recyclerUnchecked" class="headerlink" title="3.3 recyclerUnchecked()"></a>3.3 recyclerUnchecked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就很简单了，将 Message 的成员变量都还原为初始化状态，接着将该 Message 插入到缓存池链表的头部，并更新缓存池的数量</p>
<h2 id="4-Handler"><a href="#4-Handler" class="headerlink" title="4. Handler"></a>4. Handler</h2><h3 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...忽略...</span></span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个构造方法的区别在于是否有 Looper 参数</p>
<p>如果没有传入 Looper 参数，则会调用 Looper.myLooper() 方法获取当前线程中的 Looper 赋值给 mLooper ，如果当前线程的 Looper 还未初始化，则抛出异常</p>
<h3 id="4-2-sendMessageDelayed-Message-msg-long-updateMillis"><a href="#4-2-sendMessageDelayed-Message-msg-long-updateMillis" class="headerlink" title="4.2 sendMessageDelayed(Message msg , long updateMillis)"></a>4.2 sendMessageDelayed(Message msg , long updateMillis)</h3><p>Handler 中的 <code>post(Runnable r)</code> 、<code>postDelayed(@NonNull Runnable r, long delayMillis)</code> 等等方法最终都会调用 <code>boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis)</code> 方法，我们先来看如何将 Runnable 转为 Message 的方法，再接着看 sendMessageAtTime</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个值得注意点是，传入 sendMessageAtTime 方法中的第二个参数是用的是 SystemClock.uptimeMillis() 即当前距离开机的时间，使用这个时间就不会因为机器的时间戳变化而导致不准确的问题</p>
<h3 id="4-2-1-getPostMessage-Runnable-r"><a href="#4-2-1-getPostMessage-Runnable-r" class="headerlink" title="4.2.1  getPostMessage(Runnable r)"></a>4.2.1  getPostMessage(Runnable r)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即从缓存池中获取一个 Message 对象，并将其 callback 设置为传入的 Runnable 对象</p>
<p>至于这个 callback 的作用，详见 4.4 dispatchMessage</p>
<h3 id="4-3-sendMessageAtTime-Message-msg-long-uptimeMillis"><a href="#4-3-sendMessageAtTime-Message-msg-long-uptimeMillis" class="headerlink" title="4.3 sendMessageAtTime(Message msg, long uptimeMillis)"></a>4.3 sendMessageAtTime(Message msg, long uptimeMillis)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sendMessageAtTime</code> 方法会先判断当前 Handler 中的消息队列 mQueue 是否为空，如果为空则抛出异常并打印日志返回</p>
<p>否则调用 <code>enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,long uptimeMillis)</code> 方法将该 Message 消息对象放入消息队列中</p>
<h3 id="4-3-1-enqueueMessage-MessageQueue-queue-Message-msg-long-updateMillis"><a href="#4-3-1-enqueueMessage-MessageQueue-queue-Message-msg-long-updateMillis" class="headerlink" title="4.3.1 enqueueMessage(MessageQueue queue,Message msg,long updateMillis)"></a>4.3.1 enqueueMessage(MessageQueue queue,Message msg,long updateMillis)</h3><p>将 Message 的 target 设置为当前的 Handler 对象，并压入 MessageQueue 队列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue 的 enqueueMessage 方法详见 5.1 MessageQueue#enqueueMessage()</p>
<h3 id="4-4-dispatchMessage"><a href="#4-4-dispatchMessage" class="headerlink" title="4.4 dispatchMessage"></a>4.4 dispatchMessage</h3><p>在 4.3.1 方法中，enqueueMessage 方法将 Message 压入 MessageQueue 后，会被 2.3 Looper#loop() 不停获取队列中的 Message 并交由其 target(即 Handler) 处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断 msg 的 callback 是否为空，如果不为空，则调用该 callback 的 run 方法</p>
<blockquote>
<p>由 3. Message 中我们知道 callback 就是一个 Runnable 对象</p>
</blockquote>
<p>如果 callback 为空，则判断 Handler 的成员变量 mCallback 是否为空，如果不为空，则调用其接口方法 <code>boolean andlerMessage(Message msg)</code> ，由实现了该 Handler.Callback 接口的子类自行处理</p>
<p>如果 Handler 中设置了 Handler.Callback，则回调其 handleMessage 方法对消息进行处理，否则则调用 <code>public void handleMessage(@NonNull Message msg)</code> 方法，由子类  Override 该方法对信息进行处理</p>
<blockquote>
<p>PS. 如果 Handler.Callback 的 handleMessage() 方法返回了 true，则代表不再需要对该消息进行处理，否则还会调用 handleMessage 方法对该消息进行处理</p>
</blockquote>
<h2 id="5-MessageQueue"><a href="#5-MessageQueue" class="headerlink" title="5. MessageQueue"></a>5. MessageQueue</h2><blockquote>
<p>MessageQueue 是一个消息队列</p>
</blockquote>
<h3 id="5-1-enqueueMessage"><a href="#5-1-enqueueMessage" class="headerlink" title="5.1 enqueueMessage()"></a>5.1 enqueueMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果 Message 没有设置 target 则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="comment">//如果该 message 已经在使用了，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将消息标记为在使用中</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="comment">//将执行时间赋值给 when</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//如果 p == null(即当前消息队列没有消息)</span></span><br><span class="line">            <span class="comment">//或者 when == 0(即该消息需要立即处理)</span></span><br><span class="line">            <span class="comment">//或者 when &lt; p.when(即该消息比当前队列中的消息的需要执行的时间要早)</span></span><br><span class="line">            <span class="comment">//则将该消息插入到最前面处理</span></span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">//将消息插入到队列中间</span></span><br><span class="line">            <span class="comment">//通常来说，我们不需要唤醒事件队列，除非在队列的头是一个屏障消息(target == null),并且要插入的消息是队列中的第一个异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//下面是个死循环，直到找到队列中的消息的执行时间(when 字段)小于该插入消息的时间的，插在其前面，如果没有，则插入到队列最后面</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    <span class="comment">//如果 p 是异步消息，说明要插入的消息不是第一个异步消息(因为走到这里来说明要插入的消息是插入到了 p 后面了)所以不需要唤醒</span></span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 <code>when</code> 是指需要执行的时间戳(用距离机器开机的时间来计算)</p>
<ul>
<li>先判断 Message 的 target 是否为空，为空则抛出异常</li>
<li>再判断 Message 是否被使用了，如果该 Message 已经被使用了则抛出异常</li>
<li>再判断是否已经退出了，如果已经退出了则将 Message 回收并返回 false</li>
<li>以上检查无异常后，将 Message 标记为在使用</li>
</ul>
<p>着重看一下后面的一段代码</p>
<p>判断 </p>
<ol>
<li>p 是否为空(<em>即当前的消息队列为空</em>) </li>
<li>when &#x3D;&#x3D; 0(<em>即该消息需要立即执行</em>)</li>
<li>when&lt; p.when(即该消息的执行时间早于消息队列的第一条消息的执行时间)</li>
</ol>
<p>如果满足以上任何一个条件，则将该 Message 插入到队列的头部</p>
<p>否则对 消息队列进行遍历，直到将该消息插入到执行时间都比该消息小的消息后面</p>
<p>可见，MessageQueue 是按照 Message.when 对消息进行排序的，链表中的 Message 按照 when 的大小排序</p>
<h3 id="5-2-next"><a href="#5-2-next" class="headerlink" title="5.2 next()"></a>5.2 next()</h3><p>next() 内部有一个 for(;;) 的死循环，一直从 Message 链表中获取符合条件的 Message 并进行返回<br>如果在某次循环中获取不到 msg ，则会去处理 idle handler ，处理完后将 pendingIdleHandlerCount 置为 0，保证下次循环不处理 idle 了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">//如果消息循环已经退出并且被处理了，则会在这里 return</span></span><br><span class="line">    <span class="comment">//这种情况可能发生在如果应用尝试在退出后重启 looper </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里会进行休眠，相对应的 nativeWait() 会进行唤醒</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="comment">//尝试检索下一条消息，如果找到了就返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//当前消息队列不为空，且 target 为 null，注意这里的 target 为 null</span></span><br><span class="line">                <span class="comment">//则从消息队列中找到异步的 Message</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                <span class="comment">//msg 不为空且为同步的消息，则继续循环直到找到异步的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时 msg 就是第一个需要进行处理的 Message（可能是消息屏障后的第一个消息，也可能是原本消息队列中的头，即 mMessage）</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//如果当前时间还没到消息需要处理的时间，则设置一个延时时间，这里不会 return Message，</span></span><br><span class="line">                    <span class="comment">//如果还没到消息需要处理的时间，所以 for 循环会一直进入这个 case 导致阻塞在这里</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//消息需要处理，则将该消息返回，并将链表的第二个数据移到链表头，并退出循环</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 prevMsg 不为 null，说明 msg 为需要处理的异步消息，被提前取出来处理了</span></span><br><span class="line">                        <span class="comment">//而 prevMsg 就是该消息的前一个消息，现在将 msg.next 链接到 prevMsg.next 的后面，(其实就相当于删除了中间的 msg)</span></span><br><span class="line">                        <span class="comment">//此时的 mMessage 还是原来的 mMessage，下次进入 next() 方法 mMessage 还是原来的那个</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//将链表的第二个数据移到链表头</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果第一次闲置，则会获取 idleHandlers 的数量</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果 idleHandler 数量小于0，则跳过后面的 idleHandler 的逻辑，继续下一个 next() 循环</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将外部添加进来的 mIdleHandlers 列表拷贝到 mPendingIdleHandlers 数组中</span></span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">//运行 idle Handler 的逻辑，这里只可能在第一次 for 循环的迭代时被执行</span></span><br><span class="line">        <span class="comment">//(因为后面将 pendingIdleHandlerCount 置为 0了，所以导致后续 pendingIdleHandlerCount 一直为 0)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//IdleHandler 各自处理逻辑，并返回是否需要被移除</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="comment">//如果返回需要被移除，则移除该 idleHandler</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">//将待办的闲置 IdleHandler 的数量置为 0 </span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-quit"><a href="#5-3-quit" class="headerlink" title="5.3 quit()"></a>5.3 quit()</h3><p>将 mQuitting 标志位置为 true，后续 MessageQueue 的 next() 方法等地方 使用该字段做判断后进行处理</p>
<h2 id="6-消息同步屏障"><a href="#6-消息同步屏障" class="headerlink" title="6. 消息同步屏障"></a>6. 消息同步屏障</h2><blockquote>
<p>同步屏障，顾名思义，将同步的消息给挡住，优先处理非同步(即异步)的消息</p>
</blockquote>
<p>从以上我们 MessageQueue#next() 中，我们知道从 MessageQueue 中获取队列中的消息时，会优先获取异步的消息(msg.isAsynchronous() &#x3D;&#x3D; true)进行处理</p>
<h3 id="6-1-如何开启同步屏障"><a href="#6-1-如何开启同步屏障" class="headerlink" title="6.1 如何开启同步屏障"></a>6.1 如何开启同步屏障</h3><p>按理来说，要开启同步屏障，我们只需要在 <code>MessageQueue#postSyncBarrier(long when)</code> 方法中，会在 MessageQueue 消息队列的队头插入一个 message(这个 Message 的 target 为 null) 即可</p>
<p>这个 message 仅仅作为一个标志存在，并不用来分发事件，<br>当 looper 在进行循环🔄时，调用 queue.next() 方法，当遇到 <code>message.target == null</code> ，则会从 MessageQueue 中找到异步的消息并返回</p>
<p>但是由上文可知，在调用 <code>enqueueMessage</code> 方法后，会将 msg 的 target 赋值为当前的 Handler 导致我们的上面想插入一个 target &#x3D;&#x3D; null 的 Message 的想法不成立</p>
<p>并且 <code>MessageQueue#postSyncBarrier()</code> 方法并不开放给开发者使用，所以要开启同步屏障，我们只能通过反射该方法进行调用</p>
<p>而如果直接使用 <code>Handler.sendMessage()</code> 等方法插入消息，会根据时间顺序插入到队列中，如果要立即生效，则需要将消息插入队列队头，如何将消息插入到队列头部，详见 *** 6.3 如何将消息插入队列头部 ***</p>
<h3 id="6-2-如何插入异步消息"><a href="#6-2-如何插入异步消息" class="headerlink" title="6.2 如何插入异步消息"></a>6.2 如何插入异步消息</h3><ol>
<li><p>构造异步 Handler<br>从 <code>4.3.1 enqueueMessage</code> 中可以看到，当 <code>mAsynchronous</code> 字段为 true 时候，会将 message 设置为异步消息<br>所以只需要在构造 Handler 的时候，将构造方法中的 async 字段设置为 true 即可，则后续所有的消息都会是异步的消息</p>
</li>
<li><p>构造异步的 Message</p>
</li>
</ol>
<p>在构造 Message 时，通过 <code>setAsynchronous(boolean async)</code> 方法设置该消息为异步消息即可</p>
<h3 id="6-3-如何将消息插入队列头部"><a href="#6-3-如何将消息插入队列头部" class="headerlink" title="6.3 如何将消息插入队列头部"></a>6.3 如何将消息插入队列头部</h3><p>由上述分析我们知道通过 <code>Handler#enqueMessage()</code> 方法将消息插入 <code>MessageQueue</code> 中，会根据 <code>message.when</code> 由小到大插入到队列中，如果需要将消息插入到队头，那么应该使得 <code>when</code> 为 0，但 <code>when</code> 这个参数也是不支持开发者修改的</p>
<p>但是 <code>Handler</code> 中提供了一个 <code>Handler#postAtFrontOfQueue</code> (最终调用 <code>Handler#sendMessageAtFrontOfQueue</code>) 方法。这个方法在将消息插入队列前，会将 when 设置为0，则会将该消息插入到消息队列的队头</p>
<h3 id="何时会插入同步屏障"><a href="#何时会插入同步屏障" class="headerlink" title="何时会插入同步屏障"></a>何时会插入同步屏障</h3><p>在绘制流程中，ViewRootImpl 的 requestLayout 方法中会调用 postSyncBarrier 方法开启同步屏障优先绘制 UI </p>
<h2 id="7-举例"><a href="#7-举例" class="headerlink" title="7. 举例"></a>7. 举例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> normalHandler <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Handler(Looper.getMainLooper(),<span class="keyword">object</span> : Handler.Callback&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;普通 Handler 回调 msg is <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> asyncHandler <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Handler.createAsync(Looper.getMainLooper(),<span class="keyword">object</span> : Handler.Callback&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;异步 Handler 回调 msg is <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSendNormalMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessage start&quot;</span>)</span><br><span class="line">    normalHandler.sendMessage(Message().apply &#123; obj = <span class="string">&quot;普通 Handler 调用 sendMessage 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessage end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessageAtFrontOfQueue start&quot;</span>)</span><br><span class="line">    asyncHandler.sendMessageAtFrontOfQueue(Message().apply &#123; obj = <span class="string">&quot;异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessageAtFrontOfQueue end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessage start&quot;</span>)</span><br><span class="line">    asyncHandler.sendMessage(Message().apply &#123; obj = <span class="string">&quot;异步 Handler 调用 sendMessage 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessage end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessageAtFrontOfQueue start&quot;</span>)</span><br><span class="line">    normalHandler.sendMessageAtFrontOfQueue(Message().apply &#123; obj = <span class="string">&quot;普通 Handler 调用 sendMessageAtFrontOfQueue 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessageAtFrontOfQueue end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通 Handler sendMessage start</span><br><span class="line">普通 Handler sendMessage end</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">异步 Handler sendMessage start</span><br><span class="line">异步 Handler sendMessage end</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">普通 Handler 回调 msg is &#123; when=-4d23h57m46s154ms what=0 obj=同步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-4d23h57m46s154ms what=0 obj=异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">普通 Handler 回调 msg is &#123; when=-13ms what=0 obj=普通 Handler 调用 sendMessage 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-13ms what=0 obj=异步 Handler 调用 sendMessage 发送的消息 target=android.os.Handler &#125;</span><br></pre></td></tr></table></figure>

<p>此时的 asyncHandler 并不能将其消息插入到消息队列的最前面，而是取决于其插入的顺序，后调用 <code>sendMessageAtFrontOfQueue</code> 的消息后插入到前面去</p>
<p>如果要使得 asyncHandler 插入的消息能优先处理，则需要同步屏障起作用，我们先通过反射开启一下同步屏障，再在使用完毕后关闭同步屏障</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private var barrierToken = 0</span><br><span class="line"></span><br><span class="line">fun startReflectPostSyncBarrier(looper: Looper)&#123;</span><br><span class="line">    val method: Method = MessageQueue::class.java.getDeclaredMethod(&quot;postSyncBarrier&quot;)</span><br><span class="line">    barrierToken = method.invoke(looper.queue) as Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun stopReflectPostSyncBarrier(looper: Looper)&#123;</span><br><span class="line">    val method = MessageQueue::class.java</span><br><span class="line">        .getDeclaredMethod(&quot;removeSyncBarrier&quot;, Int::class.javaPrimitiveType)</span><br><span class="line">    method.invoke(looper.queue, barrierToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>testSendNormalMessage</code> 方法前先调用 <code>startReflectPostSyncBarrier</code> 方法，建立起同步屏障</p>
<p>日志打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">普通 Handler sendMessage start</span><br><span class="line">普通 Handler sendMessage end</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">异步 Handler sendMessage start</span><br><span class="line">异步 Handler sendMessage end</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">普通 Handler 回调 msg is &#123; when=-5d0h9m7s27ms what=0 obj=普通 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-5d0h9m7s27ms what=0 obj=异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-11ms what=0 obj=异步 Handler 调用 sendMessage 发送的消息 target=android.os.Handler &#125;</span><br></pre></td></tr></table></figure>
<p><code>startReflectPostSyncBarrier()</code> 方法建立起了同步屏障，即往消息队列中插入了一条 target &#x3D; null 的消息，且 <code>msg.when</code> 的值为当前时间<br>由于普通(同步)的 Handler 将插入了一条消息到消息队列最前面，when &#x3D;&#x3D; 0，所以导致会先处理该普通消息，然后再遇到了 target &#x3D;&#x3D; null 的消息，则开始遍历异步消息进行处理，如果不调用 <code>android.os.MessageQueue#removeSyncBarrier</code> 方法将 <code>target == null</code> 的消息移除掉，则该 MessageQueue 中的同步消息就一直无法得到处理</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用以下一幅图来总结 Android 中的消息分发机制</p>
<p>Looper 像是一个发动机，不停地将生产者产生的 Message 从传送带(MessageQueue) 中分发给消费者去处理</p>
<p><img src="https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png" alt="Handler 消息机制.png"></p>
<p>本文参考：</p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制1-Handler(Java层)</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Handler 消息机制</p><p><a href="https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/">https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>PPTing</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-04-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Handler/">Handler</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/07/2021_05_07_bitmap_in_android/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android 中的图片内存</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/01/2021_04_01_java_string_encode/"><span class="level-item">Java 字符串编码</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f6831bd0bc4b52efc3e2906cd20646a2",
            repo: "ppting.github.io",
            owner: "PPTing",
            clientID: "8ee6c32324c60fd9fe83",
            clientSecret: "caabfe4dc60fd4b19575bcb4b754d5068a0f7a41",
            admin: ["PPTing"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/f10df62c29905b9b4ba7aaa81b28f152?s=128" alt="PPTing"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">PPTing</p><p class="is-size-6 is-block">Android Developer | Former Frisbee Player</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guangzhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PPTing" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:zhengkejian0@gmail.com"><i class="fas fa-inbox"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">概念</span></span></a></li><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Handler-消息机制-UML-类图"><span class="level-left"><span class="level-item">Handler 消息机制 UML 类图</span></span></a></li><li><a class="level is-mobile" href="#消息机制类比图"><span class="level-left"><span class="level-item">消息机制类比图</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-Example"><span class="level-left"><span class="level-item">1. Example</span></span></a></li></ul><li><a class="level is-mobile" href="#2-Looper"><span class="level-left"><span class="level-item">2. Looper</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-prepare"><span class="level-left"><span class="level-item">2.1 prepare()</span></span></a></li><li><a class="level is-mobile" href="#2-2-myLooper"><span class="level-left"><span class="level-item">2.2 myLooper()</span></span></a></li><li><a class="level is-mobile" href="#2-3-loop"><span class="level-left"><span class="level-item">2.3 loop()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-Message"><span class="level-left"><span class="level-item">3. Message</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-obtain"><span class="level-left"><span class="level-item">3.1 obtain()</span></span></a></li><li><a class="level is-mobile" href="#3-2-recycler"><span class="level-left"><span class="level-item">3.2 recycler()</span></span></a></li><li><a class="level is-mobile" href="#3-3-recyclerUnchecked"><span class="level-left"><span class="level-item">3.3 recyclerUnchecked()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-Handler"><span class="level-left"><span class="level-item">4. Handler</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-构造方法"><span class="level-left"><span class="level-item">4.1 构造方法</span></span></a></li><li><a class="level is-mobile" href="#4-2-sendMessageDelayed-Message-msg-long-updateMillis"><span class="level-left"><span class="level-item">4.2 sendMessageDelayed(Message msg , long updateMillis)</span></span></a></li><li><a class="level is-mobile" href="#4-2-1-getPostMessage-Runnable-r"><span class="level-left"><span class="level-item">4.2.1  getPostMessage(Runnable r)</span></span></a></li><li><a class="level is-mobile" href="#4-3-sendMessageAtTime-Message-msg-long-uptimeMillis"><span class="level-left"><span class="level-item">4.3 sendMessageAtTime(Message msg, long uptimeMillis)</span></span></a></li><li><a class="level is-mobile" href="#4-3-1-enqueueMessage-MessageQueue-queue-Message-msg-long-updateMillis"><span class="level-left"><span class="level-item">4.3.1 enqueueMessage(MessageQueue queue,Message msg,long updateMillis)</span></span></a></li><li><a class="level is-mobile" href="#4-4-dispatchMessage"><span class="level-left"><span class="level-item">4.4 dispatchMessage</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-MessageQueue"><span class="level-left"><span class="level-item">5. MessageQueue</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-enqueueMessage"><span class="level-left"><span class="level-item">5.1 enqueueMessage()</span></span></a></li><li><a class="level is-mobile" href="#5-2-next"><span class="level-left"><span class="level-item">5.2 next()</span></span></a></li><li><a class="level is-mobile" href="#5-3-quit"><span class="level-left"><span class="level-item">5.3 quit()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-消息同步屏障"><span class="level-left"><span class="level-item">6. 消息同步屏障</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-如何开启同步屏障"><span class="level-left"><span class="level-item">6.1 如何开启同步屏障</span></span></a></li><li><a class="level is-mobile" href="#6-2-如何插入异步消息"><span class="level-left"><span class="level-item">6.2 如何插入异步消息</span></span></a></li><li><a class="level is-mobile" href="#6-3-如何将消息插入队列头部"><span class="level-left"><span class="level-item">6.3 如何将消息插入队列头部</span></span></a></li><li><a class="level is-mobile" href="#何时会插入同步屏障"><span class="level-left"><span class="level-item">何时会插入同步屏障</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-举例"><span class="level-left"><span class="level-item">7. 举例</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 PPTing</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>