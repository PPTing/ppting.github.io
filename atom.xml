<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PPTing&#39;s Blog</title>
  
  <subtitle>美好的事物总是稍纵即逝，不记往昔，珍惜当下</subtitle>
  <link href="https://ppting.me/atom.xml" rel="self"/>
  
  <link href="https://ppting.me/"/>
  <updated>2022-02-19T14:10:44.014Z</updated>
  <id>https://ppting.me/</id>
  
  <author>
    <name>PPTing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 并发编程之 AQS</title>
    <link href="https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/"/>
    <id>https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/</id>
    <published>2022-02-19T13:13:26.000Z</published>
    <updated>2022-02-19T14:10:44.014Z</updated>
    
    <content type="html"><![CDATA[<br><p>AQS，全称为 <strong>AbstractQueuedSynchronizer</strong>，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制<br>其中封装了 FIFO(first in first out) 的队列</p><span id="more"></span><h3 id="AQS-的「范式」"><a href="#AQS-的「范式」" class="headerlink" title="AQS 的「范式」"></a>AQS 的「范式」</h3><p>继承 AQS 的实现 <em>Sync 类</em>都需要遵守一定的「范式」<br>一般来说，一个锁的实现，要么是独占式的，要么是共享式的，AQS 中需要开发者 override 以下的方法，但对于某一种锁实现(独占式&#x2F;共享式)来说，只需要 override 其中的一对即可</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>独占式尝试获取锁状态，返回值表示是否获取到锁</td></tr><tr><td>boolean tryRelease(int arg)</td><td>独占式尝试释放锁状态，返回值表示<strong>锁状态是否完全被释放</strong>而非是否释放成功，因为在可重入锁的情况下，释放后当前线程可能还持有者该所状态</td></tr><tr><td>int tryAcquireShare(int arg)</td><td>共享式尝试获取锁状态</td></tr><tr><td>boolean tryReleaseShare(int arg)</td><td>共享式尝试释放锁状态</td></tr><tr><td>boolean isHeldExclusively()</td><td>是否独占式的，一般返回 true 表示当前的锁状态被当前线程持有</td></tr></tbody></table><h3 id="关于独占式和共享式"><a href="#关于独占式和共享式" class="headerlink" title="关于独占式和共享式"></a>关于独占式和共享式</h3><p>独占式和共享式的区别在于，在同一个时刻是否能有多个线程获取所状态<br>顾名思义，独占式就是锁状态只能被一个线程获取到，而共享式可以被多个线程获取锁(例如读锁，可以多个线程同时读)</p><p>对于一个锁框架来说，需要做到</p><ol><li>对锁状态的维护</li><li>对锁竞争时候，无法竞争到锁的线程的处理</li></ol><p>而在 AQS 中，以上的两个问题是这样解决的</p><ol><li>AQS 提供一个 <code>volatile int state</code> 变量，用来标识锁的状态，并且提供了以下三个方法进行读和取</li></ol><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>final int getState()</td><td>获取 state 的值</td></tr><tr><td>final void setState(int newState)</td><td>设置 state 的值</td></tr><tr><td>final boolean compareAndSetState(int expect, int update)</td><td>原子地修改 state 的值，返回值表示是否修改成功</td></tr></tbody></table><ol start="2"><li>而对于第二个问题，AQS 提供了一个 FIFO 的队列对无法获取到锁的线程进行入队等待的处理</li></ol><p>在 AQS 中维护了一个 <code>head</code> 和 <code>tail</code> 两个字段，其类型为 AQS 的内部类 <code>Node</code>，<code>Node</code> 的数据结构如下表格，可见通过 <code>head</code> 和 <code>tail</code> 则构成了一个双向的链表</p><p>其结构大概表现为：</p><p><img src="https://s2.loli.net/2022/02/19/FhD5tUV1kx6wqJI.png" alt="aqs_queue.png"></p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>int waitStatus</td><td>表示当前 Node 的等待状态，具体见下面的表格</td></tr><tr><td>Node prev</td><td>表示当前 Node 的前置节点</td></tr><tr><td>Node next</td><td>表示当前 Node 的后置节点</td></tr><tr><td>Thread thread</td><td>表示将这个 node 加入队列中的线程，在构造函数中赋值，并在Node使用完毕后会置为 null</td></tr><tr><td>Node nextWaiter</td><td>指向下一个在 condition 上等待的 Node，或者共享式的 Node</td></tr></tbody></table><p>waitStatus:</p><table><thead><tr><th>枚举</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>CANCELLED</td><td>1</td><td>表示线程获取锁的请求已经被取消</td></tr><tr><td>SIGNAL</td><td>-1</td><td>表示线程在等待锁资源，也表示其后续的节点的线程在等待唤醒</td></tr><tr><td>CONDITION</td><td>-2</td><td>表示线程正在等待 condition</td></tr><tr><td>PROPAGATE</td><td>-3</td><td>表示下一个 acquireShared 应该无条件传播</td></tr></tbody></table><h2 id="独占锁机制"><a href="#独占锁机制" class="headerlink" title="独占锁机制"></a>独占锁机制</h2><p><code>lock.tryLock()</code> 会调用 <code>sync.tryAcquire(int arg)</code> 方法，<code>tryAcquire()</code> 方法会通过 cas 的方式设置 state 的值，如果设置成功则返回 true，否则说明无法获取同步状态，则返回 false</p><p><code>lock.lock()</code> 方法，调用 <code>sync.acquire(int arg)</code> 方法</p><p><code>tryAcquire()</code> 方法：尝试获取锁(修改标志位)，无论成功与否立即返回<br><code>acquire()</code> 方法：获取锁(修改标志位)，获取成功则返回，失败则进入队列等待，直到获取到锁</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 <code>acquire()</code> 方法也会调用 <code>tryAcquire()</code> 方法先尝试获取同步状态，如果能获取到(即 tryAcquire() 返回 true)，则不会走后续的 <code>acquireQueued()</code> 以及 <code>selfInterrupt()</code> 方法</p><p>如果无法获取同步状态(即 tryAcquire() 返回 false)，调用 <code>addWaiter()</code> 方法以及 <code>acquireQueued()</code> 方法</p><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>接着看 <code>addWaiter()</code> 方法，顾名思义，添加一个等待节点，将新建的 Node 加入链表的队尾，并返回该节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先构造一个 Node 对象，包含当前线程对象，以及 mode (即传入的 Node.EXCLUSIVE 独占式)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">//将 pred 指向 tail 节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 pred 不为空，即队尾有节点</span></span><br><span class="line">        <span class="comment">//设置 node 的前置节点为 pred(即 tail)</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//通过 cas 将 node 设置为链表队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//设置成功后，将 tail 的后置节点设置为 node，并返回</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明 tail 为 null，即链表为空</span></span><br><span class="line">    <span class="comment">//或者通过 cas 设置链表队尾失败，说明有多个线程在竞争设置队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看 <code>enq()</code> 方法</p><p>将 node 插入到链表的队尾，并返回 node 的前序节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// t == null 说明还未初始化，则先创建一个哨兵节点并设置为 head，接着将 tail 指向哨兵节点</span></span><br><span class="line">            <span class="comment">//即 head -&gt; new Node() 0= &lt;- tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将 node 插入到 tail 后，并组成双向链表后返回 node 的前序节点(即旧的 tail)</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到 <code>acquire()</code> 方法中 if 中的 <code>acquireQueued()</code> 方法</p><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>方法的返回值代表是否需要中断该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="comment">//获取 node 的前序节点 p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果 p 是头节点</span></span><br><span class="line">                <span class="comment">//将 node 设置为头节点并将原来的头节点 p 从链表中删除</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//返回 interrupted</span></span><br><span class="line">                <span class="comment">//这个死循环只有在这才会返回退出</span></span><br><span class="line">                <span class="comment">//即只有当 node 的前续节点是头节点时才会退出循环</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明 p 不是头节点，或者是头节点但是尝试获取同步状态失败(tryAcquire 返回 false)</span></span><br><span class="line">            <span class="comment">//这里会将获取不到锁的线程进行挂起，避免循环自旋造成 CPU 性能的无谓消耗</span></span><br><span class="line">            <span class="comment">//shouldParkAfterFailedAcquire 返回的是该线程是否需要挂起</span></span><br><span class="line">            <span class="comment">//parkAndCheckInterrupt 方法会将线程挂起，并且返回是否在挂起期间线程被中断了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><blockquote><p>当一个线程尝试获取锁失败后，会调用这个方法判断是否需要挂起</p></blockquote><p>node: 当前线程对应的节点<br>pred: 当前线程对应的节点 node 的前序节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取 pred 节点的 waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果前序节点的 waitStatus 为 Signal，返回 true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前序节点的 waitStauts &gt; 0 （即 CANCELLED）</span></span><br><span class="line">        <span class="comment">//则往前遍历找到非 CANCELLED 状态的节点，并删除 CANCELLED 状态的节点</span></span><br><span class="line">        <span class="comment">//最后 return false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明 waitStatus 为 0 或者 PROPAGATE(-3)</span></span><br><span class="line">        <span class="comment">//则将前置节点的 waitStatus 设置为 SIGNAL</span></span><br><span class="line">        <span class="comment">//最后 return false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3><p>这个方法中通过 <code>LockSupport.park(</code>) 方法将当前线程挂起，并阻塞在该行代码处，直到被唤醒响应<br>通过这个方法挂起的线程在被中断后，不会抛出 InterruptException 的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下:</p><p>调用 <code>acquire()</code> 方法的线程首先会先尝试获取锁状态，如果获取成功，则执行后续代码，不表<br>主要是在多个线程竞争同一个锁时，存在竞争状态的情况下</p><p>调用 <code>tryAcquire()</code> 返回 false，即该线程获取锁状态不成功，则会在双向链表最后面插入一个 node 节点(持有该线程对象)<br>并通过 <code>acquireQueued()</code> 方法开启一个死循环</p><ol><li>如果 node 节点的前序节点为 head 节点<br>说明这个 node 节点已经排队排到最前面了，可以尝试获取锁状态，获取成功后则将该 node 节点置为 head，并跳出循环<br>如果获取锁状态失败，则进入下一步判断该线程是否需要挂起</li></ol><blockquote><p>实际上在这个双向链表中，head 节点只是充当一个哨兵的作用，并没有其他作用</p></blockquote><ol start="2"><li><p>如果 node 节点的前序节点不为 head 节点，则判断该线程是否能够挂起<br> 如果当前节点的前置节点的 waitStatus 为 Signal，说明前面的节点也在等待中，那自己理所应当的就该挂起阻塞等待了<br> 如果当前节点的前置节点的 waitStatus 为 Canceled，则往前遍历并修改链表，跳过并删除 canceled 的节点<br> 否则，将当前节点的前置节点的 waitStatus 置为 Signal</p></li><li><p>在 <code>shouldParkAfterFailedAcquire()</code> 方法中，除非 pred.waitStatus &#x3D;&#x3D; Signal 则直接返回 true，会将当前线程挂起，否则会继续循环，「将 canceled 的节点删除」或者「将前序节点的 waitStatus 置为 Signal」，当完成「将前序节点的 waitStatus 置为 Signal」这一步(即<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>) 后，下次循环如果 就会走到 pred.waitStatus &#x3D;&#x3D; Signal 的 case 中返回 true，后续的 <code>parkAndCheckInterrupt()</code> 方法会将该线程挂起</p></li></ol><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p>从前文我们知道，<code>acquireQueued()</code> 的返回值代表是否要中断线程，如果返回 true ，则会走到 if 的 case 中调用 <code>selfInterrupt()</code> 方法中断当前线程<br>而在 <code>acquireQueued()</code> 方法中，只有在 <code>shouldParkAfterFailedAcquire()</code> 和 <code>parkAndCheckInterrupt()</code> 方法都返回 true 的情况下，才会将 interrupted 的值置为 true，并在循环结束的时候返回</p><p>回看一下 <code>parkAndCheckInterrupt()</code> 方法，这个方法中回调用 <code>LockSupport.park(this)</code> 将线程挂起，由于这个方法将线程挂起时，不同于 thread.wait() 和 Thread.sleep() ，通过 <code>LockSupport.park()</code> 方法将线程挂起期间，不会抛出中断异常，所以在被唤醒后，需要通过 <code>Thread.interrupted()</code> 方法的返回值来决定是否需要中断当前线程</p><blockquote><p><code>Thread.interrupted()</code> 返回的是线程是否被中断过，并清除中断状态</p></blockquote><p>如果线程在等待过程中被中断过(thread.interrupt()) 则 Thread.interrupted() 会返回 true ，将 acquireQueued() 方法中的 interrupted 的值修改为 true ，直到循环退出，调用 selfInterrupt() 方法将线程中断</p><h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先尝试释放锁状态，由实现类自定义</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">//释放锁状态成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//头节点不为空且其 waitStatus 不为初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后序节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><p><code>unparkSuccessor()</code> 方法是为了唤醒 node 节点的后序节点对应的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将头节点的 waitStatus 值置为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果头节点的后序节点为空，或者其 waitStatus 为 Canceled 状态，则将其删除</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//从链表的尾巴向前查找，找到链表中第一个 waitStatus &lt; 0 的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//找到了链表中最靠前的 waitStatus &lt; 0 的节点，将其唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">        <span class="comment">//唤醒后则会回到 parkAndCheckInterrupt 方法中被挂起阻塞的地方，继续执行后续的代码尝试获取锁状态等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>在学习 AQS 的过程中，从 <a href="https://space.bilibili.com/1578320">B站寒食君</a> 以及 <a href="https://dayarch.top/">日拱一兵</a> 中学到了很多知识，感谢</p><p>附上链接：</p><p><a href="https://www.bilibili.com/video/BV12K411G7Fg">【Java并发】并发编程的意义是什么？月薪30K必知必会的Java AQS机制</a></p><p><a href="https://dayarch.top/p/java-aqs-and-reentrantlock.html">Java AQS队列同步器以及ReentrantLock的应用</a></p>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;p&gt;AQS，全称为 &lt;strong&gt;AbstractQueuedSynchronizer&lt;/strong&gt;，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制&lt;br&gt;其中封装了 FIFO(first in first out) 的队列&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://ppting.me/categories/Java/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Thread" scheme="https://ppting.me/tags/Thread/"/>
    
    <category term="并发" scheme="https://ppting.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程的中断机制</title>
    <link href="https://ppting.me/2022/02/17/2022_02_17_Java_Interrupt/"/>
    <id>https://ppting.me/2022/02/17/2022_02_17_Java_Interrupt/</id>
    <published>2022-02-17T14:52:12.000Z</published>
    <updated>2022-02-17T14:56:54.198Z</updated>
    
    <content type="html"><![CDATA[<br><p>简单回顾一下 Java 的中断机制</p><p>Java 中的线程 Thread 有以下三个方法</p><span id="more"></span><p><strong>public void interrupt()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>public static boolean interrupted()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    returncurrentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>isInterrupted()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>interrupt()</td><td>中断线程 <br> 当线程处于 Runnable 状态时，调用该方法中断该线程，会使得 isInterrupted() 方法返回 true <br> 当线程处于 Block 或者 Wait 阻塞状态时，如果是通过 thread.wait(),thread.join(),Thread.sleep() 方法处于阻塞状态时，则会抛出 InterruptedException,如果是通过 LockSupport.park() 方法使线程处于阻塞状态，则不会抛出 InterruptedException</td></tr><tr><td>interrupted()</td><td>静态方法，作用于调用该方法的当前线程，这个方法的命名用的是一般过去时，所以返回的值代表的是「线程是否被中断过」并且会清除掉该线程的中断状态</td></tr><tr><td>isInterrupted()</td><td>公开方法，作用于调用该方法的线程对象，返回值代表的是「调用该方法的线程是否被中断过」，但不会清除该线程的中断状态</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;p&gt;简单回顾一下 Java 的中断机制&lt;/p&gt;
&lt;p&gt;Java 中的线程 Thread 有以下三个方法&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://ppting.me/categories/Java/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Thread" scheme="https://ppting.me/tags/Thread/"/>
    
    <category term="并发" scheme="https://ppting.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap 源码阅读笔记</title>
    <link href="https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/"/>
    <id>https://ppting.me/2021/12/23/2021_12_23_concurrenthashmap/</id>
    <published>2021-12-22T16:00:00.000Z</published>
    <updated>2022-02-12T08:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<br><blockquote><p>本文基于 JDK 1.8 分析</p></blockquote><p>HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失</p><p>而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理</p><span id="more"></span><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>先大概对 ConcurrentHashMap 的数据结构模型有个大概的了解</p><p>跟 HashMap 一样，由一个数组和多个链表&#x2F;红黑树组成</p><p><img src="https://s2.loli.net/2021/12/23/vQgJ7Bea1GO5mu2.png" alt="concurrenthashmap.png"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><em><code>MAXIMUM_CAPACITY</code> &#x3D; 1 &lt;&lt; 30</em></p><p>最大的容量，因为 32 位的 hash 值的前两位为控制位，所以最大只到 1&lt;&lt;30</p><p><em><code>DEFAULT_CAPACITY</code></em>  &#x3D; 16</p><p>默认初始容量，必须为2的次幂，最低位 1，最大为 <em><code>MAXIMUM_CAPACITY</code></em></p><p><em><code>DEFAULT_CONCURRENCY_LEVEL</code> &#x3D; 16</em></p><p>默认的并发级别</p><p><em><code>LOAD_FACTOR</code> &#x3D; 0.75</em> </p><p>负载因子</p><p><em><code>TREEIFY_THRESHOLD</code> &#x3D; 8</em></p><p><em><code>MIN_TREEIFY_CAPACITY</code> &#x3D; 64</em></p><p>当插入时，链表上的节点数量超过 <code>TREEIFY_THRESHOLD</code> ，且 table 的长度也超过了 <code>MIN_TREEIFY_CAPACITY</code>，则会将链表转为树</p><p>否则进行扩容操作</p><h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><p>sizeCtl 字段是用来表示 table 的初始化状态或者用来控制 table 数组的容量</p><p>如果 sizeCtl 为负数，则表示 table 正在初始化或者在调整容量</p><p>如果 sizeCtl 不为负数，如果 table 为 null，则保存初始化 ConcurrentHashMap 时的容量，为0或者默认值</p><p>初始化以后，则保存的是要进行扩容的阈值</p><p><strong>sizeCtl &#x3D; -1</strong> 表示正在初始化</p><p><strong>sizeCtl &lt; 0 &amp;&amp; sizeCtl! &#x3D; -1</strong> 表示正在扩容中，且 sizeCtl 的低16位的值表示正在扩容的线程数 + 1，高16位为扩容标识，是由数组长度计算得到的值</p><p><strong>sizeCtl ≥ 0 &amp;&amp; table &#x3D;&#x3D; null</strong> 表示初始化时计算出的默认容量</p><p>s<strong>izeCtl ≥ 0 &amp;&amp; table !&#x3D; null</strong> 表示需要扩容的阈值</p><h3 id="Node-lt-K-V-gt"><a href="#Node-lt-K-V-gt" class="headerlink" title="Node&lt;K,V&gt;"></a>Node&lt;K,V&gt;</h3><p><code>Node&lt;K,V&gt;</code> 是 ConcurrentHashMap 的一个静态内部类，实现了 <code>Map.Entry&lt;K,V&gt;</code> 接口，用来保存键值对信息，注意这里的 <code>val</code> 和 <code>next</code> 字段都是用了 <code>volatile</code> 修饰，以保证其线程间的可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      <span class="keyword">volatile</span> V val;</span><br><span class="line">      <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p> ConcurrentHashMap 有多个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>initialCapacity:</strong> 传入的初始容量</p><p><strong>loadFactor</strong>: 负载因子</p><p>在构造方法中，实际上，是想通过传入的 <em>initialCapacity</em> 参数，并根据 loadFactor 计算出数组的初始化容量 cap，并且数组的阈值要大于 <em>initialCapacity ，</em>在 <code>initTable()</code> 方法中会使用这个 sizeCtl 值初始化 table 数组的容量</p><p><em><strong>But，但是</strong></em></p><p>这里的 <code>public ConcurrentHashMap(int initialCapacity)</code> 实际上是有 bug 的，在某些情况下，和下面三个参数的构造方法计算出来的 cap 值并不一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ConcurrentHashMap(<span class="number">22</span>)</span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap(<span class="number">22</span>,<span class="number">0.75</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在一个参数的构造方法中，计算出来的 cap 值为 64，而三参数的构造方法计算所得到的 cap 为 32</p><p>这个问题直到 JDK 12 才被修复</p><p><a href="https://bugs.openjdk.java.net/browse/JDK-8202422">value of ‘sizeCtl’ in ConcurrentHashMap varies with the constructor called</a></p><h3 id="tableSizeFor-int-size"><a href="#tableSizeFor-int-size" class="headerlink" title="tableSizeFor(int size)"></a>tableSizeFor(int size)</h3><p><code>tableSizeFor(int size)</code> 会返回大于等于 size 的最小的 2^n 的</p><p>例如：tableSizeFor(22) &#x3D; 32 ; tableSizeFor(3) &#x3D; 4</p><p>具体 <code>tableSizeFor(size)</code> 的方法可以参考</p><p><a href="https://segmentfault.com/a/1190000039392972">HashMap之tableSizeFor方法图解</a></p><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h3><p>final V putVal(K key , V value , boolean onlyIfAbsent) </p><aside>💡 添加键值对，会进行初始化 table 数组、扩容、链表转树等操作</aside><p>先看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果 key 和 value 都为 null 则抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录链表中节点的数量，用来控制扩容或者由链表转变为树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">//死循环，直到满足某个条件后再退出</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//-------------①--------------------</span></span><br><span class="line">            <span class="comment">//如果 tab 为空或者 tab 的长度为 0，则初始化 table</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//-------------②--------------------</span></span><br><span class="line">            <span class="comment">//如果 hash 对应的索引处 i 的桶为空，则尝试 cas 插入</span></span><br><span class="line">            <span class="comment">//这里 i 被赋值为索引</span></span><br><span class="line">            <span class="comment">//f 被赋值为索引处的 node 对象</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">//插入数据成功，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//-------------③--------------------</span></span><br><span class="line">            <span class="comment">// i 处的 Node 不为 null 且其 hash 为 MOVED，即正在扩容中</span></span><br><span class="line">            <span class="comment">// 这里将 fh 赋值为 Node f 的 hash 值</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//-------------④--------------------</span></span><br><span class="line">            <span class="comment">//否则，即 i 处已经有 Node f 存在，并且不处于扩容中，那就应该插入到链表中</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//多 f 加锁，多线程访问</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//这里再次确认 i 处 Node 对象是否为 f</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 f 的 hash 大于等于 0 </span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            <span class="comment">//开始遍历链表，</span></span><br><span class="line">                            <span class="comment">//过程中如果找到 key 相同的，则替换 value 并退出遍历</span></span><br><span class="line">                            <span class="comment">//否则，遍历完链表，将节点插入链表尾部</span></span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">//如果 key 相等，则替换 value，退出循环</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//如果当前节点已经是树了，则将键值对插入树中</span></span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//binCount 不为0，链表上的节点数量不为 0 ，即键值对插入了</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">//节点上的数量超过了阈值，转为树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果旧值不为 null，即替换了某个键值对</span></span><br><span class="line">                    <span class="comment">//则 return 旧值，结束整个 put 流程</span></span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">//否则，即 oldVal == null 的情况下</span></span><br><span class="line">                <span class="comment">//退出 for (Node&lt;K,V&gt;[] tab = table;;) 循环</span></span><br><span class="line">                <span class="comment">//走 addCount(1L,binCount) 处的逻辑并返回 null</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加计数，扩容等</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="comment">//返回 null，代表是新增的键值对，并非 key 相同替换旧的 value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><p><strong>①. 初始化数组</strong></p><p>通过 spread 方法计算 hash 值，并开始死循环，直到插入成功后退出</p><p>如果 table 还未初始化，则先通过 initTable() 初始化数组 </p><p><strong>②. index 处为 null</strong></p><p>通过 spread() 方法计算出对应的索引 i ，如果数组 i 索引处的值为 null ，则通过 cas 的方式进行插入，如果 cas 失败，说明有别的线程在对该处进行操作，则进行下一次 for 循环，下一次 for 循环则会进入 3、4 步中</p><p><strong>③. 帮助扩容</strong></p><p>如果 index 处节点不为 null 且 index 处的节点 hash 值为 MOVED ，则进行 helpTransfer() 方法</p><p><strong>④. 普通插入</strong></p><p>上述几步都不满足，则说明 index 上有个普通的节点，或为链表，或为树，进行更新或者插入操作</p><p>这里需要注意的是，会将 f(即 index 处的节点) 进行加锁，并会再次检查此时的 table index 索引处的节点是否被改变了，如果改变了，则进入下一次循环，如果没有改变依旧为 f ，则进行更新或者插入操作</p><p>如果是链表，则遍历链表覆盖更新值或者在链表尾部插入新的键值对(binCount &#x3D; 原链表长度)</p><p>如果是树，则将键值对插入树中</p><p>添加完成后，判断该节点上的链表长度，如果超过阈值，则调用 treeifyBin 转为树或者扩容数组，最后调用 addCount 添加计数，视机扩容数组等</p><h3 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h3><p>💡 初始化 table 数组</p><p>接着看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//table 还没初始化，则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// sizeCtl 小于 0 说明有别的线程在初始化，则让出 CPU 时间碎片</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//否则，通过 cas 将 sc 和 -1 进行 cas 操作</span></span><br><span class="line">            <span class="comment">//SIZECTL 是 sizeCtl 传入的对象 this</span></span><br><span class="line">            <span class="comment">//(即 sizeCtl 在 ConcurrentHashMap 这个对象中内存的偏移量)</span></span><br><span class="line">            <span class="comment">// sc 为期望值，此时值为 sizeCtl</span></span><br><span class="line">            <span class="comment">// -1 为要替换的值</span></span><br><span class="line">            <span class="comment">//总结来说就是将 sizeCtl 和 sc 进行比较，如果相等就将 -1 赋值给 sizeCtl，返回 true</span></span><br><span class="line">            <span class="comment">//否则不赋值返回 false</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//走到这里说明 cas 成功了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果设置了容量大小则使用设置的容量，否则使用默认的容量</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="comment">//new 一个数组并赋值</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容的阈值 n - (n &gt;&gt;&gt; 2) 等同于 n * LOAD_FACTOR</span></span><br><span class="line">                    <span class="comment">//只不过使用位运算更快</span></span><br><span class="line">                    <span class="comment">//即 n * 0.75 = n * 3/4 = n * (1 - 1/4) = n - n/4</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将 sc 的值赋值给 sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回新的 table 数组</span></span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,<span class="keyword">int</span> expected,<span class="keyword">int</span> x&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">这个方法的作用是，读取传入的对象 o 在内存中偏移 offset 的值，并和 expected 比较</span></span></span><br><span class="line"><span class="params"><span class="function">如果相同，则将 x 赋值给内存中偏移 offset 位置的值，并返回 <span class="keyword">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">否则不赋值返回 <span class="keyword">false</span></span></span></span><br></pre></td></tr></table></figure><p>总结：</p><p>如果 sizeCtl  小于 0 则让出，则暂停自己的线程，以便其他线程去执行初始化操作</p><p>如果 sizeCtl 大于等于 0 则初始化一个 sizeCtl 大小的数组，并更新 sizeCtl 为自身的负载因子倍( * 0.75)</p><p>这里通过 Unsafe.compareAndSwapInt 保证了线程安全</p><p>假如有多个线程同时调用了 initTable 方法，只有一个线程的 <code>U.compareAndSwapInt(this, SIZECTL, sc, -1)</code> 会返回 true 走入该 if 中的代码去执行初始化操作，假如有第三个线程来了，则会走入到 Thread.yield() 这里去让出时间碎片</p><h3 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer"></a>helpTransfer</h3><p>如果在某个线程在进行转移节点数据，则进行判断，满足条件就帮助转移，并返回 table 数组，以便在下次循环中进行插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 tab 不为空，且其头节点为 fwd 节点，说明正在扩容迁移</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//满足 while 中的条件这里说明正在扩容</span></span><br><span class="line">            <span class="comment">//则循环，直到扩容结束</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//修改 sizeCtl 成功，修改扩容的线程数 +1，参与扩容</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩容结束，返回新 table</span></span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头节点非 fwd 节点，则返回旧 table </span></span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resizeStamp-int-n"><a href="#resizeStamp-int-n" class="headerlink" title="resizeStamp(int n)"></a>resizeStamp(int n)</h3><blockquote><p>由于传入的参数 n 都是 2 的 n 次幂，这个方法实际上是用来将这个 n 通过算法将其记录在低16位中</p></blockquote><p><em>TL;DR</em> </p><blockquote><p><strong>返回值高16位记录为 0，低16位记录的是「扩容标识」，与数组长度有关</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS- <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>Integer.numberOfLeadingZeros(n)</code> 返回 n 在二进制中最高位的1前面0的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比方说 <span class="number">1</span> 的二进制为 </span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">则 `Integer.numberOfLeadingZeros(<span class="number">1</span>)` = <span class="number">31</span></span><br><span class="line">所以 Integer.numberOfLeadingZeros(<span class="keyword">int</span> n) 的值的范围为 <span class="number">0</span>-<span class="number">32</span></span><br></pre></td></tr></table></figure><p>接着看后半段，*<code>RESIZE_STAMP_BITS</code> 值为  16，*所以 <code>(1 &lt;&lt; (*RESIZE_STAMP_BITS - 1 )*</code> 即1左移15位，得到 <code>0000 0000 0000 0000 1000 0000 0000 0000</code></p><p>最后进行 <code>|</code> 运算*(有1则为1)*</p><p>我们以 resizeStamp(16) 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(十进制 <span class="number">16</span>)                            == <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">Integer.numberOfLeadingZeros(<span class="number">16</span>) = <span class="number">27</span> == <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">              | 或运算</span><br><span class="line">(<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS- <span class="number">1</span>)  = <span class="number">1</span>&lt;&lt;<span class="number">15</span> == <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">              = 等于</span><br><span class="line">                                         <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见 resizeStamp 方法会返回一个 高16为都为0，低16位为传入的参数 n 的 「最高位的1前面0的个数」</p><p>即高16位记录为 0，第16位为1，低15位记录的是「最高位的1前面0的个数」低16位构成一个「扩容标识」</p><p>可见该方法返回的值的取值范围为 [32769,32799]</p><h3 id="treeifyBin-Node-lt-K-V-gt-tab-int-index"><a href="#treeifyBin-Node-lt-K-V-gt-tab-int-index" class="headerlink" title="treeifyBin(Node&lt;K,V&gt;[] tab,int index)"></a>treeifyBin(Node&lt;K,V&gt;[] tab,int index)</h3><p>在往 ConcurrentHashMap 中插入元素后，会调用该方法进行扩容或者将链表转为树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">//如果 tab 的长度小于 MIN_TREEIFY_CAPACITY(64)，则进行扩容操作</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//否则，如果 index 处的节点 b 不为空且 hash 值大于0</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                <span class="comment">//再次判断，tab 的 index 处是否为 b</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">//转为树，略过不表</span></span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>当插入一个元素后，如果链表的长度超过<code>TREEIFY_THRESHOLD == 8</code>，但整个 table 数组长度小于  <code>MIN_TREEIFY_CAPACITY</code>&#x3D;&#x3D;64，则进行扩容操作，如果超过了 <code>MIN_TREEIFY_CAPACITY</code> 则将链表转为树</p><h3 id="tryPresize-int-size"><a href="#tryPresize-int-size" class="headerlink" title="tryPresize(int size)"></a>tryPresize(int size)</h3><p>💡 尝试预处理 table 数组的容量以容纳给定的数量的元素</p><p>这个方法只在 treeifyBin() 以及 putAll() 中被调用</p><p>treeifyBin() 方法传入的 size 为 <code>table.length &lt;&lt; 1</code></p><p>putAll() 传入的 size 为 <code>m.size()</code> 即原 Map 的节点数</p><p>以 table.length &#x3D;&#x3D; 16 为例，调用该方法时候，size &#x3D; table.length &lt;&lt; 1 即 32，计算出来的 c 为 64，直到 c ≤ sc 时才会退出循环，则 sc 至少需要为 128 * 0.75 &#x3D; 96 才会退出循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试调整 table 数组的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 需要调整到的容量</span></span><br><span class="line"><span class="comment"> * 这个方法只在 treeifyBin() 以及 putAll() 中被调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据 size 的值计算约束出为一个正确的 2的次幂值</span></span><br><span class="line">    <span class="comment">//为 MAXIMUM_CAPACITY 或者是大于等于 (size * 1.5 + 1) 的最小的 2次幂</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// sc 为 sizeCtl 在本方法中的临时变量</span></span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//-------①--------</span></span><br><span class="line">            <span class="comment">//如果 table 还未初始化，则进行初始化操作</span></span><br><span class="line">            <span class="comment">// n 为新的数组容量</span></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">//同理，if 中的语句会通过 cas 将 sizeCtl 更新为 -1，表示正在初始化</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        <span class="comment">//计算 sc，即 n - 0.25 * n = 0.75 * n</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置新的阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="comment">//-------②--------</span></span><br><span class="line">            <span class="comment">// c &lt;= sc 说明数组的容量已经足够了</span></span><br><span class="line">            <span class="comment">// n &gt;= MAXIMUM_CAPACITY 说明已经超过最大容量了</span></span><br><span class="line">            <span class="comment">//则退出循环，不处理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">//-------③--------</span></span><br><span class="line">            <span class="comment">//进行扩容操作</span></span><br><span class="line">            <span class="comment">//走到这里说明①和②的情况已经被排除掉了，即已经 table 数组已经初始化过了</span></span><br><span class="line">            <span class="comment">//并且c &lt;= sc不成立，即 sc &lt; c ，说明还没扩容完成</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//n 为 table 的容量</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//sc &lt; 0 因为数组已经初始化了，说明有其他线程正在扩容</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//sc 右移16位后，高16位为0，低16位为数组长度计算出的扩容标识</span></span><br><span class="line">                <span class="comment">//(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs:扩容标识不同</span></span><br><span class="line">                <span class="comment">//说明数组长度发生了变化，可能是别的线程触发了第二次扩容</span></span><br><span class="line">                <span class="comment">//sc == rs + MAX_RESIZERS:已经达到最大的扩容线程数量了</span></span><br><span class="line">                <span class="comment">//(nt = nextTable) == null :nextTable 还没创建</span></span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 需要迁移的区间已经被别的线程分完了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//实际上这里有两个 bug</span></span><br><span class="line">                <span class="comment">//1. sc == rs + 1</span></span><br><span class="line">                <span class="comment">//sc 现在是个负数，rs 高16位都为 0，无论如何 rs + 1 都不会等于 sc</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//2. sc == rs + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = (1 &lt;&lt; 16) -1 = 65535</span></span><br><span class="line">                <span class="comment">//rs 的取值范围为 [32769,32799] 而 rs + MAX_RESIZERS &gt; 0 并且还没溢出为负数</span></span><br><span class="line">                <span class="comment">//也无论如何都不会相等</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//将 rs 左移 16位，其高16位才是扩容标识，低16为存储扩容的线程数 + 1</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//下面这里对 sizeCtl 加一，表示参与迁移的线程数 +1，并进行迁移</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明自己是第一个进行扩容的线程，则通过 cas 的方式，将 rs 左移 16位并加2，存储在 sizeCtl 中</span></span><br><span class="line">            <span class="comment">//通过前面的 resizeStamp 方法我们直到 rs 的高16位为0，这里左移16位，则低16位都为0，再加2</span></span><br><span class="line">            <span class="comment">//则用低16为表示正在扩容的线程数，并且用 2 表示第一个正在扩容的线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h3><p>transfer(Node&lt;K,V&gt; tab, Node&lt;K,V&gt;[] nextTab)<br>💡 将旧数组的数据迁移到新的数组中，支持多线程迁移</p><h4 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a><strong>字段说明</strong></h4><p><code>transferIndex</code> 是个全局变量，通过 volatile 修饰，并通过 cas 的方式进行修改，用来表示当前线程应该从哪个地方开始往前遍历，如果 transferIndex &lt;&#x3D; 0 说明对数组的转移已经到头了，不需要再继续处理了</p><p><code>i</code> 字段表示当前线程在迁移的桶的索引</p><p><code>bound</code> 字段表示当前线程的需要迁移的区间的上边界</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>即每个线程的迁移区间为 [bound,transferIndex)，并通过 i 在该区间从后往前遍历桶进行迁移处理，遍历区间完成后，会继续竞争下一个区间</p><p>为了高效的进行迁移数据，这里允许多个线程进入，但是给每个线程分配了旧数组的一段区间进行迁移，避免多个线程同时迁移同个区间，代码中通过 cas 的方式，</p><p>让多个线程通过 cas 的操作竞争 transferIndex 字段，并通过 transferIndex 字段和 stride 计算出每个线程的迁移区间，所以线程在处理完竞争到的某个区间后，会不停地往前竞争处理下一个区间，直到处理到数组最前面的区间，比如说[0,16) 的区间后，transferIndex 等于 0，所以 i &#x3D; -1，</p><p>就会将 sizeCtl 中低16位中存储的线程数减1后 return，退出迁移，等到所有的线程对所有的区间处理完毕后，其他线程都退出迁移操作了，最后一个线程会将 finish 设置为 true，</p><p>再进行下一次循环后会将新的 nextTab 赋值给 table 并将 nextTable 置为空</p><p>从 HashMap 的迁移算法中我们也可以直到，对于一个节点，在扩容迁移后，要么还在原来的桶(假设索引为 index)中，要么就在索引为 2 * index 的桶处</p><p>同理在 ConcurrentHashMap 中也是这样子，所以不会造成多个线程同时转移到同一个桶中</p><p>首先会计算每个线程需要进行迁移的步长 stride，即迁移的桶的数量，至少为 16</p><p>在进行迁移时，会从后往前对 table 数组进行遍历，逐步对桶内的数据(链表或者树)进行迁移</p><p>由于篇幅太长，我们假设步长 stride 为4，举例进行说明</p><p><img src="https://s2.loli.net/2021/12/23/7uBlQZRbcPYH3Fm.png" alt="transfer_concurrenthashmap.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当第一个线程进行转移数据时，nextTab == null，否则为全局变量 nextTable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//计算步长 stride，至少为 16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="comment">//nextTab 为 null 说明是第一个线程进行转移</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个容量为旧数组容量两倍的新数组，并赋值给 nextTab</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            <span class="comment">//如果产生 OOM 等异常，则直接退出，不转移了</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组赋值给 nextTable ，此时数组为一个没有数据的空数组</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//transferIndex 记录旧数组的长度，表示转移开始的索引值</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nextn 为新数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//fwd 是用来标识某个桶处正在转移的，存储了新数组</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">//advance 是否前进，用来标记是否需要在区间内继续往前前进处理</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//finishing 是否扫描结束了，用来标记是否将所有的区间都迁移完成了</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        <span class="comment">//这里将 i 和 bound 初始化为 0，并开始死循环，直到数据转移成功后再退出循环</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在第一个线程第一次执行到这里时</span></span><br><span class="line">        <span class="comment">//--i == -1， bound == 0，第一个判断为 false</span></span><br><span class="line">        <span class="comment">//注意这里每次进入 while 循环都会做一次 --i 的操作，使得 i 不断的自减</span></span><br><span class="line">        <span class="comment">//nextIndex = transferIndex == n == tab.length 即旧数组的长度，大于0，第二个判断为 false</span></span><br><span class="line">        <span class="comment">//则走到第三个判断中</span></span><br><span class="line">        <span class="comment">//nextBound 为下一个线程需要进行转移的数组的下边界</span></span><br><span class="line">        <span class="comment">//计算 nextBound 的值，如果 nextIndex(即就数组的长度)大于步长 stride，</span></span><br><span class="line">        <span class="comment">//则 nextBound = nextIndex - stride，并通过 cas 的方式赋值</span></span><br><span class="line">        <span class="comment">//给全局变量 transferIndex，即下个线程需要转移的区间的下边界</span></span><br><span class="line">        <span class="comment">//下面的代码主要就是在第一次循环时，计算出来 [bound,transferIndex) 这个区间</span></span><br><span class="line">        <span class="comment">//在下一次 for 循环则会走到第一个判断中，直到 i &lt; bound 或者 finishing</span></span><br><span class="line">        <span class="comment">//当 i &lt; bound 时，即当前线程已经把分配给自己的区间里的桶都转移完毕了</span></span><br><span class="line">        <span class="comment">//如果此时别的线程还没有将整个数组转移完毕(transferIndex &lt;= 0 不成立)，</span></span><br><span class="line">        <span class="comment">//则当前线程会继续往前竞争下一个区间，这也就是如果只有一个线程的话，也可以迁移完成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                <span class="comment">//某个线程的第二次循环时候才会走到这里来，说明 i 还在该线程需要转移的区间内</span></span><br><span class="line">                <span class="comment">//[bound &lt;--&gt; i &lt;--&gt; transferIndex)</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明将已经到最前面了，将 i 赋值为 -1</span></span><br><span class="line">                <span class="comment">//则会走到 ③ 处执行，简单来说 ③ 处会做一些判断是否该线程要退出迁移操作</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                        (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                        nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//走到这里说明 i &lt; bound 且 transferIndex &gt; 0 (即整个 table 的转移还没处理完成)</span></span><br><span class="line">                <span class="comment">//通过 cas 继续认领一段区间进行转移</span></span><br><span class="line">                <span class="comment">//计算出当前线程所需要处理的区间</span></span><br><span class="line">                <span class="comment">//nextBound 就是下一个线程的下边界，也就是当先线程的上边界</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">//i 为索引值，所以需要 - 1</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="comment">//-----③----</span></span><br><span class="line">            <span class="comment">//如果 i &lt; 0 或者 i &gt;= n 说明已经超出了所需要处理的区间了</span></span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//------①-----</span></span><br><span class="line">                <span class="comment">//如果 finishing 为 true ，说明所有的桶都处理完了</span></span><br><span class="line">                <span class="comment">//则将新的数组赋值给 table 并将 nextTable 置为空</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">//并且设置新的阈值，新数组的长度为 2n，所以阈值应该为 0.75 * 2n，即 2n - 0.5n</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//返回，结束迁移</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明 finishing 为 false，即还未处理完所有的桶</span></span><br><span class="line">            <span class="comment">//但当前线程需要处理的区间内的桶已经处理完了，所以将 sizeCtl 减一表示正在迁移的线程数 -1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">//if 中为 true 说明当前线程不是最后一个在进行迁移的线程，返回，结束本线程的迁移</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//走到这里说明当前线程是第一个参与迁移的线程</span></span><br><span class="line">                <span class="comment">//将 finishing 和 advance 均设为 true</span></span><br><span class="line">                <span class="comment">//并把 i 设置为 n(即旧数组 table 的长度)</span></span><br><span class="line">                <span class="comment">//这样下一次循环就会走入 ① 处的逻辑结束迁移</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果索引为 i 的桶处为 null，则通过 cas 方式将 fwd 放在该桶处</span></span><br><span class="line">            <span class="comment">//接着将 advance 设置为 true，退出循环继续往前</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//如果索引为 i 处的桶上的数据不为空，且其 hash 值为 MOVED</span></span><br><span class="line">            <span class="comment">//代表该处的数据已经迁移过了，将 advance 设置为 true，退出循环继续往前</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，索引为 i 处的桶上有数据，则对桶处的头节点加锁</span></span><br><span class="line">            <span class="comment">//进行迁移，迁移完成后会将 advance 设置为 true</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//二次确认索引为 i 处的桶的节点为 f</span></span><br><span class="line">                    <span class="comment">//进行数据迁移，见后文细说</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-x2F-树的转移"><a href="#链表-x2F-树的转移" class="headerlink" title="链表&#x2F;树的转移"></a>链表&#x2F;树的转移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果头节点 f 的 hash 值大于0，说明为链表</span></span><br><span class="line">        <span class="comment">//计算出 fh 和 n 的与运算的结果，由于 n 为数组的长度，是2的次幂，所以只有最高位为1，其他都为0</span></span><br><span class="line">        <span class="comment">//与运算计算出来后 runBit 要么为 0 ，要么为 n</span></span><br><span class="line">        <span class="comment">//如果 runBid == 0 说明扩容后 f 依旧在原来的 index 处，否则在 index + n 处</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">            <span class="comment">//遍历链表，找到第一个后面全部为相同的 runBit 的节点</span></span><br><span class="line">            <span class="comment">//举个例子</span></span><br><span class="line">            <span class="comment">//链表     ： A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G</span></span><br><span class="line">            <span class="comment">//runBit 值： n-&gt;0-&gt;n-&gt;0-&gt;0-&gt;0-&gt;0</span></span><br><span class="line">            <span class="comment">//则这个 for 循环跑完以后，lastRun 则为D，runBit = 0</span></span><br><span class="line">            <span class="comment">//后续则可以将这个 D 后面的所有节点都一起挪动过去，就不需要再一个一个处理</span></span><br><span class="line">            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                runBit = b;</span><br><span class="line">                lastRun = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 runBit == 0 说明这些节点还要放在相同 index 的桶里，赋值给 ln</span></span><br><span class="line">            ln = lastRun;</span><br><span class="line">            hn = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则 runBit == n 说明这些节点还要放在相同 index + n 的桶里，赋值给 hn</span></span><br><span class="line">            hn = lastRun;</span><br><span class="line">            ln = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">            <span class="comment">//循环，构建两个链表，将节点插入对应的链表的尾部</span></span><br><span class="line">            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 ln 插入新的 table 的 i 处</span></span><br><span class="line">        setTabAt(nextTab, i, ln);</span><br><span class="line">        <span class="comment">//将 ln 插入新的 table 的 i + n 处</span></span><br><span class="line">        setTabAt(nextTab, i + n, hn);</span><br><span class="line">        <span class="comment">//将旧的 table i 处置为 fwd</span></span><br><span class="line">        setTabAt(tab, i, fwd);</span><br><span class="line">        <span class="comment">//更新 advance 为 true，准备下次 for 循环</span></span><br><span class="line">        advance = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">        <span class="comment">//同理对 TreeBin 进行迁移</span></span><br><span class="line">        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    lo = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    loTail.next = p;</span><br><span class="line">                loTail = p;</span><br><span class="line">                ++lc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                    hi = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = p;</span><br><span class="line">                hiTail = p;</span><br><span class="line">                ++hc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">        setTabAt(nextTab, i, ln);</span><br><span class="line">        setTabAt(nextTab, i + n, hn);</span><br><span class="line">        setTabAt(tab, i, fwd);</span><br><span class="line">        advance = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素数量计数"><a href="#元素数量计数" class="headerlink" title="元素数量计数"></a>元素数量计数</h2><h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><blockquote><p>获取 map 中键值对的数量</p></blockquote><p>返回 <code>sumCount</code> 方法的值，如果小于0，则返回0，如果超过了 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> n = sumCount();</span><br><span class="line">      <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">              (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">              (<span class="keyword">int</span>)n);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="sumCount"><a href="#sumCount" class="headerlink" title="sumCount()"></a>sumCount()</h3><p>返回 <code>baseCount</code> 和 <code>counterCells 列表中值的总和</code> 的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个 baseCount 和 counterCells 是什么呢，我们在前面 putVal 的流程中还没有介绍 addCount(1L,binCount) 这个方法。通过名字我们也能看出来这是个用来增加计数的方法</p><p>我们先来看这个方法</p><h3 id="addCount-long-x-int-check"><a href="#addCount-long-x-int-check" class="headerlink" title="addCount(long x,int check)"></a>addCount(long x,int check)</h3><p><code>x</code> 表示新增的节点数</p><p><code>check</code> 表示是否需要进行扩容检查，如果 &lt; 0 则不进行扩容</p><p>从前面 putVal 中我们可以知道，当一个键值对节点插入到链表中时， check 的值为链表的长度，当插入到红黑树中时，check 为 2</p><p>这个方法分为两个部分，前一部分是通过 LongAdder 的方式，进行计数，后半部分中会进行扩容迁移操作后，再进行计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//第一个判断：(as = counterCells) != null</span></span><br><span class="line">    <span class="comment">//表示 counterCells 已经被初始化了</span></span><br><span class="line">    <span class="comment">//第二个判断：将 baseCount 通过 cas 的方式修改为 baseCount + x</span></span><br><span class="line">    <span class="comment">//如果修改成功说明没有竞争</span></span><br><span class="line">    <span class="comment">//如果修改失败，说明存在竞争，则进入下面的逻辑对 counterCells 进行处理</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//前两个判断 as == null || (m = as.length - 1) &lt; 0 </span></span><br><span class="line">        <span class="comment">//判断 counterCells 是否初始化了，并且数组中是否有内容</span></span><br><span class="line">        <span class="comment">//如果为还未初始化或者数组中没有内容，则调用 fullAddCount(x, true)</span></span><br><span class="line">        <span class="comment">//第三个判断是在前两个判断都为 false 的基础上</span></span><br><span class="line">        <span class="comment">//进一步获取 counterCells 中当前线程所对应的 CounterCell 元素</span></span><br><span class="line">        <span class="comment">//如果为空，则调用 fullAddCount(x, true)</span></span><br><span class="line">        <span class="comment">//如果不为空，则尝试对 CounterCell 通过 cas 进行累加，累加成功则进行下一步</span></span><br><span class="line">        <span class="comment">//累加不成功说明存在竞争，则调用 fullAddCount(x, false)</span></span><br><span class="line">        <span class="comment">//uncontended 代表是否无竞争</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//详见后面的小节</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当 check &gt;= 0，则尝试是否需要扩容</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//当下面的三个条件都满足时，才会进入这里</span></span><br><span class="line">            <span class="comment">//1. 当 s (节点数量) &gt;= 阈值 sizeCtl 了</span></span><br><span class="line">            <span class="comment">//2. table 不为 null</span></span><br><span class="line">            <span class="comment">//3. table 的长度小于最大容量</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//rs 的高16位为0，低16为存储数组长度 n 计算出来的值</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;(</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//sc 右移16位后，高16位为0，低16位为数组长度计算出的扩容标识</span></span><br><span class="line">                <span class="comment">//(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs:扩容标识不同，</span></span><br><span class="line">                <span class="comment">//  说明数组长度发生了变化，可能是别的线程触发了第二次扩容</span></span><br><span class="line">                <span class="comment">//sc == rs + MAX_RESIZERS:已经达到最大的扩容线程数量了</span></span><br><span class="line">                <span class="comment">//(nt = nextTable) == null :nextTable 还没创建</span></span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 需要迁移的区间已经被别的线程分完了</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//实际上这里有两个 bug</span></span><br><span class="line">                <span class="comment">//1. sc == rs + 1</span></span><br><span class="line">                <span class="comment">//sc 现在是个负数，rs 高16位都为 0，无论如何 rs + 1 都不会等于 sc</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//2. sc == rs + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = (1 &lt;&lt; 16) -1 = 65535</span></span><br><span class="line">                <span class="comment">//rs 的取值范围为 [32769,32799] 而 rs + MAX_RESIZERS &gt; 0 且还没溢出为负数</span></span><br><span class="line">                <span class="comment">//也无论如何都不会相等</span></span><br><span class="line">                <span class="comment">//fix:</span></span><br><span class="line">                <span class="comment">//sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">//将 rs 左移 16位，其高16位才是扩容标识，低16为存储扩容的线程数 + 1</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//不需要扩容</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">//此时有别的线程在扩容了，则帮助进行扩容</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">//进行扩容，这里是第一个进行扩容的线程</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//进行计数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fullAddCount"><a href="#fullAddCount" class="headerlink" title="fullAddCount"></a>fullAddCount</h3><p>private final void fullAddCount(long x, boolean wasUncontended)</p><p><code>x</code>表示新增的节点数量</p><p><code>wasUncontented</code> 表示是否无竞争</p><pre><code>true == 表示没有竞争false == 表示有竞争</code></pre><p>在 ConcurrentHashMap 中，其实是复制了一份 LongAdder 的源码，在 ConcurrentHashMap 中，由于并发情况多，如果使用 AtomicLong 的方式进行记录，如果 N 个线程同时对 AtomicLong 进行修改，只有一个线程能修改成功，其他线程则会处于自旋等待状态，而 LongAdder 的方式是使用一个变量 baseCount+数组 CounterCell[]，让每个线程去维护自己的一个变量，减少碰撞冲突，每个线程维护数组中的一个对象，对象中存储一个值；从 CounterCell[] 中获取到对应的值并进行修改，如果修改失败，则尝试修改 baseCount 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果还没有初始化，则进行初始化</span></span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        <span class="comment">//还没初始化，所以不存在竞争，将 wasUncontended 设置为 true</span></span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//collide 表示是否多个线程 hash 到同一个 CounterCell 产生碰撞了</span></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 counterCells 不为 null 且 counterCells 长度大于 0</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//取到 counterCells 中对应线程的 CounterCell 为空</span></span><br><span class="line">                <span class="comment">//cellsBusy 字段为 1 说明 counterCells 正在初始化或者扩容</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">//下面为尝试创建一个 CounterCell 对象并存到 counterCells 数组对应的索引处</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="comment">//counterCells 为正常状态且修改 cellsBusy 为1 成功</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//j 是当前线程的 hash 值计算得出的索引</span></span><br><span class="line">                                <span class="comment">//对 counterCells 中 j 处的元素进行替换</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="comment">//创建成功，退出循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//创建不成功，则进行下一次循环</span></span><br><span class="line">                        <span class="comment">//可能是因为 rs[j] != null，即该处有值了</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       </span><br><span class="line">                <span class="comment">// cas 失败了，则设置为 true，在下次循环的时候重新计算 hash 再进行分配</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="comment">//修改当前 CounterCell 中的 value 成功，则退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                <span class="comment">//counterCells != as 说明 counterCells 被扩容了</span></span><br><span class="line">                <span class="comment">//或者 as 大于等于 CPU 的数量了，等待下一轮重试</span></span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                <span class="comment">//上述条件都不满足，说明产生了碰撞，且竞争失败了</span></span><br><span class="line">                <span class="comment">//将值 collide 修改为 true，下一次循环就可以走到下个 if 中</span></span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//counterCells 处于正常状态，且修改 cellsBusy 值为1成功</span></span><br><span class="line">                <span class="comment">//则对 counterCells 进行扩容并迁移数据，</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新计算 hash 值</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;<span class="comment">//这里是 (as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0 这个条件结束的地方</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//走到这里说明 counterCells 为空，则进行初始化，容量为2，并将 CounterCell 放进数组中</span></span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里说明 counterCells 为空，且竞争初始化失败了，则尝试将 x 加到 baseCount 上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们就看完了 ConcurrentHashMap 中的 put 的方法</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://segmentfault.com/a/1190000039055166">通俗易懂的JUC源码剖析-LongAdder&#x2F;LongAccumulator</a></li><li><a href="https://xilidou.com/2018/11/27/LongAdder/">从 LongAdder 中窥见并发组件的设计思路</a></li><li><a href="https://mp.weixin.qq.com/s/9x1V8DG3fv-4bgXYs5b6Hw">精妙绝伦的并发艺术品 — ConcurrentHashMap是如何保证线程安全的</a></li><li><a href="https://www.cnblogs.com/zerotomax/p/8687425.html">ConcurrentHashMap源码分析(1.8)</a></li><li><a href="https://www.meetkiki.com/archives/%E4%BB%8E%E6%AD%BB%E5%BE%AA%E7%8E%AFBUG%E6%9D%A5%E8%81%8A%E8%81%8AConcurrentHashMap%E7%9A%84%E6%89%A7%E8%A1%8C%E5%86%85%E5%B9%95(%E4%B8%8A)">从死循环BUG来聊聊ConcurrentHashMap的执行内幕（上）</a></li><li><a href="https://www.hegongshan.com/2020/03/06/java-collections-api-concurrenthashmap/">Java容器探秘之旅 ConcurrentHashMap</a></li><li><a href="http://ljh.gold/java-10/">ConcurrentHashMap</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;本文基于 JDK 1.8 分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失&lt;/p&gt;
&lt;p&gt;而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://ppting.me/categories/Java/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    <category term="数据结构" scheme="https://ppting.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Map" scheme="https://ppting.me/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2 原理解析</title>
    <link href="https://ppting.me/2021/11/24/2021_11_24_rxjava/"/>
    <id>https://ppting.me/2021/11/24/2021_11_24_rxjava/</id>
    <published>2021-11-23T16:00:00.000Z</published>
    <updated>2022-02-12T08:16:58.000Z</updated>
    
    <content type="html"><![CDATA[<br><blockquote><p>RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.<br>RxJava 是 Reactive Extensions 的 Java VM 实现：一个使用可观察序列组合异步和基于事件的程序的库。</p></blockquote><p>RxJava 通过观察者订阅被观察者进行事件的分发，并提供了很多被观察者(即事件发送者)的创建方法和事件转换的操作符函数(map、flatmap、filter 等等)</p><span id="more"></span><p>下面以最简单的一个 SingleJust 的发射和订阅为例，来看一下 RxJava 中到底是如何进行订阅的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SingleJust.just(<span class="number">0</span>)</span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="meta">@NonNull</span> Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> integer.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>首先看一下 <code>SingleJust.just(1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport(SchedulerSupport.NONE)</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Single&lt;T&gt; <span class="title">just</span><span class="params">(<span class="keyword">final</span> T item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查校验参数不能为 null</span></span><br><span class="line">    ObjectHelper.requireNonNull(item, <span class="string">&quot;item is null&quot;</span>);</span><br><span class="line">    <span class="comment">//这是个 hook 方法，一般默认返回传入的对象本身</span></span><br><span class="line">    <span class="comment">//如果设置了 hook 对象(Function)，则会对其进行一些操作后再返回</span></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> SingleJust&lt;T&gt;(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RxJavaPlugins.onAssembly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Single&lt;T&gt; <span class="title">onAssembly</span><span class="params">(<span class="meta">@NonNull</span> Single&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> Single, ? extends Single&gt; f = onSingleAssembly;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看一下 <code>SingleJust.java</code> 类</p><p>很简单的一个类，继承 Single<T> 类，构造方法中传入一个 <code>value</code>，并实现 <code>subscribeActual()</code> 方法<br>在 <code>subscribeActual()</code> 方法中调用传入的 observer 的 <code>onSubscribe()</code> 方法和 <code>onSuccess()</code> 方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleJust</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Single</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleJust</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        observer.onSubscribe(Disposables.disposed());</span><br><span class="line">        observer.onSuccess(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>subscribeActual()</code> 方法中调用了 <code>observer</code>（观察者）的 <code>onSubscribe()</code> 和 <code>onSuccess()</code> 方法<br>至于 <code>subscribeActual()</code> 什么时候被调用的，我们一会再看</p><p>再接着看 <code>Single.map()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@SchedulerSupport(SchedulerSupport.NONE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Single&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查入参</span></span><br><span class="line">    ObjectHelper.requireNonNull(mapper, <span class="string">&quot;mapper is null&quot;</span>);</span><br><span class="line">    <span class="comment">//返回一个 SingleMap 对象</span></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> SingleMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看下 <code>SingleMap</code> 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Single</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SingleSource&lt;? extends T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleMap</span><span class="params">(SingleSource&lt;? extends T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> R&gt; t)</span> </span>&#123;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> MapSingleObserver&lt;T, R&gt;(t, mapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSingleObserver</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">SingleObserver</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleObserver&lt;? <span class="keyword">super</span> R&gt; t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapSingleObserver(SingleObserver&lt;? <span class="keyword">super</span> R&gt; t, Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper) &#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">            <span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            t.onSubscribe(d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">            R v;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(value), <span class="string">&quot;The mapper function returned a null value.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                onError(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t.onSuccess(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            t.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 SingleMap 的构造方法中<br>传入的第一个参数 <code>SingleSource source</code>，即调用该方法的 SingleSouce 对象<br>第二个参数是个 <code>Function mapper</code>，即转换方法</p><p>同样的，<code>subscribeActual(final SingleObserver&lt;? super R&gt; t)</code> 方法里调用了 <code>source:SingleSource</code> 的 subscribe 方法，传入了一个 <code>MapSingleObserver</code> 对象</p><p>MapSingleObserver 相当于一个代理类，对 <code>subscribeActual()</code> 方法中的 t 进行代理，当 mapSingleObserver 的方法被调用时，就会调用其构造方法中传入的 t 进行调用，在 <code>onSuccess()</code> 中先使用 mapper 对数据进行处理后，得到 result，再调用 <code>t.onSuccess(result)</code> 进行回调</p><p>再回过头来看 <code>subscribe()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Disposable <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> T&gt; onSuccess, <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对参数进行检查</span></span><br><span class="line">    ObjectHelper.requireNonNull(onSuccess, <span class="string">&quot;onSuccess is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onError, <span class="string">&quot;onError is null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对传入的观察者进行包装为一个 ConsumerSingleObserver</span></span><br><span class="line">    ConsumerSingleObserver&lt;T&gt; observer = <span class="keyword">new</span> ConsumerSingleObserver&lt;T&gt;(onSuccess, onError);</span><br><span class="line">    <span class="comment">//再调用 subscribe 方法订阅</span></span><br><span class="line">    subscribe(observer);</span><br><span class="line">    <span class="keyword">return</span> observer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(SingleObserver&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//依旧是进行参数检查</span></span><br><span class="line">    ObjectHelper.requireNonNull(observer, <span class="string">&quot;observer is null&quot;</span>);</span><br><span class="line">    <span class="comment">//同上理，进行 hook 配置</span></span><br><span class="line">    observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line"></span><br><span class="line">    ObjectHelper.requireNonNull(observer, <span class="string">&quot;The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//重点在于这里，调用了 subscribeActual 方法</span></span><br><span class="line">        <span class="comment">//subscribeActual 是个抽象方法，需要各个子类进行实现</span></span><br><span class="line">        <span class="comment">//于是这里就会调用到了我们上面所看到的 SingleJust 类中的 subscribeActual 方法，完成了整个 RxJava 的流程</span></span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">&quot;subscribeActual failed&quot;</span>);</span><br><span class="line">        npe.initCause(ex);</span><br><span class="line">        <span class="keyword">throw</span> npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述我们可以知道，在 RxJava 中，就是由最下游的 subscribe() 方法中的参数 observer ，最终调用事件发出者的 subscribeActual() 方法</p><p>上述的代码的流程我们可以用下面的伪代码来进行理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后被执行</span></span><br><span class="line">SingleObserver.subscribeActual()&#123;</span><br><span class="line">    <span class="comment">//第二个被执行</span></span><br><span class="line">    SingleMap.subscribeActual()&#123;</span><br><span class="line">        <span class="comment">//最先执行</span></span><br><span class="line">        SingleJust.subscribeActual()&#123;</span><br><span class="line">            <span class="comment">//create </span></span><br><span class="line">            onSubscribe()</span><br><span class="line">            onSuccess()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理一下，RxJava 的事件流起始在于调用了 <code>subscribe()</code> 方法，然后一层一层地调用上游的 <code>subscribeActual(SingleObserver&lt;? super T&gt; observer)</code> 方法，同时也把把自己传给上游</p><p>对于操作符来说，其 <code>subscribeActual()</code> 方法会调用其上游的 <code>subscribe() -&gt; subscribeActual()</code> 方法，直到最上游的生产者</p><p>对于生产者来说，其 <code>subscribeActual()</code> 方法则是在生产数据，调用下游观察者(即从 subscribeActual() 方法中传入的参数) 的回调方法</p><p>所以实际上就是后面的 observer 在倒序地调用上游的 subscribeActual() 方法，然后不断调用下游的 onSuccess&#x2F;onSubscribe&#x2F;onError 等等方法</p><blockquote><p>操作符持有调用它的上游的引用，并在被订阅的时候(<code>subscribeActual()</code>) 将下游进行代理后，去订阅其上游</p></blockquote><p>同理，Observable&#x2F;Flowable 等 RxJava 的事件流也是同样的流程</p><p>画个流程图<br><img src="https://i.loli.net/2021/11/24/j13eldyRuYn6NSv.png" alt="RxJava.drawio _1_.png"></p><h2 id="RxJava-的线程切换"><a href="#RxJava-的线程切换" class="headerlink" title="RxJava 的线程切换"></a>RxJava 的线程切换</h2><ul><li><p>subscribeOn()</p><blockquote><p>指定事件产生的线程</p></blockquote></li><li><p>observeOn()</p><blockquote><p>指定事件消费的线程</p></blockquote></li></ul><p>RxJava 中的线程调度是通过 <code>subscribeOn(Scheduler scheduler)</code> 和 <code>observeOn(Scheduler scheduler)</code> 两个方法完成的<br><code>subscribeOn()</code> 方法调度的是上游到第一个 <code>observeOn()</code> 之间的的线程<br><code>observeOn()</code> 调度的是该 <code>observeOn()</code> 到下一个 <code>observeOn()</code> 之间的的线程</p><p>所以在 RxJava 中可以进行任意的线程调度，但是，<code>subscribeOn()</code> 方法则有所区别，如果有多个 <code>subscribeOn()</code> 方法，只有最靠近上游的 <code>subscribeOn()</code> 起作用，而其他的 <code>subscribeOn()</code> 方法不起作用，但是这其中也有一个例外，当使用 <code>doOnSubscribe()</code> 方法时，这个方法发生在 <code>subscribe()</code> 调用后而且在事件发送前，这个方法是可以指定线程的，默认情况下， <code>doOnSubscribe()</code> 执行在 <code>subscribe()</code> 发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p><p><code>subscribeOn()</code> 和 <code>observeOn()</code> 方法需要传入一个 <code>Schedule</code> 对象</p><h3 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h3><p><code>Schedule</code> 是一个抽象类，其子类有我们经常使用的 <code>Schedulers.io()</code>、<code>Schedulers.newThread()</code> 以及 <code>AndroidSchedulers.mainThread()</code> 等等</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">//---------1 start ------------//</span></span><br><span class="line">        .flatMap(<span class="keyword">new</span> Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;Integer&gt; <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;flatMap&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,Thread.currentThread().toString());</span><br><span class="line">                <span class="keyword">return</span> Observable.just(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//---------1 end ------------//</span></span><br><span class="line">        .subscribeOn(Schedulers.newThread())<span class="comment">//调度从上游到第一个 observerOn() 方法之间的线程，即 1 和 2</span></span><br><span class="line">        <span class="comment">//---------2 start ------------//</span></span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;map&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,Thread.currentThread().toString());</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//---------2 end ------------//</span></span><br><span class="line">        <span class="comment">//---------3 start ------------//</span></span><br><span class="line">        .doOnSubscribe(<span class="keyword">new</span> Consumer&lt;Disposable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Disposable disposable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;doOnSubscribe&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,Thread.currentThread().toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//---------3 end ------------//</span></span><br><span class="line">        .observeOn(Schedulers.computation())<span class="comment">//调度下面的线程，即4 和5</span></span><br><span class="line">        <span class="comment">//---------4 start ------------//</span></span><br><span class="line">        .map(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;map&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,Thread.currentThread().toString());</span><br><span class="line">                <span class="keyword">return</span> s + <span class="string">&quot; map &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//---------4 end ------------//</span></span><br><span class="line">        <span class="comment">//只能决定 doOnSubscribe 中的线程，即3</span></span><br><span class="line">        <span class="comment">//.subscribeOn(Schedulers.newThread())</span></span><br><span class="line">        <span class="comment">//---------5 start ------------//</span></span><br><span class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;subscribe&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,Thread.currentThread().toString());</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;result is &quot;</span>+s);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//---------5 end ------------//</span></span><br></pre></td></tr></table></figure><p>打印出来的日志为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D/MainActivity: 3</span><br><span class="line">D/MainActivity: doOnSubscribe</span><br><span class="line">D/MainActivity: Thread[main,5,main]</span><br><span class="line">D/MainActivity: 1</span><br><span class="line">D/MainActivity: flatMap</span><br><span class="line">D/MainActivity: Thread[RxNewThreadScheduler-1,5,main]</span><br><span class="line">D/MainActivity: 2</span><br><span class="line">D/MainActivity: map</span><br><span class="line">D/MainActivity: Thread[RxNewThreadScheduler-1,5,main]</span><br><span class="line">D/MainActivity: 4</span><br><span class="line">D/MainActivity: map</span><br><span class="line">D/MainActivity: Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">D/MainActivity: 5</span><br><span class="line">D/MainActivity: subscribe</span><br><span class="line">D/MainActivity: Thread[RxComputationThreadPool-1,5,main]</span><br><span class="line">D/MainActivity: result is 1 map </span><br></pre></td></tr></table></figure><p>可以看出 doOnSubscribe 是最先被执行的</p><p>第一个 <code>subscribeOn(Schedulers.io())</code> 调度的是最上游的 1 和 2 中的线程<br>第二个 <code>subscribeOn(Schedulers.newThread())</code> 不起作用，只能调度 3 中的线程<br>第三个 <code>observeOn(Schedulers.computation())</code> 调度的是其后面的代码的线程，即 4 和 5</p><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn()"></a>subscribeOn()</h3><p>我们通过源码一步一步看，subscribeOn 到底是如何调度线程的</p><p>同上，也是先校验 scheduler 不为空<br>然后将 scheduler 包装为一个 ObservableSubscribeOn 并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io.reactivex.Observable#subscribeOn</span><br><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport(SchedulerSupport.CUSTOM)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">io.reactivex.internal.operators.observable.ObservableSubscribeOn#<span class="function">ObservableSubscribeOn</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObservableSubscribeOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">    <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用下游的 onSubscribe() 方法，</span></span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//⑥</span></span><br><span class="line">    parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//⑦</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObservableSubscribeOn 类的构造方法<br>第一个参数是 <code>ObservableSource source</code> 即上面传入的 <code>this</code>(就是调用 subscribeOn 的对象)<br>第二个参数是 <code>Scheduler scheduler</code>，即要调度到的线程</p><p>再看 <code>subscribeActual(final Observer&lt;? super T&gt; observer)</code> 方法<br>从上文我们可以知道，当下游的观察者订阅时，会调用上游的 <code>subscribeActual()</code> 方法，在我们这里，<code>ObservableSubscribeOn#subscribeActual()</code> 的职责就是切换到指定的线程，并在指定的线程中调用上游的 <code>subscribe()</code> 方法，达到切换上游线程的目的</p><p>在这个方法中，会将下游的 observer 进行包装为 <code>SubscribeOnOnserver</code> 对象 <code>parent</code>，这个对象中持有着下游 <code>observer</code></p><p>重点看一下 <code>scheduler.scheduleDirect(new SubsribeTask(parent))</code></p><p><code>SubscribeTask</code> 是一个实现了 <code>Runnable</code> 接口的类，那肯定会在某个时机调用其 <code>run()</code> 方法，可以看到在 <code>run()</code> 方法中调用了 <code>source.subscribe(parent)</code>，由于 <code>SubscribeTask</code> 是 <code>ObservableSubscribeOn</code> 的内部类，所以这里的 <code>source</code> 就是 <code>ObservableSubscribeOn</code> 构造方法中传入的第一个参数，即调用<code>subscribeOn()</code> 的上游对象，这里的 <code>parent</code> 则是上面的 <code>SubscribeOnOnserver</code> 包装对象 </p><p><strong>那么重点又转移到了 <code>SubscribeTask</code> 中的 <code>run()</code> 方法是如何被调用的了</strong></p><p>我们继续看 <code>io.reactivex.Scheduler#scheduleDirect(java.lang.Runnable)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="meta">@NonNull</span> Runnable run, <span class="keyword">long</span> delay, <span class="meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 Worker </span></span><br><span class="line">    <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line">    <span class="comment">//对传入的 run 对象（即前面的 SubscribeTask 对象）做钩子处理</span></span><br><span class="line">    <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line">    <span class="comment">//将 decoratedRun 和 w 包装成一个 DisposeTask (即一个可以被取消的 Runnable)</span></span><br><span class="line">    DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</span><br><span class="line">    <span class="comment">//worker 调用 schedule 方法进行操作</span></span><br><span class="line">    <span class="comment">//① 具体的实现见下方</span></span><br><span class="line">    w.schedule(task, delay, unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个 <code>createWorker()</code> 方法，是 <code>Scheduler</code> 类的抽象方法，我们以 Schedulers.newThread() 的具体实例 <code>NewThreadScheduler</code> 为例，来看一下这段代码到底是如何切换线程的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...忽略一些代码...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewThreadWorker(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看 <code>NewThreadWorker</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewThreadWorker</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体代码见 ②</span></span><br><span class="line">        executor = SchedulerPoolFactory.create(threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从上文可以知道，①处的代码会调用到这里</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Runnable action, <span class="keyword">long</span> delayTime, <span class="meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (disposed) &#123;</span><br><span class="line">            <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scheduleActual(action, delayTime, unit, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//③</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, <span class="meta">@NonNull</span> TimeUnit unit, <span class="meta">@Nullable</span> DisposableContainer parent)</span> </span>&#123;</span><br><span class="line">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line"></span><br><span class="line">        ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!parent.add(sr)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                f = executor.submit((Callable&lt;Object&gt;)sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            sr.setFuture(f);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.remove(sr);</span><br><span class="line">            &#125;</span><br><span class="line">            RxJavaPlugins.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>② 创建一个只有一个核心线程的线程池并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">create</span><span class="params">(ThreadFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">1</span>, factory);</span><br><span class="line">    tryPutIntoPool(PURGE_ENABLED, exec);</span><br><span class="line">    <span class="keyword">return</span> exec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DisposeTask</span> <span class="keyword">implements</span> <span class="title">Disposable</span>, <span class="title">Runnable</span>, <span class="title">SchedulerRunnableIntrospection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">final</span> Runnable decoratedRun;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">final</span> Worker w;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        Thread runner;</span><br><span class="line"></span><br><span class="line">        DisposeTask(<span class="meta">@NonNull</span> Runnable decoratedRun, <span class="meta">@NonNull</span> Worker w) &#123;</span><br><span class="line">            <span class="keyword">this</span>.decoratedRun = decoratedRun;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//④</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runner = Thread.currentThread();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//⑤</span></span><br><span class="line">                decoratedRun.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                runner = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (runner == Thread.currentThread() &amp;&amp; w <span class="keyword">instanceof</span> NewThreadWorker) &#123;</span><br><span class="line">                ((NewThreadWorker)w).shutdown();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                w.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> w.isDisposed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Runnable <span class="title">getWrappedRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.decoratedRun;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由上述的代码我们可以看到<br>① 处的 worker 调用 schedule() 方法，传入包装类 DisposeTask 的对象(持有 worker 和 subscribeTask)，一步步调用到 ③ 处，③这里就是将传入的 <code>run</code> 对象(即 DisposeTask )，根据延迟时间，交给 ② 处的线程池去执行，最终执行到 ④ 处 DisposeTask 的 <code>run()</code> 方法，<code>run()</code> 方法中会的调用 ⑤处 的 <code>decoratedRun.run()</code>，而这个 <code>decoratedRun</code> 对象就是我们在 ⑥处 传入的 <code>SubscribeTask</code> 对象，至此就调用到了它的 run 方法，也就是 ⑦处 的代码，完成了在 <code>Schedules.newThread()</code> 所指定的线程中调用 <code>source.subscribe(parent)</code> 的方法，使得上游的 <code>subscribe() -&gt; 即 subscribeActual()</code> 的代码都运行在了 <code>Schedules.newThread()</code> 所指定的线程中</p><h4 id="为何-subscribeOn-方法只有第一个才生效"><a href="#为何-subscribeOn-方法只有第一个才生效" class="headerlink" title="为何 subscribeOn() 方法只有第一个才生效"></a>为何 subscribeOn() 方法只有第一个才生效</h4><blockquote><p>为了避免歧义，这里先不讨论 doOnSubscribe() 的情况</p></blockquote><p>由上文我们可以知道，subscribeOn 的核心内容就是将 <code>source.subscribe(parent)</code> 方法放到指定的线程中去执行，其中 <code>source</code> 为上游，<code>parent</code> 为下游的监听者，所以上游的 <code>subscribe()</code> 方法，即 <code>subscribeActual()</code> 都会被执行在指定的线程中。</p><p>而当最上游的事件产生者接收到订阅后，就会开始发射事件，即调用 onNext、onError、onComplete 等方法，这些方法如果没有经过 observeOn 指定线程，则依然执行在subscribeOn 的线程中，否则执行在 observeOn 指定的线程中。 </p><p>所以「subscribeOn() 方法只有第一个才生效」这种说法是有点令人误解的，每一个 subscribeOn 方法都会使得其上游的 <code>subscribe() -&gt; subscribeActual()</code> 方法执行在指定的线程中</p><h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn()"></a>observeOn()</h3><p>同上理，我们从源码开始着手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="meta">@SchedulerSupport(SchedulerSupport.CUSTOM)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">&quot;scheduler is null&quot;</span>);</span><br><span class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">&quot;bufferSize&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Scheduler scheduler;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> delayError;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableObserveOn</span><span class="params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">        <span class="keyword">this</span>.delayError = delayError;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//①</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">            source.subscribe(observer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">            source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当上游调用 <code>observeOn()</code> ，包装成一个 ObservableObserveOn 对象，并传入 <code>source(即上游)</code> 和所需要调度线程的 scheduler </p><p>由上文我们可以知道，当下游调用 <code>subscribe()</code> 方法后，会调用到 ①处的 <code>subscribeActual()</code> 方法，<br>在这里创建一个 worker 对象，从上文我们知道这个 worker 是一个用来进行切换线程的抽象类<br>将 worker 和 下游的 observer 进行代理为一个 <code>ObserveOnObserver</code> 对象，并让  <code>source(即上游)</code> 订阅这个被代理了的<code>「下游 observer」</code></p><p>当上游调用下游的 <code>onNext()</code>、<code>onError()</code>、<code>onComplete()</code> 等方法时候，会调用到 <code>ObserveOnObserver</code> 这个代理对象中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BasicIntQueueDisposable</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        ......<span class="comment">//省略一些代码</span></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line">        <span class="keyword">final</span> Scheduler.Worker worker;</span><br><span class="line">        Disposable upstream;</span><br><span class="line">        ......<span class="comment">//省略一些代码</span></span><br><span class="line">        ObserveOnObserver(Observer&lt;? <span class="keyword">super</span> T&gt; actual, Scheduler.Worker worker, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize) &#123;</span><br><span class="line">            <span class="keyword">this</span>.downstream = actual;</span><br><span class="line">            <span class="keyword">this</span>.worker = worker;</span><br><span class="line">            <span class="keyword">this</span>.delayError = delayError;</span><br><span class="line">            <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            ......<span class="comment">//省略一些代码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            ......<span class="comment">//省略一些代码</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            ......<span class="comment">//省略一些代码</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ......<span class="comment">//省略一些代码</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......<span class="comment">//省略一些代码</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">                worker.schedule(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......<span class="comment">//省略一些代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (outputFused) &#123;</span><br><span class="line">                drainFused();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                drainNormal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......<span class="comment">//省略一些代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码中我们看到，在 <code>ObserveOnObserver</code> 的 <code>onNext()</code>、<code>onError()</code>、<code>onComplete()</code> 方法中调用了 <code>schedule()</code> 方法，而 <code>schedule()</code> 方法中调用了 <code>worker.schedule(this)</code></p><p>同理我们知道会在该 worker 的线程中执行 ②处的 run 方法，在 <code>run()</code> 方法中的 <code>drainNormal()</code> 和 <code>drainFused()</code> 会调用传入的「下游 observer」相对应的 <code>onNext()</code>、<code>onError()</code>、<code>onComplete()</code>等方法，也就达到了切换下游 observer 的代码的执行线程，从这里就完成了 observeOn() 的线程切换</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上述的 subscribeOn() 和 observeOn() 的流程的分析，我们可以得出以下的结论</p><ol><li>subscribeOn() 切换的是 <code>source.subscribe()</code> 这行代码的执行线程，所以他只能影响到的是从其开始，自下而上的 <code>subscribe()</code> 方法执行的线程，但从表象上看如果有多个的话，生效的只有最上游的 <code>subscribeOn()</code>，且作用域是从最上游(事件生产者)到第一个 <code>subscribeOn()</code> 之间，订阅(subscribe)是自下而上的，但事件流真正的传递(onNext、onError、onComplete)是自上而下的</li><li>observeOn() 切换的是 <code>onNext、onError、onComplete</code> 等方法的执行线程，这些方法中再调用下游的代码进行自上而下的事件传递，所以多个 observeOn() 的话，作用域的就是其下游到下一个 obserbeOn() 之间的代码</li><li>由于开发者写的代码都是在 <code>onNext、onError、onComplete</code> 中，所以从表象上看，我们所写的各个操作符中的代码都是执行在 <code>observeOn</code> 指定的线程中</li></ol><h3 id="doOn-操作符"><a href="#doOn-操作符" class="headerlink" title="doOn 操作符"></a>doOn 操作符</h3><h4 id="doOnNext、doOnError、doOnComplete"><a href="#doOnNext、doOnError、doOnComplete" class="headerlink" title="doOnNext、doOnError、doOnComplete"></a>doOnNext、doOnError、doOnComplete</h4><p>以上三个 doOn 操作符所在的线程由 subscribeOn 和 observeOn 决定</p><p>看下 doOnNext() 的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">doOnNext</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doOnEach(onNext, Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Observable&lt;T&gt; <span class="title">doOnEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError, Action onComplete, Action onAfterTerminate)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(onNext, <span class="string">&quot;onNext is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onError, <span class="string">&quot;onError is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onComplete, <span class="string">&quot;onComplete is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onAfterTerminate, <span class="string">&quot;onAfterTerminate is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableDoOnEach&lt;T&gt;(<span class="keyword">this</span>, onNext, onError, onComplete, onAfterTerminate));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道，doOnError()、doOnComplete() 方法同样是会调用 doOnEach() 方法中，通过 ObservableDoOnEach 类进行代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableDoOnEach</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> T&gt; onNext;</span><br><span class="line">    <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError;</span><br><span class="line">    <span class="keyword">final</span> Action onComplete;</span><br><span class="line">    <span class="keyword">final</span> Action onAfterTerminate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * 传入对应的 onNext、onError、onComplete、onAfterTerminate 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 上文中传入的 this，即上游的 Observable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableDoOnEach</span><span class="params">(ObservableSource&lt;T&gt; source, Consumer&lt;? <span class="keyword">super</span> T&gt; onNext,</span></span></span><br><span class="line"><span class="params"><span class="function">                              Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span></span></span><br><span class="line"><span class="params"><span class="function">                              Action onComplete,</span></span></span><br><span class="line"><span class="params"><span class="function">                              Action onAfterTerminate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.onNext = onNext;</span><br><span class="line">        <span class="keyword">this</span>.onError = onError;</span><br><span class="line">        <span class="keyword">this</span>.onComplete = onComplete;</span><br><span class="line">        <span class="keyword">this</span>.onAfterTerminate = onAfterTerminate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当调用 subscribe() 方法后会调用这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 下游或者下游的代理包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; t)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//调用上游的 subscribe 方法(-&gt; subscribeActual ) 传递给上游</span></span><br><span class="line">        source.subscribe(<span class="keyword">new</span> DoOnEachObserver&lt;T&gt;(t, onNext, onError, onComplete, onAfterTerminate));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DoOnEachObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line">        <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> T&gt; onNext;</span><br><span class="line">        <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError;</span><br><span class="line">        <span class="keyword">final</span> Action onComplete;</span><br><span class="line">        <span class="keyword">final</span> Action onAfterTerminate;</span><br><span class="line"></span><br><span class="line">        Disposable upstream;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> done;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> actual 下游 Observer</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> onNext 传入的 doOnNext 中的对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DoOnEachObserver(</span><br><span class="line">                Observer&lt;? <span class="keyword">super</span> T&gt; actual,</span><br><span class="line">                Consumer&lt;? <span class="keyword">super</span> T&gt; onNext,</span><br><span class="line">                Consumer&lt;? <span class="keyword">super</span> Throwable&gt; onError,</span><br><span class="line">                Action onComplete,</span><br><span class="line">                Action onAfterTerminate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.downstream = actual;</span><br><span class="line">            <span class="keyword">this</span>.onNext = onNext;</span><br><span class="line">            <span class="keyword">this</span>.onError = onError;</span><br><span class="line">            <span class="keyword">this</span>.onComplete = onComplete;</span><br><span class="line">            <span class="keyword">this</span>.onAfterTerminate = onAfterTerminate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...省略部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当上游调用下游的 onNext 方法时，会调用到这个方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//调用 onNext 的 accept 方法</span></span><br><span class="line">                onNext.accept(t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e);</span><br><span class="line">                upstream.dispose();</span><br><span class="line">                onError(e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再调用下游的 onNext 方法</span></span><br><span class="line">            downstream.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见，doOnXxxx() 方法会在 onXxxx() 调用之前调用，且其执行的线程和其他操作符一样由 <code>subscribeOn()</code> 和 <code>observeOn()</code> 决定</p><h4 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h4><p>在一个 RxJava 的调用链中，doOnSubscribe() 方法表示在被 subscribe 时执行</p><p>默认情况下，<code>doOnSubscribe()</code> 方法执行在 <code>subscribe()</code> 方法调用的线程中，但如果 <code>doOnSubscribe()</code> 方法后有<code>subscribeOn()</code>指定了线程，则执行在指定的线程中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="meta">@NonNull</span> ObservableEmitter&lt;Integer&gt; emitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;create thread is &quot;</span> + Thread.currentThread());</span><br><span class="line">        emitter.onNext(<span class="number">1</span>);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.newThread())</span><br><span class="line">.doOnSubscribe(<span class="keyword">new</span> Consumer&lt;Disposable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Disposable disposable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;thread is &quot;</span> + Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe();</span><br></pre></td></tr></table></figure><p>打印的日志如下<br>thread is Thread[RxCachedThreadScheduler-1,5,main]<br>create thread is Thread[RxNewThreadScheduler-2,5,main]</p><p>说明 create 的代码执行在 <code>Schedulers.newThread()</code> 线程中，而 <code>doOnSubscribe</code> 的代码执行在 <code>Schedulers.io()</code> 线程中，接着看源码来分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableCreate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableCreate</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">doOnSubscribe</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doOnLifecycle(onSubscribe, Functions.EMPTY_ACTION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">doOnLifecycle</span><span class="params">(<span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe, <span class="keyword">final</span> Action onDispose)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(onSubscribe, <span class="string">&quot;onSubscribe is null&quot;</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(onDispose, <span class="string">&quot;onDispose is null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableDoOnLifecycle&lt;T&gt;(<span class="keyword">this</span>, onSubscribe, onDispose));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上理，不废话，直接看 <code>ObservableDoOnLifecycle</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableDoOnLifecycle</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractObservableWithUpstream</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Action onDispose;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableDoOnLifecycle</span><span class="params">(Observable&lt;T&gt; upstream, Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe,</span></span></span><br><span class="line"><span class="params"><span class="function">            Action onDispose)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(upstream);</span><br><span class="line">        <span class="keyword">this</span>.onSubscribe = onSubscribe;</span><br><span class="line">        <span class="keyword">this</span>.onDispose = onDispose;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">        source.subscribe(<span class="keyword">new</span> DisposableLambdaObserver&lt;T&gt;(observer, onSubscribe, onDispose));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DisposableLambdaObserver</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; downstream;</span><br><span class="line">    <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DisposableLambdaObserver</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; actual,</span></span></span><br><span class="line"><span class="params"><span class="function">            Consumer&lt;? <span class="keyword">super</span> Disposable&gt; onSubscribe,</span></span></span><br><span class="line"><span class="params"><span class="function">            Action onDispose)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downstream = actual;</span><br><span class="line">        <span class="keyword">this</span>.onSubscribe = onSubscribe;</span><br><span class="line">        <span class="keyword">this</span>.onDispose = onDispose;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        onSubscribe.accept(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>onSubscribe()</code> 方法中会调用 <code>onSubscribe.accept()</code> 方法，即 doOnSubscribe() 中的接口方法。</p><p>而从 Create 方法中可以看到 <code>.onSubscribe()</code> 方法的调用是在 <code>subscribeActual()</code> 中调用的，而从上文我们知道 <code>subscribeActual()</code> 所执行的线程是由 <code>subscribeOn()</code> 指定的，所以 <code>.onSubscribe()</code> 方法的线程也就执行在了 subscribeOn 指定的线程中了，所以 doOnSubscribe() 方法的线程会受到 <code>subscribeOn()</code> 方法影响</p>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.&lt;br&gt;RxJava 是 Reactive Extensions 的 Java VM 实现：一个使用可观察序列组合异步和基于事件的程序的库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RxJava 通过观察者订阅被观察者进行事件的分发，并提供了很多被观察者(即事件发送者)的创建方法和事件转换的操作符函数(map、flatmap、filter 等等)&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="RxJava" scheme="https://ppting.me/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Java 动态代理</title>
    <link href="https://ppting.me/2021/11/21/2021_11_21_java_proxy/"/>
    <id>https://ppting.me/2021/11/21/2021_11_21_java_proxy/</id>
    <published>2021-11-20T16:00:00.000Z</published>
    <updated>2022-02-12T08:16:29.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>所谓代理模式，就是指「代理对象」(或者我们形象地称呼为中介)，通过实现接口类具有了接口的能力，并通过和「实际的生产者」产生联系，将「实际生产者」的能力通过自己中转给「客户(调用者)」</p><p>客户不直接通过「实际生产者」获取信息，而是跟「代理对象(中介)」打交道获取信息</p><span id="more"></span><p>我们通过房屋租赁作为例子</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>举个例子，我们有个 <code>IPriceService.java</code> 的接口，用于获取房屋的报价</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPriceService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在代码里我们还会有一个类去实现这个 <code>IPriceService.java</code> 接口，例如下面的 <code>APriceService.java</code><br>代表A房东的报价为 100元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">APriceService</span> <span class="keyword">implements</span> <span class="title">IPriceService</span></span>&#123;</span><br><span class="line">    <span class="function">override <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可能还有一个代理类，PriceServiceProxy，对 APriceService 进行代理，相当于一个「中介」，不让「租客」和「房东」接触，「中介」可以对数据(即价格)进行加工处理后再提供给「租客」</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceServiceProxy</span> <span class="keyword">implements</span> <span class="title">IPriceService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IPriceService realPriceService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriceServiceProxy</span><span class="params">(IPriceService service)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当然，这里也可以通过外部注入该中介对接的房东</span></span><br><span class="line">        realPriceService = service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">override <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//中介获取到了房东的报价</span></span><br><span class="line">        <span class="keyword">int</span> aPrice = realPriceService.getPrice();</span><br><span class="line">        <span class="comment">//再在房东报价的基础上加上中介费，返回给租客</span></span><br><span class="line">        <span class="keyword">return</span> aPrice + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是静态代理，从工程上来说，静态代理是添加一个「委托类」在不需要修改真正的实现类的基础上，做到对需求变动进行灵活修改的目的。</p><p>例如有一天需求变为「提供给租客的价格是房东的价格的 9折」，如果没有代理类，而是「租客」和「房东」直接打交道，那么我们需要修改所有实现了 IPriceService 接口的类中的 <code>getPrice()</code>方法，有了代理类，我们只需要修改代理类中的 <code>getPrice()</code> 方法，在房东的报价的基础上 * 0.9 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceServiceProxy</span> <span class="keyword">implements</span> <span class="title">IPriceService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IPriceService realPriceService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriceServiceProxy</span><span class="params">(IPriceService service)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当然，这里也可以通过外部注入该中介对接的房东</span></span><br><span class="line">        realPriceService = service;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">override <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//中介获取到了房东的报价</span></span><br><span class="line">        <span class="keyword">int</span> aPrice = realPriceService.getPrice();</span><br><span class="line">        <span class="comment">//再在房东报价的基础打9折，返回给租客</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(aPrice * <span class="number">0.9f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IPriceService priceService = <span class="keyword">new</span> PriceServiceProxy(<span class="keyword">new</span> APriceService());</span><br><span class="line">    System.out.print(<span class="string">&quot;租客获取到的房子报价为&quot;</span>+priceService.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的「静态代理」有如下几个特点：</p><ol><li>「租客」只关心报价，而不关心是谁提供了报价;<br>即只关心 IPriceService 接口的返回，而不关心实现 IPriceService 接口的实例是谁</li><li>将「租客」和「房东」分离，降低了一定的耦合性</li><li>但也需要创建很多的代理类，使得代码量增加，一旦接口需要变动，代理类和实际目标类都需要进行修改</li></ol><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理就是将上述我们的静态代理中的 PriceServiceProxy 类通过代码动态生成，并通过该动态代理对目标对象(房东)进行进一步操作，达到代理的目的</p><p>我们可以使用 Java 中的 <code>java.lang.reflect.Proxy#newProxyInstance</code> 生成动态代理对象<br>其方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数传入需要代理的接口的 ClassLoader<br>第二个参数传入需要代理的接口类<br>第三个参数传入 InvocationHandler 对象，对需要代理的目标对象进行处理</p><p>eg.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> aPriceService <span class="keyword">by</span> lazy &#123; APriceService() &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代码动态创建了一个「中介对象」priceServiceProxy</span></span><br><span class="line"><span class="keyword">val</span> priceServiceProxy = Proxy.newProxyInstance(</span><br><span class="line">            IPriceService::<span class="keyword">class</span>.java.classLoader,</span><br><span class="line">            arrayOf(IPriceService::<span class="keyword">class</span>.java),</span><br><span class="line">            <span class="keyword">object</span> : InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(proxy: <span class="type">Any</span>?, method: <span class="type">Method</span>?, args: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;?)</span></span>: Any? &#123;</span><br><span class="line">                    Log.d(<span class="string">&quot;ProxyDemoActivity&quot;</span>,<span class="string">&quot;method is <span class="subst">$&#123;method?.name&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> (method?.name?:<span class="string">&quot;&quot;</span> == <span class="string">&quot;getPrice&quot;</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果方法是「getPrice」方法，则获取对象返回的数据，然后再加上 100 后在返回</span></span><br><span class="line">                        <span class="keyword">return</span> (method?.invoke(aPriceService,*(args?: arrayOfNulls(<span class="number">0</span>))) <span class="keyword">as</span> <span class="built_in">Int</span>) + <span class="number">100</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> method?.invoke(aPriceService,*(args?: arrayOfNulls(<span class="number">0</span>)))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        ) <span class="keyword">as</span> IPriceService</span><br><span class="line"></span><br><span class="line">findViewById&lt;Button&gt;(R.id.btnProxyDemo).setOnClickListener &#123;</span><br><span class="line">    <span class="comment">//通过代理对象获取价格</span></span><br><span class="line">    Log.d(<span class="string">&quot;ProxyDemoActivity&quot;</span>,<span class="string">&quot;price is &quot;</span>+priceServiceProxy.getPrice())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，我们通过代码 Proxy.newProxyInstance 生成了一个动态代理对象，对原本的 aPriceService 对象进行代理，从中做一些「偷梁换柱」的方法</p><p>那这到底有什么用呢，静态代理不也能做到吗，何必多此一举呢。</p><p>下面我们看个例子，假设我们有个需求，需要对 Android Framework 中的 startActivity() 方法做一些拦截处理</p><p>然而这个方法的代码是我们无法编辑的，也无法通过静态代理的方式生成一个 ActivityManagerProxy 对象进行代理，这时我们就可以考虑使用动态代理的方式，生成一个动态代理对象，对 activityManager 对象进行代理，在 <code>startActivity</code> 方法前后进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; activityManagerNativeClass = <span class="keyword">null</span>;</span><br><span class="line">    Field defaultFiled = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        activityManagerNativeClass = Class.forName(<span class="string">&quot;android.app.ActivityManager&quot;</span>);</span><br><span class="line">        defaultFiled = activityManagerNativeClass.getDeclaredField(<span class="string">&quot;IActivityManagerSingleton&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activityManagerNativeClass = Class.forName(<span class="string">&quot;android.app.ActivityManagerNative&quot;</span>);</span><br><span class="line">        defaultFiled = activityManagerNativeClass.getDeclaredField(<span class="string">&quot;gDefault&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultFiled.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object defaultValue = defaultFiled.get(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//反射SingleTon</span></span><br><span class="line">    Class&lt;?&gt; SingletonClass = Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>);</span><br><span class="line">    Field mInstance = SingletonClass.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>);</span><br><span class="line">    mInstance.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//到这里已经拿到ActivityManager对象</span></span><br><span class="line">    Object iActivityManagerObject = mInstance.get(defaultValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始动态代理，用代理对象替换掉真实的ActivityManager，瞒天过海</span></span><br><span class="line">    Class&lt;?&gt; IActivityManagerIntercept = Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AmsInvocationHandler handler = <span class="keyword">new</span> AmsInvocationHandler(iActivityManagerObject);</span><br><span class="line"></span><br><span class="line">    Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;IActivityManagerIntercept&#125;, handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在替换掉这个对象</span></span><br><span class="line">    mInstance.set(defaultValue, proxy);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Log.e(<span class="string">&quot;vivid&quot;</span>,<span class="string">&quot;hook 异常&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AmsInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object iActivityManagerObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AmsInvocationHandler</span><span class="params">(Object iActivityManagerObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iActivityManagerObject = iActivityManagerObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;startActivity&quot;</span>.contains(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//我要在这里搞点事情</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(iActivityManagerObject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码则是通过反射获取到 ActivityManager 对象，然后通过动态代理构建其一个代理类，并在 <code>invoke</code> 方法中对 <code>startActivity</code> 方法进行判断处理，达到我们的目的</p><h3 id="Retrofit-中的动态代理"><a href="#Retrofit-中的动态代理" class="headerlink" title="Retrofit 中的动态代理"></a><code>Retrofit</code> 中的动态代理</h3><blockquote><p>下文基于 <code>&quot;com.squareup.retrofit2:retrofit:2.7.1&quot;</code> 分析</p></blockquote><p>我们知道在 <code>Retrofit</code> 中，api 方法的定义是定义在一个 interface 中的，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPodCastBusiness</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRss</span><span class="params">(<span class="meta">@Url</span> url: <span class="type">String</span>)</span></span>: Flowable&lt;RssResponse&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在使用该方法进行网络请求时，是使用以下的方法进行请求的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">    .client(OkHttpClient())</span><br><span class="line">    .addConverterFactory(SimpleXmlConverterFactory.create())</span><br><span class="line">    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">    .build()</span><br><span class="line">    .create(IPodCastBusiness::class.java)</span><br><span class="line">    .getRss(rssLink)</span><br></pre></td></tr></table></figure><p>我们重点看一下这个 <code>create</code> 方法，看 Retrofit 是如何将一个 <code>IPodCastBusiness</code> 的接口转化为一个实例的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第一步校验 service 是否是一个接口，不是我们现在的重点，跳过不表</span></span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="comment">//这里又见到了我们的老朋友了，在这里，通过 Proxy.newProxyInstance() 方法</span></span><br><span class="line">  <span class="comment">//将我们传入的 service 接口构建了一个动态代理对象并返回</span></span><br><span class="line">  <span class="comment">//外部则可以使用这个动态代理的实例进行下一步操作了</span></span><br><span class="line">  <span class="comment">//至于调用了接口中定义的 HTTP Request 方法是如何转化成返回类型的，则需要看 invoke 方法中的内容</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="comment">//如果这个方法是 Object 里的方法，则正常调用，不处理</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就知道了在 Retrofit 中是如何将一个 Interface 转化成一个实例对象了的<br>其远离就是通过 Proxy.newProxyInstance() 方法生成其代理对象返回</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h3&gt;&lt;p&gt;所谓代理模式，就是指「代理对象」(或者我们形象地称呼为中介)，通过实现接口类具有了接口的能力，并通过和「实际的生产者」产生联系，将「实际生产者」的能力通过自己中转给「客户(调用者)」&lt;/p&gt;
&lt;p&gt;客户不直接通过「实际生产者」获取信息，而是跟「代理对象(中介)」打交道获取信息&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://ppting.me/categories/Java/"/>
    
    <category term="设计模式" scheme="https://ppting.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Proxy" scheme="https://ppting.me/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>Android 中的图片内存</title>
    <link href="https://ppting.me/2021/05/07/2021_05_07_bitmap_in_android/"/>
    <id>https://ppting.me/2021/05/07/2021_05_07_bitmap_in_android/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2022-02-12T08:41:31.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>先提出一个问题，将两张分辨率相同(48px * 48px)，但文件大小不同的 png 图片，放在 drawable-xhdpi 文件夹下，在不同分辨率的手机上，所加载出来的 Bitmap 的占用内存大小分别是多少？</p><span id="more"></span><blockquote><p>PS. 使用 Bitmap.getByteCount() 所获取的值作为占用内存的大小</p></blockquote><p>通过以下代码获取 Bitmap 所占用的内存大小</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       setContentView(R.layout.activity_main)</span><br><span class="line">       <span class="keyword">val</span> bigBitmap = BitmapFactory.decodeResource(resources,R.drawable.big_png)</span><br><span class="line">       <span class="keyword">val</span> smallBitmap = BitmapFactory.decodeResource(resources,R.drawable.small_png)</span><br><span class="line">       Log.d(TAG,<span class="string">&quot;small png bitmap size is <span class="subst">$&#123;smallBitmap.byteCount&#125;</span>&quot;</span>)</span><br><span class="line">       Log.d(TAG,<span class="string">&quot;bid png bitmap size is <span class="subst">$&#123;bigBitmap.byteCount&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS. 表格中的 dpi 的通过 <code>resources.displayMetrics.densityDpi</code> 方法获取</p></blockquote><p><strong>图片1</strong> <em><strong>(分辨率 48px * 48px，文件大小 1.24kb)</strong></em></p><p><strong>图片2</strong> <em><strong>(分辨率 48px * 48px，文件大小 1.27kb)</strong></em></p><table><thead><tr><th>手机</th><th>分辨率</th><th>dpi</th><th>图片1 的 byteCount</th><th>图片2 的 byteCount</th></tr></thead><tbody><tr><td>Nexus S</td><td>480 * 800</td><td>hdpi&#x2F;240dpi</td><td>5184</td><td>5184</td></tr><tr><td>Nexus 4</td><td>768 * 1280</td><td>xhdpi&#x2F;320dpi</td><td>9216</td><td>9216</td></tr><tr><td>Pixel 1</td><td>1080 * 1920</td><td>420dpi</td><td>15876</td><td>15876</td></tr><tr><td>小米6</td><td>1080 * 1920</td><td>480dpi</td><td>20736</td><td>20736</td></tr><tr><td>Nexus 5</td><td>1080 * 1920</td><td>xxhdpi&#x2F;480dpi</td><td>20736</td><td>20736</td></tr><tr><td>Pixel 3a</td><td>1080 * 2220</td><td>440dpi</td><td>17424</td><td>17424</td></tr><tr><td>Pixel XL</td><td>1440 * 2560</td><td>560dpi</td><td>28244</td><td>28244</td></tr></tbody></table><p>通过以上的数据对比，可见图片1和图片2的即使文件大小不同，但运行时所占的内存都是相同的，因此我们猜测：<strong>图片运行时的内存大小和文件大小无关，只与图片的分辨率有关</strong></p><p>接下来，我们再将两张图片放到 drawable-xxhdpi 文件夹下，再通过同样的方式进行计算，得出以下表格</p><table><thead><tr><th>手机</th><th>分辨率</th><th>dpi</th><th>图片1 的 byteCount</th><th>图片2 的 byteCount</th></tr></thead><tbody><tr><td>Nexus S</td><td>480 * 800</td><td>hdpi&#x2F;240dpi</td><td>2304</td><td>2304</td></tr><tr><td>Nexus 4</td><td>768 * 1280</td><td>xhdpi&#x2F;320dpi</td><td>4096</td><td>4096</td></tr><tr><td>Pixel 1</td><td>1080 * 1920</td><td>420dpi</td><td>7056</td><td>7056</td></tr><tr><td>小米6</td><td>1080 * 1920</td><td>480dpi</td><td>9216</td><td>9216</td></tr><tr><td>Nexus 5</td><td>1080 * 1920</td><td>xxhdpi&#x2F;480dpi</td><td>9216</td><td>9216</td></tr><tr><td>Pixel 3a</td><td>1080 * 2220</td><td>440dpi</td><td>7744</td><td>7744</td></tr><tr><td>Pixel XL</td><td>1440 * 2560</td><td>560dpi</td><td>12544</td><td>12544</td></tr></tbody></table><p>这回我们同样发现图片1和图片2所占的内存都是相同的，更加肯定了我们在第一个表格后的猜测</p><p>但是，通过表格②中的「Pixel 1、小米6 和 Nexus 5」的纵向对比，三个手机的分辨率均为<strong>1080 * 1920</strong>，但三个手机的 dpi 分别为 420dpi，480dpi 和 480dpi，占用的内存为 7056、9216 和 9216，因此我们猜测，<strong>图片所占内存的大小变化也跟手机的 dpi 有关，跟手机的分辨率无关</strong></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>既然有以上的猜测，我们不如从源码中探索缘由</p><blockquote><p>PS. 以下代码基于 Android 30 版本</p></blockquote><p>在分析 <code>decodeResource</code> 方法之前，我们先来看一些基础概念</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="android-util-DisplayMetrics-density-Float"><a href="#android-util-DisplayMetrics-density-Float" class="headerlink" title="android.util.DisplayMetrics#density: Float"></a>android.util.DisplayMetrics#density: Float</h3><blockquote><p>显示的逻辑密度，这是 dip 单位的比例系数.<br>一个 dip 大概是 160dpi 屏幕上的的一个像素(例如分辨率240x320.尺寸为 1.5”x2”的屏幕)，按这个标准提供显示的基准。<br>因此在 160dpi 的屏幕上，这个值为1，在120dpi 的屏幕上，这个值为 0.75，在480dpi 的屏幕上，这个值为3.依次类推</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算方式：density = densityDpi/160</span><br></pre></td></tr></table></figure><h3 id="android-util-DisplayMetrics-densityDpi-Int"><a href="#android-util-DisplayMetrics-densityDpi-Int" class="headerlink" title="android.util.DisplayMetrics#densityDpi: Int"></a>android.util.DisplayMetrics#densityDpi: Int</h3><blockquote><p>缩写为 dpi<br>dots-per-inch</p></blockquote><p>屏幕密度，表示每英寸屏幕上的像素点个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算方式为 dpi = 斜边长/英寸</span><br></pre></td></tr></table></figure><p>在 Android 设备中，将 densityDpi 将设备分成多个显示级别，如下表</p><table><thead><tr><th></th><th>ldpi</th><th>mdpi</th><th>hdpi</th><th>xhdpi</th><th>xxhdpi</th></tr></thead><tbody><tr><td>dpi</td><td>0-120</td><td>120-160</td><td>160-320</td><td>320-480</td><td>480-640</td></tr><tr><td>比例 1dp</td><td>0.75px</td><td>1px</td><td>2px</td><td>3px</td><td>4px</td></tr></tbody></table><blockquote><p>由于 mdpi 中 1dp 刚好等于 1px 所以将 mdpi 作为基准屏幕密度</p><p>一般来说设备都会在出厂时设置一个默认的 dpi ，设置其范围内的最大值</p></blockquote><h3 id="dip-x2F-dp"><a href="#dip-x2F-dp" class="headerlink" title="dip&#x2F;dp"></a>dip&#x2F;dp</h3><blockquote><p>全称为 Density Independent Pixel<br>密度独立像素</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算方式为 dip/dp = px / (dpi / 160)</span><br></pre></td></tr></table></figure><h3 id="TypeValue"><a href="#TypeValue" class="headerlink" title="TypeValue"></a>TypeValue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TypedValue typedValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">Resources resources = getResources();</span><br><span class="line"><span class="keyword">int</span> id = resources.getIdentifier(<span class="string">&quot;ic_launcher&quot;</span>,<span class="string">&quot;mipmap&quot;</span>,getPackageName());</span><br><span class="line">resources.openRawResource(id,typedValue);</span><br><span class="line"><span class="keyword">int</span> density = typedValue.density;</span><br></pre></td></tr></table></figure><h4 id="android-util-TypedValue-density-Int"><a href="#android-util-TypedValue-density-Int" class="headerlink" title="android.util.TypedValue#density: Int"></a>android.util.TypedValue#density: Int</h4><p>如果是从 resource 中加载的图片等，这个值将会存储相对应的像素密度</p><p>例如：<br>    从 ldpi 加载的 density &#x3D;&#x3D; 120<br>    从 mdpi 加载的 density &#x3D;&#x3D; 160</p><h2 id="decodeResource"><a href="#decodeResource" class="headerlink" title="decodeResource"></a>decodeResource</h2><h4 id="decodeResource-Resources-res-int-id"><a href="#decodeResource-Resources-res-int-id" class="headerlink" title="decodeResource(Resources res, int id)"></a>decodeResource(Resources res, int id)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> decodeResource(res, id, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="decodeResource-Resources-res-int-id-Options-opts"><a href="#decodeResource-Resources-res-int-id-Options-opts" class="headerlink" title="decodeResource(Resources res, int id, Options opts)"></a>decodeResource(Resources res, int id, Options opts)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResource</span><span class="params">(Resources res, <span class="keyword">int</span> id, Options opts)</span> </span>&#123;</span><br><span class="line">    validate(opts);</span><br><span class="line">    Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> TypedValue value = <span class="keyword">new</span> TypedValue();</span><br><span class="line">        is = res.openRawResource(id, value);</span><br><span class="line"></span><br><span class="line">        bm = decodeResourceStream(res, value, is, <span class="keyword">null</span>, opts);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">/*  do nothing.</span></span><br><span class="line"><span class="comment">            If the exception happened on open, bm will be null.</span></span><br><span class="line"><span class="comment">            If it happened on close, bm is still valid.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>) is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bm == <span class="keyword">null</span> &amp;&amp; opts != <span class="keyword">null</span> &amp;&amp; opts.inBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Problem decoding into existing bitmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt; 最后走到 <code>android.graphics.BitmapFactory#decodeResourceStream</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span><span class="params">(<span class="meta">@Nullable</span> Resources res, <span class="meta">@Nullable</span> TypedValue value,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Nullable</span> InputStream is, <span class="meta">@Nullable</span> Rect pad, <span class="meta">@Nullable</span> Options opts)</span> </span>&#123;</span><br><span class="line">    validate(opts);</span><br><span class="line">    <span class="comment">//如果 opts 为空，则 new 一个 Options 对象，默认为空</span></span><br><span class="line">    <span class="keyword">if</span> (opts == <span class="keyword">null</span>) &#123;</span><br><span class="line">        opts = <span class="keyword">new</span> Options();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 opts 的 inDensity 参数</span></span><br><span class="line">    <span class="keyword">if</span> (opts.inDensity == <span class="number">0</span> &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//只有当 opts.inDensity 为0 且 TypedValue 不为空时才进行赋值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取 TypedValue 的 density 值()</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> density = value.density;</span><br><span class="line">        <span class="keyword">if</span> (density == TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">            <span class="comment">//如果 density 为默认值(0)，则设置 inDenisity 为 DisplayMetrics.DENSITY_DEFAULT(160)</span></span><br><span class="line">            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (density != TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">            <span class="comment">//如果 density 不为 DENSITY_NONE(0xffff)</span></span><br><span class="line">            <span class="comment">//只有放在 nodpi 中的图片的 density 会被设置为 DENSITY_NONE</span></span><br><span class="line">            opts.inDensity = density;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 opts 的 isTargetDenisity 为0且 res 不为空，则将设备的 densityDpi 赋值给 inTargetDensity</span></span><br><span class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后走到 <code>decodeStream()</code> 中的 native 方法中对图片进行解码</p><p>在 native 代码中，会根据前面的方法中的 BitmapFactory.Options 中设置的参数 inDensity 和 inTargetDensity 参数，对图片进行缩放</p><p>简单来说：<br>inDensity 代表资源文件所在的文件夹 dpi<br>inTargetDenisity 代表 bitmap 会被绘制的地方的像素密度</p><p>从 <a href="https://android.googlesource.com/platform/frameworks/base/+/5b0971801fdfdd7b6600b03bec3191c9709d0285/core/jni/android/graphics/BitmapFactory.cpp">BitmapFactory.cpp</a> 中可以看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (env-&gt;<span class="built_in">GetBooleanField</span>(options, gOptions_scaledFieldID)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> density = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_densityFieldID);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> targetDensity = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_targetDensityFieldID);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> screenDensity = env-&gt;<span class="built_in">GetIntField</span>(options, gOptions_screenDensityFieldID);</span><br><span class="line">            <span class="keyword">if</span> (density != <span class="number">0</span> &amp;&amp; targetDensity != <span class="number">0</span> &amp;&amp; density != screenDensity) &#123;</span><br><span class="line">                scale = (<span class="keyword">float</span>) targetDensity / density;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当 isDenisity 、inTargetDensity 不为0，且 isDenisity !&#x3D; inScreenDensity 时候，会将图片进行缩放</p><p>缩放比例为 (float)inTargetDensity&#x2F;isDenisity</p><h2 id="内存大小计算"><a href="#内存大小计算" class="headerlink" title="内存大小计算"></a>内存大小计算</h2><p>至此，我们可以回到文章开头的两个表格，来看一下图片所占用的内存是如何计算出来的</p><p>在计算之前，我们还要再看一个参数 Bitmap.Config</p><p>在 BitmapFactory.Options 中，inPreferredConfig 段默认为 ARGB_8888<br>该参数代表图片解码时使用的颜色模式</p><table><thead><tr><th>Bitmap.Config</th><th>字节数</th><th>备注</th></tr></thead><tbody><tr><td>ALPHA_8</td><td>1</td><td>每个像素占8bit,存储图片的透明值</td></tr><tr><td>RGB_565</td><td>2</td><td>每个像素占16bit，RGB 通道分别占用5，6，5bit，存储图片的 RGB 值</td></tr><tr><td>ARGB_4444(已废弃)</td><td>2</td><td>每个像素占16bit,即每个通道用4bit表示</td></tr><tr><td>ARGB_8888</td><td>4</td><td>每个像素占32bit,即每个通道用8bit表示</td></tr><tr><td>RGBA_F16</td><td>8</td><td></td></tr></tbody></table><blockquote><p>各个枚举中的数字之和代表其位数，例如 ARGB_8888 则占用 8+8+8+8 &#x3D; 32bit &#x3D; 4byte</p></blockquote><p>现在我们可以计算出一张图片在解码后所占用的内存了</p><p>内存 &#x3D; (图片像素宽 * scale ) * (图片像素高 * scale ) * 每个像素点内存占用</p><p>其中 scale &#x3D; (float)inTargetDensity&#x2F;inDenisity</p><p>我们来对上述的表格进行验证<br>对于表格1中<br>由于我们将资源文件放在了 xhdpi 文件夹中，所以 inDenisity &#x3D; 320</p><ul><li><p>Nexus S 设备<br>scale &#x3D; (float)240&#x2F;320 &#x3D; 0.75<br>图片的内存 &#x3D; (48 * 0.75 ) * (48 * 0.75 ) * 4 &#x3D; 5184 </p></li><li><p>Pixel 1<br>scale &#x3D; (float)420&#x2F;320 &#x3D; 1.3125<br>图片的内存 &#x3D; (48 * 1.3125 ) * (48 * 1.3125 ) * 4 &#x3D; 15876</p></li><li><p>小米6<br>scale &#x3D; (float)480&#x2F;320 &#x3D; 1.5<br>图片的内存 &#x3D; (48 * 1.5 ) * (48 * 1.5 ) * 4 &#x3D; 20736</p></li></ul><p>同理可以验证表格2 中的数据</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>由以上的 Bitmap 内存占用可知，要优化 bitmap 的内存大小<br>可以从以下几个方面出发</p><ol><li>将正确的资源图片放到正确的目录下🐶<blockquote><p>通过表格2和表格1的对比，如果本应放在 xxhdpi 下的图片如果放到了 xhdpi 下，会导致 bitmap 占用的内存变大</p></blockquote></li><li>对资源图片进行取样，根据所展示的 view 的宽高修改图片解码时采样率，以降低图片的分辨率</li></ol><p>eg.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ImageView 设置资源图</span></span><br><span class="line"><span class="comment"> * 会根据宽高对资源文件的采样率进行压缩，减少内存占用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resId 资源文件 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width 展示图片的 View 的宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height 展示图片的 View 的高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ImageView.<span class="title">setImage</span><span class="params">(resId: <span class="type">Int</span>,width: <span class="type">Int</span>,height: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> bitmap = BitmapFactory.Options().run &#123;</span><br><span class="line">        inJustDecodeBounds = <span class="literal">true</span></span><br><span class="line">        BitmapFactory.decodeResource(resources,resId,<span class="keyword">this</span>)</span><br><span class="line">        inSampleSize = calculateInSampleSize(<span class="keyword">this</span>,width,height)</span><br><span class="line"></span><br><span class="line">        inJustDecodeBounds = <span class="literal">false</span></span><br><span class="line">        BitmapFactory.decodeResource(resources,resId,<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(<span class="string">&quot;ImageViewExt&quot;</span>,<span class="string">&quot;bitmap size is <span class="subst">$&#123;bitmap.byteCount&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">this</span>.setImageBitmap(bitmap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据宽高计算采样率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateInSampleSize</span><span class="params">(options: <span class="type">BitmapFactory</span>.<span class="type">Options</span>, reqWidth: <span class="type">Int</span>, reqHeight: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// Raw height and width of image</span></span><br><span class="line">    <span class="keyword">val</span> (height: <span class="built_in">Int</span>, width: <span class="built_in">Int</span>) = options.run &#123; outHeight to outWidth &#125;</span><br><span class="line">    <span class="keyword">var</span> inSampleSize = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> halfHeight: <span class="built_in">Int</span> = height / <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> halfWidth: <span class="built_in">Int</span> = width / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></span><br><span class="line">        <span class="comment">// height and width larger than the requested height and width.</span></span><br><span class="line">        <span class="keyword">while</span> (halfHeight / inSampleSize &gt;= reqHeight &amp;&amp; halfWidth / inSampleSize &gt;= reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inSampleSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; title=&quot;提出问题&quot;&gt;&lt;/a&gt;提出问题&lt;/h2&gt;&lt;p&gt;先提出一个问题，将两张分辨率相同(48px * 48px)，但文件大小不同的 png 图片，放在 drawable-xhdpi 文件夹下，在不同分辨率的手机上，所加载出来的 Bitmap 的占用内存大小分别是多少？&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="Bitmap" scheme="https://ppting.me/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Handler 消息机制</title>
    <link href="https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/"/>
    <id>https://ppting.me/2021/04/21/2021_04_21_about_handler_in_android/</id>
    <published>2021-04-20T16:00:00.000Z</published>
    <updated>2022-02-12T08:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android 中，使用 Handler 主要用于不同线程间的通信</p><p><em>本文基于 Target 30 的 Android 源码进行分析</em></p><span id="more"></span><p>先来看几个类</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>Handler</strong> : 消息处理类，用来发送和处理 Message</p><p><strong>Looper</strong> : 循环器，将消息发送给 Handler 进行处理</p><p><strong>MessageQueue</strong> : 消息队列</p><p><strong>Message</strong> : 消息</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Handler-消息机制-UML-类图"><a href="#Handler-消息机制-UML-类图" class="headerlink" title="Handler 消息机制 UML 类图"></a>Handler 消息机制 UML 类图</h4><p><img src="https://i.loli.net/2021/06/08/7exYtmhbEU6k4IW.png" alt="Handler 消息机制 UML"></p><h4 id="消息机制类比图"><a href="#消息机制类比图" class="headerlink" title="消息机制类比图"></a>消息机制类比图</h4><p><img src="https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png" alt="Handler 消息机制.png"></p><h3 id="1-Example"><a href="#1-Example" class="headerlink" title="1. Example"></a>1. Example</h3><p>先来看个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> button = Button(context)</span><br><span class="line">        setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT))</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                Looper.prepare()</span><br><span class="line">                <span class="keyword">val</span> looper = Looper.myLooper()!!</span><br><span class="line">                <span class="keyword">val</span> handler = MyHandler(looper)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> message = Message().apply &#123;</span><br><span class="line">                    what = <span class="number">1</span></span><br><span class="line">                    obj = <span class="string">&quot;message&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">                handler.sendMessage(message)</span><br><span class="line"></span><br><span class="line">                Looper.loop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span></span>(looper: Looper) : Handler(looper)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line"><span class="comment">//①</span></span><br><span class="line">            Log.d(<span class="string">&quot;MyHandler&quot;</span>,<span class="string">&quot;thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span> msg.what is <span class="subst">$&#123;msg.what&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: thread is Thread-<span class="number">3</span></span><br><span class="line">MyHandler: thread is Thread-<span class="number">3</span> msg<span class="variable">.what</span> is <span class="number">1</span></span><br></pre></td></tr></table></figure><p>每点击一次按钮，会创建一个新的线程，并在该线程中通过 handler 将消息分发给 <code>MyHandler#handleMessage</code>  进行处理，在这个例子中，<code>MyHandler#handleMessage</code> 和 <code>thread&#123;&#125;</code></p><p>是同一个线程，并没有跨线程通信，所以对于线程间的通信来说，这个例子并没有什么意义，只是大概告知一下 Handler 的使用，但事实上，在 Android 的主线程(即 UI 线程、Main Thread) 就是通过这种方式对消息进行分发的</p><p>详见 <code>ActivityThread#main()</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......忽略一些细节</span></span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......忽略一些细节</span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在进行跨线程通信中，例如在子线程中做完耗时任务后，通知主线程更新UI</p><p>我们会在子线程中获取到主线程的 Looper <code>(Looper.getMainLooper())</code> 后，使用一个持有该 Looper 的 Handler 发送一个消息，而后在该 Handler 的 handlerMessage 方法中接收该消息进行更新UI 等操作</p><p>eg. 将上述例子中的 Handler 的 Looper 替换，则在 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> handler = MyHandler(Looper.getMainLooper())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> message = Message().apply &#123;</span><br><span class="line">        what = <span class="number">1</span></span><br><span class="line">        obj = <span class="string">&quot;message&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    handler.sendMessage(message)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志如下：</p><ul><li>可见已经切换到主线程中接收到信息了</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainActivity: thread is Thread[main,<span class="number">5</span>,main]</span><br><span class="line">MyHandler: thread is main msg<span class="variable">.what</span> is <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过以上的例子，我们来分析 Android 中的消息机制到底是如何运作的</p><h2 id="2-Looper"><a href="#2-Looper" class="headerlink" title="2. Looper"></a>2. Looper</h2><h3 id="2-1-prepare"><a href="#2-1-prepare" class="headerlink" title="2.1 prepare()"></a>2.1 prepare()</h3><blockquote><p>将当前线程初始化为循环线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，第一次调用 prepare() 方法时会在当前线程中 new 一个 Looper 对象，并保存在该线程的 mThreadLocal 中</p><p>若在同个线程中多次调用 prepare 方法，则会走到 if 的 case 中抛出异常</p><p><em><strong>因此保证在同一个线程中只有一个 Looper 对象存在</strong></em></p><h3 id="2-2-myLooper"><a href="#2-2-myLooper" class="headerlink" title="2.2 myLooper()"></a>2.2 myLooper()</h3><blockquote><p>获取当前线程 looper 的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    returnsThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即返回在 <code>prepare()</code> 方法中保存的 Looper 对象</p><h3 id="2-3-loop"><a href="#2-3-loop" class="headerlink" title="2.3 loop()"></a>2.3 loop()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Looper 还没有初始化，则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                    + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me.mInLoop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                        + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//开始进入死循环</span></span><br><span class="line">            <span class="comment">//获取消息队列中的第一条消息，可能回阻塞</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果当前没有需要处理的消息，则返回，继续下一个循环</span></span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                        msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//消息不为空，分发给消息对应的 target(即 Handler)去处理</span></span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该消息处理完了，将其回收复用</span></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见 loop() 方法中是一个 <code>for(;;)</code> 的死循环</p><p>大概分成：</p><ol><li>从当前 looper 对应的 messageQueue 中通过 ,mQueue.next() 方法获取下一个 Message[该方法可能会阻塞，详见 5.2 MessageQueue#next()]</li><li>分发给 Message 对应的 target (即 Handler)[ target 赋值见 4.3.1 android.os.Handler#enqueueMessage] 交由 Handler 的 dispatchMessage [见 4.4 android.os.Handler#dispatchMessage] 去处理</li><li>最后再将 Message 进行回收利用[见 3.3 Message#recycleUnchecked()]</li></ol><p>接着不断的重复这个过程</p><p>由于 loop() 方法中进行的是死循环，所以在 loop() 方法后的代码是不会被调用到的</p><p>loop() 方法中，获取下一条消息的方法 <code>messageQueue.next()</code> 是阻塞的，所以当 messageQueue 中没有新的消息了，loop() 会阻塞住[见 MessageQueue#next()]，所以不会造成 CPU 的高消耗</p><h2 id="3-Message"><a href="#3-Message" class="headerlink" title="3. Message"></a>3. Message</h2><p>Message 是整个消息分享机制中的「信使」，将信息从 A 带给 B</p><p>Message 类中包含以下一些字段</p><table><thead><tr><th>成员变量</th><th>类型</th><th>解释</th></tr></thead><tbody><tr><td>what</td><td>Int</td><td>开发者自定义的一个 code 字段，用来标识是什么类型的消息后续进行处理</td></tr><tr><td>arg1</td><td>Int</td><td>arg1 和 arg2 都是用来存储数据的备选方案，如果需要存储的数据不多而不想使用 data 的话，则可以考虑使用该字段</td></tr><tr><td>arg2</td><td>Int</td><td>同上</td></tr><tr><td>data</td><td>Bundle</td><td>用于在 Message 中存储自定义数据</td></tr><tr><td>obj</td><td>Object</td><td>用于发送给接受者的任意对象，注意，如果使用 Messager 在跨进程中的发送数据时，只能发送 framework 中的 Parcelable 对象，且不能为 null，不能发送自定义的 Parcelable 对象，要发送自定义的 Parcelable 对象应该使用 setData 方法</td></tr><tr><td>when</td><td>Long</td><td>Message 的目标发送处理时间，这个时间是基于系统开机时间计算的SystemClock#uptimeMillis</td></tr><tr><td>target</td><td>Handler</td><td>用于处理该消息的 Handler</td></tr><tr><td>callback</td><td>Runable</td><td>Runnable 类型</td></tr><tr><td>next</td><td>Message</td><td>Message 的下一个 Message，可见 Message 是一个单链表的数据结构</td></tr><tr><td>sPool</td><td>Message</td><td>用来做 Message 的缓存池</td></tr></tbody></table><h3 id="3-1-obtain"><a href="#3-1-obtain" class="headerlink" title="3.1 obtain()"></a>3.1 obtain()</h3><blockquote><p>从 Message 缓存池中获取一个 Message 对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sPoolSync 是一个锁对象，用来在对 Message 进行复用回收时候进行线程同步处理，避免多线程访问时的内存数据共享错误</p><p>首先通过上面的 Message#next 我们知道 Message 是一个单链表的数据结构</p><p>obtain() 方法判断当 sPool 不为空时，即已经有被创建出来的 Message 对象了，则赋值给 <code>m</code> 并将 <a href="http://m.next/"><code>m.next</code></a>  赋值给 sPool，即将单链表中的第一个节点取出，并将第二个节点作为 sPool ，即剩下的链表继续作为缓存池，同时将缓存池的数量减一。最后将需要返回的 <code>m</code> 的 next 赋值为 null，清除 flag 等并返回 <code>m</code></p><h3 id="3-2-recycler"><a href="#3-2-recycler" class="headerlink" title="3.2 recycler()"></a>3.2 recycler()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先检查该 Message 是否还在被使用，如果还在被使用则抛出异常，否则对该 Message 进行回收，详见 <strong>3.3 recyclerUnchecked()</strong></p><h3 id="3-3-recyclerUnchecked"><a href="#3-3-recyclerUnchecked" class="headerlink" title="3.3 recyclerUnchecked()"></a>3.3 recyclerUnchecked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">    <span class="comment">// Clear out all other details.</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = UID_NONE;</span><br><span class="line">    workSourceUid = UID_NONE;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就很简单了，将 Message 的成员变量都还原为初始化状态，接着将该 Message 插入到缓存池链表的头部，并更新缓存池的数量</p><h2 id="4-Handler"><a href="#4-Handler" class="headerlink" title="4. Handler"></a>4. Handler</h2><h3 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...忽略...</span></span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper, <span class="meta">@Nullable</span> Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个构造方法的区别在于是否有 Looper 参数</p><p>如果没有传入 Looper 参数，则会调用 Looper.myLooper() 方法获取当前线程中的 Looper 赋值给 mLooper ，如果当前线程的 Looper 还未初始化，则抛出异常</p><h3 id="4-2-sendMessageDelayed-Message-msg-long-updateMillis"><a href="#4-2-sendMessageDelayed-Message-msg-long-updateMillis" class="headerlink" title="4.2 sendMessageDelayed(Message msg , long updateMillis)"></a>4.2 sendMessageDelayed(Message msg , long updateMillis)</h3><p>Handler 中的 <code>post(Runnable r)</code> 、<code>postDelayed(@NonNull Runnable r, long delayMillis)</code> 等等方法最终都会调用 <code>boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis)</code> 方法，我们先来看如何将 Runnable 转为 Message 的方法，再接着看 sendMessageAtTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个值得注意点是，传入 sendMessageAtTime 方法中的第二个参数是用的是 SystemClock.uptimeMillis() 即当前距离开机的时间，使用这个时间就不会因为机器的时间戳变化而导致不准确的问题</p><h3 id="4-2-1-getPostMessage-Runnable-r"><a href="#4-2-1-getPostMessage-Runnable-r" class="headerlink" title="4.2.1  getPostMessage(Runnable r)"></a>4.2.1  getPostMessage(Runnable r)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即从缓存池中获取一个 Message 对象，并将其 callback 设置为传入的 Runnable 对象</p><p>至于这个 callback 的作用，详见 4.4 dispatchMessage</p><h3 id="4-3-sendMessageAtTime-Message-msg-long-uptimeMillis"><a href="#4-3-sendMessageAtTime-Message-msg-long-uptimeMillis" class="headerlink" title="4.3 sendMessageAtTime(Message msg, long uptimeMillis)"></a>4.3 sendMessageAtTime(Message msg, long uptimeMillis)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendMessageAtTime</code> 方法会先判断当前 Handler 中的消息队列 mQueue 是否为空，如果为空则抛出异常并打印日志返回</p><p>否则调用 <code>enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,long uptimeMillis)</code> 方法将该 Message 消息对象放入消息队列中</p><h3 id="4-3-1-enqueueMessage-MessageQueue-queue-Message-msg-long-updateMillis"><a href="#4-3-1-enqueueMessage-MessageQueue-queue-Message-msg-long-updateMillis" class="headerlink" title="4.3.1 enqueueMessage(MessageQueue queue,Message msg,long updateMillis)"></a>4.3.1 enqueueMessage(MessageQueue queue,Message msg,long updateMillis)</h3><p>将 Message 的 target 设置为当前的 Handler 对象，并压入 MessageQueue 队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue 的 enqueueMessage 方法详见 5.1 MessageQueue#enqueueMessage()</p><h3 id="4-4-dispatchMessage"><a href="#4-4-dispatchMessage" class="headerlink" title="4.4 dispatchMessage"></a>4.4 dispatchMessage</h3><p>在 4.3.1 方法中，enqueueMessage 方法将 Message 压入 MessageQueue 后，会被 2.3 Looper#loop() 不停获取队列中的 Message 并交由其 target(即 Handler) 处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会判断 msg 的 callback 是否为空，如果不为空，则调用该 callback 的 run 方法</p><blockquote><p>由 3. Message 中我们知道 callback 就是一个 Runnable 对象</p></blockquote><p>如果 callback 为空，则判断 Handler 的成员变量 mCallback 是否为空，如果不为空，则调用其接口方法 <code>boolean andlerMessage(Message msg)</code> ，由实现了该 Handler.Callback 接口的子类自行处理</p><p>如果 Handler 中设置了 Handler.Callback，则回调其 handleMessage 方法对消息进行处理，否则则调用 <code>public void handleMessage(@NonNull Message msg)</code> 方法，由子类  Override 该方法对信息进行处理</p><blockquote><p>PS. 如果 Handler.Callback 的 handleMessage() 方法返回了 true，则代表不再需要对该消息进行处理，否则还会调用 handleMessage 方法对该消息进行处理</p></blockquote><h2 id="5-MessageQueue"><a href="#5-MessageQueue" class="headerlink" title="5. MessageQueue"></a>5. MessageQueue</h2><blockquote><p>MessageQueue 是一个消息队列</p></blockquote><h3 id="5-1-enqueueMessage"><a href="#5-1-enqueueMessage" class="headerlink" title="5.1 enqueueMessage()"></a>5.1 enqueueMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果 Message 没有设置 target 则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="comment">//如果该 message 已经在使用了，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将消息标记为在使用中</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="comment">//将执行时间赋值给 when</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//如果 p == null(即当前消息队列没有消息)</span></span><br><span class="line">            <span class="comment">//或者 when == 0(即该消息需要立即处理)</span></span><br><span class="line">            <span class="comment">//或者 when &lt; p.when(即该消息比当前队列中的消息的需要执行的时间要早)</span></span><br><span class="line">            <span class="comment">//则将该消息插入到最前面处理</span></span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            <span class="comment">//将消息插入到队列中间</span></span><br><span class="line">            <span class="comment">//通常来说，我们不需要唤醒事件队列，除非在队列的头是一个屏障消息(target == null),并且要插入的消息是队列中的第一个异步消息</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//下面是个死循环，直到找到队列中的消息的执行时间(when 字段)小于该插入消息的时间的，插在其前面，如果没有，则插入到队列最后面</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    <span class="comment">//如果 p 是异步消息，说明要插入的消息不是第一个异步消息(因为走到这里来说明要插入的消息是插入到了 p 后面了)所以不需要唤醒</span></span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>when</code> 是指需要执行的时间戳(用距离机器开机的时间来计算)</p><ul><li>先判断 Message 的 target 是否为空，为空则抛出异常</li><li>再判断 Message 是否被使用了，如果该 Message 已经被使用了则抛出异常</li><li>再判断是否已经退出了，如果已经退出了则将 Message 回收并返回 false</li><li>以上检查无异常后，将 Message 标记为在使用</li></ul><p>着重看一下后面的一段代码</p><p>判断 </p><ol><li>p 是否为空(<em>即当前的消息队列为空</em>) </li><li>when &#x3D;&#x3D; 0(<em>即该消息需要立即执行</em>)</li><li>when&lt; p.when(即该消息的执行时间早于消息队列的第一条消息的执行时间)</li></ol><p>如果满足以上任何一个条件，则将该 Message 插入到队列的头部</p><p>否则对 消息队列进行遍历，直到将该消息插入到执行时间都比该消息小的消息后面</p><p>可见，MessageQueue 是按照 Message.when 对消息进行排序的，链表中的 Message 按照 when 的大小排序</p><h3 id="5-2-next"><a href="#5-2-next" class="headerlink" title="5.2 next()"></a>5.2 next()</h3><p>next() 内部有一个 for(;;) 的死循环，一直从 Message 链表中获取符合条件的 Message 并进行返回<br>如果在某次循环中获取不到 msg ，则会去处理 idle handler ，处理完后将 pendingIdleHandlerCount 置为 0，保证下次循环不处理 idle 了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="comment">//如果消息循环已经退出并且被处理了，则会在这里 return</span></span><br><span class="line">    <span class="comment">//这种情况可能发生在如果应用尝试在退出后重启 looper </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里会进行休眠，相对应的 nativeWait() 会进行唤醒</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="comment">//尝试检索下一条消息，如果找到了就返回</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前消息队列不为空，且 target 为 null，注意这里的 target 为 null</span></span><br><span class="line">                <span class="comment">//则从消息队列中找到异步的 Message</span></span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                <span class="comment">//msg 不为空且为同步的消息，则继续循环直到找到异步的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时 msg 就是第一个需要进行处理的 Message（可能是消息屏障后的第一个消息，也可能是原本消息队列中的头，即 mMessage）</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//如果当前时间还没到消息需要处理的时间，则设置一个延时时间，这里不会 return Message，</span></span><br><span class="line">                    <span class="comment">//如果还没到消息需要处理的时间，所以 for 循环会一直进入这个 case 导致阻塞在这里</span></span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//消息需要处理，则将该消息返回，并将链表的第二个数据移到链表头，并退出循环</span></span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 prevMsg 不为 null，说明 msg 为需要处理的异步消息，被提前取出来处理了</span></span><br><span class="line">                        <span class="comment">//而 prevMsg 就是该消息的前一个消息，现在将 msg.next 链接到 prevMsg.next 的后面，(其实就相当于删除了中间的 msg)</span></span><br><span class="line">                        <span class="comment">//此时的 mMessage 还是原来的 mMessage，下次进入 next() 方法 mMessage 还是原来的那个</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//将链表的第二个数据移到链表头</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果第一次闲置，则会获取 idleHandlers 的数量</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果 idleHandler 数量小于0，则跳过后面的 idleHandler 的逻辑，继续下一个 next() 循环</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将外部添加进来的 mIdleHandlers 列表拷贝到 mPendingIdleHandlers 数组中</span></span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="comment">//运行 idle Handler 的逻辑，这里只可能在第一次 for 循环的迭代时被执行</span></span><br><span class="line">        <span class="comment">//(因为后面将 pendingIdleHandlerCount 置为 0了，所以导致后续 pendingIdleHandlerCount 一直为 0)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//IdleHandler 各自处理逻辑，并返回是否需要被移除</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="comment">//如果返回需要被移除，则移除该 idleHandler</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        <span class="comment">//将待办的闲置 IdleHandler 的数量置为 0 </span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-quit"><a href="#5-3-quit" class="headerlink" title="5.3 quit()"></a>5.3 quit()</h3><p>将 mQuitting 标志位置为 true，后续 MessageQueue 的 next() 方法等地方 使用该字段做判断后进行处理</p><h2 id="6-消息同步屏障"><a href="#6-消息同步屏障" class="headerlink" title="6. 消息同步屏障"></a>6. 消息同步屏障</h2><blockquote><p>同步屏障，顾名思义，将同步的消息给挡住，优先处理非同步(即异步)的消息</p></blockquote><p>从以上我们 MessageQueue#next() 中，我们知道从 MessageQueue 中获取队列中的消息时，会优先获取异步的消息(msg.isAsynchronous() &#x3D;&#x3D; true)进行处理</p><h3 id="6-1-如何开启同步屏障"><a href="#6-1-如何开启同步屏障" class="headerlink" title="6.1 如何开启同步屏障"></a>6.1 如何开启同步屏障</h3><p>按理来说，要开启同步屏障，我们只需要在 <code>MessageQueue#postSyncBarrier(long when)</code> 方法中，会在 MessageQueue 消息队列的队头插入一个 message(这个 Message 的 target 为 null) 即可</p><p>这个 message 仅仅作为一个标志存在，并不用来分发事件，<br>当 looper 在进行循环🔄时，调用 queue.next() 方法，当遇到 <code>message.target == null</code> ，则会从 MessageQueue 中找到异步的消息并返回</p><p>但是由上文可知，在调用 <code>enqueueMessage</code> 方法后，会将 msg 的 target 赋值为当前的 Handler 导致我们的上面想插入一个 target &#x3D;&#x3D; null 的 Message 的想法不成立</p><p>并且 <code>MessageQueue#postSyncBarrier()</code> 方法并不开放给开发者使用，所以要开启同步屏障，我们只能通过反射该方法进行调用</p><p>而如果直接使用 <code>Handler.sendMessage()</code> 等方法插入消息，会根据时间顺序插入到队列中，如果要立即生效，则需要将消息插入队列队头，如何将消息插入到队列头部，详见 *** 6.3 如何将消息插入队列头部 ***</p><h3 id="6-2-如何插入异步消息"><a href="#6-2-如何插入异步消息" class="headerlink" title="6.2 如何插入异步消息"></a>6.2 如何插入异步消息</h3><ol><li><p>构造异步 Handler<br>从 <code>4.3.1 enqueueMessage</code> 中可以看到，当 <code>mAsynchronous</code> 字段为 true 时候，会将 message 设置为异步消息<br>所以只需要在构造 Handler 的时候，将构造方法中的 async 字段设置为 true 即可，则后续所有的消息都会是异步的消息</p></li><li><p>构造异步的 Message</p></li></ol><p>在构造 Message 时，通过 <code>setAsynchronous(boolean async)</code> 方法设置该消息为异步消息即可</p><h3 id="6-3-如何将消息插入队列头部"><a href="#6-3-如何将消息插入队列头部" class="headerlink" title="6.3 如何将消息插入队列头部"></a>6.3 如何将消息插入队列头部</h3><p>由上述分析我们知道通过 <code>Handler#enqueMessage()</code> 方法将消息插入 <code>MessageQueue</code> 中，会根据 <code>message.when</code> 由小到大插入到队列中，如果需要将消息插入到队头，那么应该使得 <code>when</code> 为 0，但 <code>when</code> 这个参数也是不支持开发者修改的</p><p>但是 <code>Handler</code> 中提供了一个 <code>Handler#postAtFrontOfQueue</code> (最终调用 <code>Handler#sendMessageAtFrontOfQueue</code>) 方法。这个方法在将消息插入队列前，会将 when 设置为0，则会将该消息插入到消息队列的队头</p><h2 id="7-举例"><a href="#7-举例" class="headerlink" title="7. 举例"></a>7. 举例</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> normalHandler <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Handler(Looper.getMainLooper(),<span class="keyword">object</span> : Handler.Callback&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;普通 Handler 回调 msg is <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> asyncHandler <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Handler.createAsync(Looper.getMainLooper(),<span class="keyword">object</span> : Handler.Callback&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            Log.d(TAG,<span class="string">&quot;异步 Handler 回调 msg is <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testSendNormalMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessage start&quot;</span>)</span><br><span class="line">    normalHandler.sendMessage(Message().apply &#123; obj = <span class="string">&quot;普通 Handler 调用 sendMessage 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessage end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessageAtFrontOfQueue start&quot;</span>)</span><br><span class="line">    asyncHandler.sendMessageAtFrontOfQueue(Message().apply &#123; obj = <span class="string">&quot;异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessageAtFrontOfQueue end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessage start&quot;</span>)</span><br><span class="line">    asyncHandler.sendMessage(Message().apply &#123; obj = <span class="string">&quot;异步 Handler 调用 sendMessage 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;异步 Handler sendMessage end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessageAtFrontOfQueue start&quot;</span>)</span><br><span class="line">    normalHandler.sendMessageAtFrontOfQueue(Message().apply &#123; obj = <span class="string">&quot;普通 Handler 调用 sendMessageAtFrontOfQueue 发送的消息&quot;</span> &#125;)</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;普通 Handler sendMessageAtFrontOfQueue end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通 Handler sendMessage start</span><br><span class="line">普通 Handler sendMessage end</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">异步 Handler sendMessage start</span><br><span class="line">异步 Handler sendMessage end</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">普通 Handler 回调 msg is &#123; when=-4d23h57m46s154ms what=0 obj=同步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-4d23h57m46s154ms what=0 obj=异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">普通 Handler 回调 msg is &#123; when=-13ms what=0 obj=普通 Handler 调用 sendMessage 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-13ms what=0 obj=异步 Handler 调用 sendMessage 发送的消息 target=android.os.Handler &#125;</span><br></pre></td></tr></table></figure><p>此时的 asyncHandler 并不能将其消息插入到消息队列的最前面，而是取决于其插入的顺序，后调用 <code>sendMessageAtFrontOfQueue</code> 的消息后插入到前面去</p><p>如果要使得 asyncHandler 插入的消息能优先处理，则需要同步屏障起作用，我们先通过反射开启一下同步屏障，再在使用完毕后关闭同步屏障</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private var barrierToken = 0</span><br><span class="line"></span><br><span class="line">fun startReflectPostSyncBarrier(looper: Looper)&#123;</span><br><span class="line">    val method: Method = MessageQueue::class.java.getDeclaredMethod(&quot;postSyncBarrier&quot;)</span><br><span class="line">    barrierToken = method.invoke(looper.queue) as Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun stopReflectPostSyncBarrier(looper: Looper)&#123;</span><br><span class="line">    val method = MessageQueue::class.java</span><br><span class="line">        .getDeclaredMethod(&quot;removeSyncBarrier&quot;, Int::class.javaPrimitiveType)</span><br><span class="line">    method.invoke(looper.queue, barrierToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>testSendNormalMessage</code> 方法前先调用 <code>startReflectPostSyncBarrier</code> 方法，建立起同步屏障</p><p>日志打印如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">普通 Handler sendMessage start</span><br><span class="line">普通 Handler sendMessage end</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">异步 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">异步 Handler sendMessage start</span><br><span class="line">异步 Handler sendMessage end</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue start</span><br><span class="line">普通 Handler sendMessageAtFrontOfQueue end</span><br><span class="line">普通 Handler 回调 msg is &#123; when=-5d0h9m7s27ms what=0 obj=普通 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-5d0h9m7s27ms what=0 obj=异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler &#125;</span><br><span class="line">异步 Handler 回调 msg is &#123; when=-11ms what=0 obj=异步 Handler 调用 sendMessage 发送的消息 target=android.os.Handler &#125;</span><br></pre></td></tr></table></figure><p><code>startReflectPostSyncBarrier()</code> 方法建立起了同步屏障，即往消息队列中插入了一条 target &#x3D; null 的消息，且 <code>msg.when</code> 的值为当前时间<br>由于普通(同步)的 Handler 将插入了一条消息到消息队列最前面，when &#x3D;&#x3D; 0，所以导致会先处理该普通消息，然后再遇到了 target &#x3D;&#x3D; null 的消息，则开始遍历异步消息进行处理，如果不调用 <code>android.os.MessageQueue#removeSyncBarrier</code> 方法将 <code>target == null</code> 的消息移除掉，则该 MessageQueue 中的同步消息就一直无法得到处理</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用以下一幅图来总结 Android 中的消息分发机制</p><p>Looper 像是一个发动机，不停地将生产者产生的 Message 从传送带(MessageQueue) 中分发给消费者去处理</p><p><img src="https://i.loli.net/2021/04/21/Fc6QszDW15xuEiG.png" alt="Handler 消息机制.png"></p><p>本文参考：</p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制1-Handler(Java层)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Android 中，使用 Handler 主要用于不同线程间的通信&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文基于 Target 30 的 Android 源码进行分析&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Handler" scheme="https://ppting.me/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Java 字符串编码</title>
    <link href="https://ppting.me/2021/04/01/2021_04_01_java_string_encode/"/>
    <id>https://ppting.me/2021/04/01/2021_04_01_java_string_encode/</id>
    <published>2021-03-31T16:00:00.000Z</published>
    <updated>2022-02-12T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文解释 Java 中的字符串编码</em></p><span id="more"></span><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><table><thead><tr><th>名词</th><th>单位</th><th>解释</th></tr></thead><tbody><tr><td>位</td><td>bit</td><td>计算机中最小的单位 用0&#x2F;1标识</td></tr><tr><td>字节</td><td>byte</td><td>可表示常用英文字符8位二进制称为一字节，一字节可以存储2^8(&#x3D;256)种状态</td></tr></tbody></table><blockquote><p>在 Java 中， char 占两个字节(2 byte)，即 16 bits</p></blockquote><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 是一个字符集，包含了全世界的几乎所有字符，现有的字符大约有百万多个，详见 <a href="https://home.unicode.org/">https://home.unicode.org/</a></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><code>码点(code point)</code>代表 Unicode 字符集中的一个值，代表一个符号</p><p><code>代码单元(code unit)</code>代表具体编码形式中的最小单位</p><p>在 Java 中，使用 <code>UTF-16</code> 作为内存中字符存储格式，即 16位，两个字节，只能存储 <code>2^16 - 1 = 65535</code> 个字符。 <code>UTF-16</code> 编码的规则很简单：基本平面的字符占用2个字节，辅助平面的字节占4个字节</p><p>则其 <code>代码单元(code unit)</code> 就是一个字节，在 Java 中，一个<code>码点(code point)</code>可能由两个<code>代码单元(code unit)</code>或者四个<code>代码单元(code unit)</code>组成</p><p>例如<code>中</code>字的码点为 <code>U+4E2D</code>，UTF-16 的编码为 <code>\u4e2d</code>，占用两个<code>代码单元(code unit)</code>，一共占用两个字节(1个 char)</p><p>但是，在 Unicode 字符集已经远远超过 65535 个字符了，难道 Java 中不能表示 Unicode 中超过 65535 的字符了吗，当然不是</p><p>在 Java 中，char 为两个字节，即16位；在代码中可以使用 <code>\uxxxx</code> 表示某个字符，但是只能表示 0x0000~0xFFFF 之间的字符，如果需要表示超过 0xFFFF以后的字符，则需要用两个 char 来表示，例如 <code>💢  U+1F4A2</code> 则使用 <code>\uD83D\uDCA2</code> 表示</p><p>很显然，这个 <code>U+1F4A2</code> 已经超过了基本面的范围<code>0x0000-0xFFFF</code> </p><p>这个<code>\uD83D\uDCA2</code>是如何计算出来的呢</p><p>在 <code>UTF-16</code> 编码中，基本面的字符使用两个字节表示，如上的<code>中</code>，辅助平面的字符使用四个字节表示。</p><p>也就是说在 <code>UTF-16</code> 中，一个字符要么为两个字节(<strong>位于[U+0000,U+FFFF]间</strong>)，要么为四个字节(<strong>位于[U+010000,U+10FFFF]间</strong>)</p><p><em><strong>那么问题来了，当遇到两个字节时，是把它当做单独的字符，还是与后面的两个字节一起当成一个四字节的字符呢？</strong></em></p><p>在 UTF-16 中，辅助平面的字符使用 20个 bit 进行表示，分为两部分，高10位和低10位</p><p>0000000000 0000000000</p><p>UTF-16编码将超过 U+FFFF 的字符，会将其拆成两个字符表示，分别为<code>H(高位 high)</code> 和 <code> L (低位 low)</code><br>并将其映射到 <code>U+D800-U+DBFF</code> 和 <code>U+DC00-U+DFFF</code> 之间（基本平面中[U+D800,U+DFFF] 为空，不对应任何字符）</p><p>即一个四个字节的辅助平面字符会使用两个基本平面的字符来表示</p><p>因此，当遇到一个字符的码点超过 U+FFFF 时候，例如 <code>💢  U+1F4A2</code> 已经超过了 U+FFFF，则在 UTF-16 中使用四个字节表示，则需要进行计算出低位和高位的数值</p><p>先计算高位。<br>减去超过的部分，得到数值 A<br>A &#x3D; 0x1F4A2 - 0x10000 &#x3D; 0xF4A2 , 即 <code>1 11101 00101 00010</code></p><p>将 A 补齐到20位二进制，得到 <code>00001 11101 00101 00010</code><br>将前十位映射到 <code>U+D800-U+DBFF</code>之间，后十位映射到 <code>U+DC00-U+DFFF</code> 之间</p><p>0xD800 的二进制为 110110 00000 00000<br>0xDC00 的二进制为 110111 00000 00000</p><p>高位：将前十位和 0xD800 相加，得到 <code>1101100000111101</code> 即 <code>0xD83D</code><br>低位：将后十位和 0xDC00 相加，得到 <code>1101110010100010</code> 即 <code>0xDCA2</code></p><p>则得到 <code>💢  U+1F4A2</code> 的 UTF-16 的编码为 <code>\uDB3D\uDCA2</code></p><p>具体的辅助平面字符的转换算法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H = (C - 0x10000) / 0x400 + 0xD800</span><br><span class="line">L = (C - 0x10000) % 0x400 + 0xDC00</span><br><span class="line"></span><br><span class="line">PS. 0x400 即 二进制的 1 00000 00000</span><br></pre></td></tr></table></figure><p>至此，将一个 Unicode 字符转为 UTF16 的编码的方法已经探究完了，现在反过来看一下在遇到 UTF16 编码时，如何将其转为 Unicode 字符</p><p>还是以<code>💢  U+1F4A2</code>为例，其 UTF-16 编码为 <code>\uDB3D\uDCA2</code>，可见第一个字符 <code>0xDB3D</code> 位于 <code>U+D800-U+DBFF</code>之间 那么可以确定 <code>\uDB3D\uDCA2</code> 是一个占四个字节的字符</p><p>接下来再进行翻译</p><p>将前一个字符减去 0xDB00 ，后一个字符减去 0xDC00</p><p>即<br>0xDB3D - 0xDB00 &#x3D; 0x003D, 即 00111101<br>0xDCA2 - 0xDC00 &#x3D; 0x00A2, 即 10100010</p><p>将高位H 和 低位L补齐到10位，即</p><p>0000111101<br>0010100010</p><p>再拼接一起，得到 <code>00001 11101 00101 00010</code>，再加上 0x10000(二进制为10000000000000000)，等于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00001 11101 00101 00010</span><br><span class="line">00010 00000 00000 00000</span><br><span class="line">-----------------------</span><br><span class="line">00011 11101 00101 00010</span><br></pre></td></tr></table></figure><p>得到 00011111010010100010(即0x1F4A2) 即<code>💢  U+1F4A2</code></p><p>Java 中 String.length 返回的字符串对应的 char 的长度而不是人类认知中字符的长度</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;💢&quot;.length() == 2</span><br><span class="line">&quot;中文&quot;.length() == 2</span><br><span class="line">&quot;中&quot;.length() == 1</span><br></pre></td></tr></table></figure><p>0001000010 1110110111</p><p>在 Java 中使用<code>码点(Code Point)</code> 来代表 Unicode 字符集中的每个字符，取值 0x000000<code>(Character.MIN_CODE_POINT)</code>-0x10FFFF<code>(Character.MAX_CODE_POINT)</code></p><p>本文参考 <a href="https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/">彻底弄懂Unicode编码</a> 感谢分享</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文解释 Java 中的字符串编码&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://ppting.me/categories/Java/"/>
    
    
    <category term="Encode" scheme="https://ppting.me/tags/Encode/"/>
    
  </entry>
  
  <entry>
    <title>Android View 的测量</title>
    <link href="https://ppting.me/2021/01/01/measure_view/"/>
    <id>https://ppting.me/2021/01/01/measure_view/</id>
    <published>2020-12-31T16:00:00.000Z</published>
    <updated>2022-02-12T08:41:00.429Z</updated>
    
    <content type="html"><![CDATA[<p><em>Android 中 view 的测量机制</em></p><span id="more"></span><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><blockquote><p>MeasureSpec 使用一个 32位的 int 数值用来存放 mode 和 size</p><p>前2位存放 mode ，后30位存放 size</p></blockquote><p>其中，mode 的类型一共有三种，分别是</p><table><thead><tr><th>mode</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td>0 &lt;&lt; 30(即00,000..[一共30个0]..000)</td><td>未指定模式，不对<code>子 view</code> 的尺寸进行限制</td></tr><tr><td>EXACTLY</td><td>1 &lt;&lt; 30(即01,000..[一共30个0]..000)</td><td>精确模式，<code>子 view</code> 的尺寸为具体的数值(xxdp)或者父 view 的大小(match_parent)</td></tr><tr><td>AT_MOST</td><td>2 &lt;&lt; 30(即10,000..[一共30个0]..000)</td><td>最大模式，<code>子 view</code> 的尺寸可以在指定范围内要多大就多大(wrap_content)</td></tr></tbody></table><blockquote><p><code>UNSPECIFIED</code> 和 <code>AT_MOST</code> 的区别在于 <code>UNSPECIFIED</code> 不限制 <code>子 view</code> 的大小</p></blockquote><p>同时，MeasureSpec 提供了两个方法，用来获取 <code>mode</code> 和 <code>size</code></p><p>PS.</p><blockquote><p>private static final int MODE_MASK  &#x3D; 0x3 &lt;&lt; 30;<br>即11,000..[一共30个0]..000</p></blockquote><p><em><strong>获取 mode</strong></em></p><p><code>android.view.View.MeasureSpec#getMode</code></p><blockquote><p>通过「&amp;」方法保留前两位数，将后30位变为0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MeasureSpecMode</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>获取 size</strong></em></p><blockquote><p>先将 MODE_MASK 按位取反，得到<br>00,111…[一共30个1]…111<br>再通过「&amp;」方法保留后30位数，将前两位变为0，则获得 size<br><code>android.view.View.MeasureSpec#getSize</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View-的测量"><a href="#View-的测量" class="headerlink" title="View 的测量"></a>View 的测量</h2><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>先来看 <code>android.view.View#onMeasure</code> 方法</p><blockquote><p>通过 getDefaultSize 方法获取 view 默认的宽&#x2F;高后进行设置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 方法是获取该 view 的最小宽度&#x2F;高度</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果没有背景，则返回设置的最小宽度(minWidth)</span></span><br><span class="line"><span class="comment"> * 否则返回背景最小宽度和设置的最小宽度(minWidth)的大者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看 getDefaultSize 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size view 的默认大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> measureSpec 父 view 对子 view 的约束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="comment">//父 view 对子 view 不做限制，则使用默认的大小</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//父 view 对子 view 限制，则使用特定的大小</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，调用子 view 的 onMeasure() 方法里的参数是怎么来的呢，我们回到 ViewGroup.measureChild() 方法</p><p>在这个方法中，会调用子 view 的 measure 方法，在 measure 方法中会调用 onMeasure 方法去测量自己的宽&#x2F;高，也就是上面讲过的 <code>android.view.View#onMeasure</code> 方法</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child 子 view</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentWidthMeasureSpec 父 view 宽的 MeasureSpec</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentHeightMeasureSpec 父 view 高的 MeasureSpec</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在这个方法中，根据parentWidthMeasureSpec、padding 以及<code>子 view</code> 的 LayoutParams 的设置，通过 getChildMeasureSpec() 该方法确定了<code>子 view</code>的 MeasureSpec，后再调用 child.measure 方法对<code>子 view</code> 进行测量</p><p>下来重点看一下 getChildMeasureSpec() 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @param spec 父 view 的 MeasureSpec</span></span><br><span class="line"><span class="comment">    * @param padding 父 view 设置的 padding</span></span><br><span class="line"><span class="comment">    * @param childDimension 该 view 希望设置的大小(即 LayoutParam 的 width/height or xml 中设置的 layout_width/layout_height)</span></span><br><span class="line"><span class="comment">    * @return 返回该 view 的 MeasureSpec</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取父 view 的 mode</span></span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="comment">//获取父 view 的 size</span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="comment">//父 view 的大小是固定的</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果子 view 设置了大小，则使用子 view 自己设置的大小和，mode 为 EXACTLY</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">//子 view 设置为 MATCH_PARENT，则使用父 view 的大小，mode 为 EXACTLY</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">//子 view 要决定自己的大小(设置为 WRAP_CONTENT)，不能超过父 view，则使用父 view 的大小，mode 为 AT_MOST(最大不能超过 size)</span></span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="comment">//父 view 没有固定大小，但有上限</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            <span class="comment">//如果子 view 设置了大小，则使用子 view 自己设置的大小，mode 为 EXACTLY</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">//子view 要求跟父 view 一样大，但父 view 是不固定的</span></span><br><span class="line">            <span class="comment">//只能约束子 view 不超过父 view，则使用父 view 的大小，mode 为 AT_MOST(最大不能超过 size)</span></span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">//子 view 要决定自己的大小(设置为 WRAP_CONTENT)，不能超过父 view，则使用父 view 的大小，mode 为 AT_MOST(最大不能超过 size)</span></span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can&#x27;t be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="comment">//父 view 没有限制，可以为任何大小</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果子 view 设置了大小，则使用子 view 自己设置的大小，mode 为 EXACTLY</span></span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">//子view 要求跟父 view 一样大，则继续看看子 view应该多大</span></span><br><span class="line">            <span class="comment">//在 Api 23 以下设置 size 为 0，Api 23以上为父 view 的 size</span></span><br><span class="line">            <span class="comment">//mode 设置为 UNSPECIFIED</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">//子 view 要决定自己的大小(设置为 WRAP_CONTENT)，</span></span><br><span class="line">            <span class="comment">//在 Api 23 以下设置 size 为 0，Api 23以上为父 view 的 size</span></span><br><span class="line">            <span class="comment">//mode 设置为 UNSPECIFIED</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="comment">//最后将 size 和 mode 组装并返回</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是通过<code>父 view</code>对<code>子 view</code>的限制来进行计算<code>子 view</code>应有的 size 和 mode</p><p>也可以通过另一种角度来确定<code>子 view</code>的 size 和 mode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec), specSize = MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>, resultMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子元素指定了具体的大小，就用子元素的大小，mode 使用 EXACTLY</span></span><br><span class="line">        resultSize = childDimension;</span><br><span class="line">        resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">        <span class="comment">// 子元素希望和父控件一样大，需要设置其上限，然后测量模式与父控件一致即可</span></span><br><span class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = specMode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (specMode == MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            <span class="comment">// API23以下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">// 子元素希望自己决定大小，设置其大小的上限是父控件的大小即可</span></span><br><span class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (specMode == MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">            <span class="comment">// API23以下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：HelloDev</span><br><span class="line">链接：https:<span class="comment">//juejin.cn/post/6844903694073331720</span></span><br><span class="line">来源：掘金</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;Android 中 view 的测量机制&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="View" scheme="https://ppting.me/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android 存储访问框架 Storage Access Framework</title>
    <link href="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/"/>
    <id>https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2022-02-12T08:14:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取&#x2F;保存&#x2F;修改手机中的文件等</p><span id="more"></span><p>SAF 包括三个部分</p><ul><li><strong>DocumentsProvider</strong><br>  内容提供程序，提供内容存储服务的应用可以实现该类，例如 Google Driver，Dropbox，OneDriver 等云存储服务甚至是本地存储服务，实现后用户可以在 <strong>Picker</strong> 中找到该程序所提供的内容</li><li><strong>Client</strong><br>  客户端程序，即发起存储访问请求的客户端</li><li><strong>Picker</strong><br>  一个系统界面，用户可以在该页面上操作符合条件的文件</li></ul><p>这里有一张 Google 文档上的图，展示了如何通过 SAF 访问存储数据</p><p><img src="https://developer.android.google.cn/images/providers/storage_dataflow.png" alt="通过 SAF 访问存储数据"></p><blockquote><p>通过 SAF 读写文件并不需要申请 <code>WRITE_EXTERNAL_STORAGE</code> 和 <code>READ_EXTERNAL_STORAGE</code> 权限</p></blockquote><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>了解了 SAF 大致的工作原理后，我们还是回归到实践中，这里演示一下在应用开发中，如何通过 SAF 去访问用户手机上的内容</p><p>其实最主要的就是通过 Intent 唤起 Picker，交给用户去操作，然后在 onActivityResult 中获取到相对应的数据再由客户端进行处理</p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><blockquote><p>创建文件需要让用户先通过 Picker 创建一个文件，再将该写入的路径提供给 Client 以供写入<br>Intent.ACTION_CREATE_DOCUMENT</p></blockquote><p>那如何让用户打开 Picker 呢，则需要 Client 通过 Intent 唤起 Picker 页面，由用户选择保存的位置和文件名后，点击确认后返回应用内。由客户端获取到 Uri 后对该文件进行写入等</p><p><img src="https://i.loli.net/2020/04/19/6vy3JM7LxtSRbBC.jpg"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重点在于这里的 Intent Action</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply &#123;</span><br><span class="line">                addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">                <span class="comment">//告知要保存的文件的 MIME 类型</span></span><br><span class="line">                type = <span class="string">&quot;image/png&quot;</span></span><br><span class="line">                <span class="comment">//提供保存的文件名，可选</span></span><br><span class="line">                putExtra(Intent.EXTRA_TITLE,<span class="string">&quot;myPicture.png&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">startActivityForResult(intent, REQUEST_CODE_FOR_WRITE_IMAGE)</span><br></pre></td></tr></table></figure><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><blockquote><p>读取文件需要用户选择文件后提供给 Client<br><strong>Intent.ACTION_OPEN_DOCUMENT</strong></p></blockquote><p>比方说，我需要用户选择一张图片作为头像</p><p>则需要通过 Intent 唤起 Picker </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_FOR_IMAGE = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply&#123;</span><br><span class="line">    <span class="comment">//对结果进行过滤，只显示可打开的文件</span></span><br><span class="line">    addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    <span class="comment">//过滤非 image 类型的文件</span></span><br><span class="line">    type = <span class="string">&quot;image/*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startActivityForResult(intent,REQUEST_CODE_FOR_IMAGE)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再在 Activity 的 onActivityResult() 回调中获取用户选择的文件的 Uri(即 data.data)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (resultCode == Activity.RESULT_OK)&#123;</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            REQUEST_CODE_FOR_IMAGE -&gt;&#123;</span><br><span class="line">                <span class="keyword">data</span>?.<span class="keyword">data</span>?.let &#123; showImage(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到该 Uri 后则可以将该 Uri 转成 Bitmap 展示在 ImageView 中</p><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><blockquote><p>编辑文件，同样的道理，你只需要通过 Intent 唤起 Picker，让用户选取文件后进行读写即可</p></blockquote><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><blockquote><p>同样的，删除文件也需要获取到该文件的 uri 后才能进行操作<br>通过 Picker 获取 Uri 的代码可以参考上文的<strong>获取文件</strong></p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentsContract.deleteDocument(contentResolver, uri)</span><br></pre></td></tr></table></figure><h2 id="获取文件夹权限"><a href="#获取文件夹权限" class="headerlink" title="获取文件夹权限"></a>获取文件夹权限</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE)</span><br><span class="line">startActivityForResult(intent,REQUEST_CODE_FOR_DIR)</span><br></pre></td></tr></table></figure><p>通过唤起 Picker ，让用户选择目录授予 Client 该文件夹的完整访问权限，包括当前存储在该文件夹下的文件以及日后存储在该文件夹下的文件</p><p>同理，在 <code>onActivityResult</code> 中可以获取到该文件夹的 <code>Uri</code> 并进行读写操作。</p><p>在用户点击「允许访问 xx 」时，会弹出一个授权提示，如下图<br><img src="https://i.loli.net/2020/04/19/hs9CGO3q7u5KxLm.png" alt="Screenshot_20200418-221258"></p><p>如果用户授权之后，在应用管理中，我们也可以看到该 APP 多了一个「取消访问权限」的按钮</p><p><img src="https://i.loli.net/2020/04/19/gFfYa7u5jnqLOlp.png" alt="Screenshot_20200418-221628"></p><p>一旦用户点击「取消访问限制」，上图中「总计」下面所罗列出来的存储位置的权限都会被取消，并且 App 不会像点击应用管理中的 「清除缓存」那样被杀死，而是还会继续在运行，所以对于应用来说，要处理好对于文件夹 Uri 的权限处理</p><h2 id="Uri-权限"><a href="#Uri-权限" class="headerlink" title="Uri 权限"></a>Uri 权限</h2><h3 id="权限时间"><a href="#权限时间" class="headerlink" title="权限时间"></a>权限时间</h3><p>根据官方文档所述，我们通过上述的方式获取到的 Uri ，事实上系统会对该 Uri 对我们的 Client 进行授权，直到用户重启设备(正常情况下是这样)</p><p><em>因为事实上还可能有上述取消访问权限的情况</em></p><p>例如说，如果我们将获取到的 Uri 进行保存(存为字符串形式)，后续再通过 <code>Uri.parse(String urlString)</code> 方法构建出来的对象，也是可以对文件进行访问的(在用户授权后至重启之间)</p><p>如果需要在设备重启后还拥有对该 Uri 的权限，则需要获取系统提供的 Uri 持久授权，这样用户则可以在设备重启后继续在该 App Client 中持续访问该文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 Uri 权限进行持久化</span></span><br><span class="line"><span class="keyword">val</span> takeFlags: <span class="built_in">Int</span> = intent.flags and</span><br><span class="line">        (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)</span><br><span class="line">contentResolver.takePersistableUriPermission(uri, takeFlags)</span><br></pre></td></tr></table></figure><blockquote><p>Caution: Even after calling takePersistableUriPermission(), your app doesn’t retain access to the URI if the associated document is moved or deleted. In those cases, you need to ask permission again to regain access to the URI.<br>还有最后一个步骤。应用最近访问的 URI 可能不再有效，原因是另一个应用可能删除或修改了文档。因此，您应始终调用 getContentResolver().takePersistableUriPermission()，以检查有无最新数据。</p></blockquote><p>官方文档上还有上述这一段描述，但是我的理解中，如果一个文件被移动或者删除了，那它所对应的 Uri 即便通过 <code>takePersistableUriPermission</code> 方法再次授权了，也是没有多大作用的呀？？这个方法本身不会有返回值告知开发者该 Uri 是否还能继续用，通过我的实验，在获取到 Uri 后，通过文件管理器等将文件进行删除，调用 <code>takePersistableUriPermission</code> 方法也不会 throw  Exception，所以官方文档上的这个 <code>move or deleted</code> 我抱有疑问，望赐教</p><h3 id="运行时权限处理"><a href="#运行时权限处理" class="headerlink" title="运行时权限处理"></a>运行时权限处理</h3><p>如果用户在应用管理中取消了访问权限，在 App 中通过 <code>contentResolver.takePersistableUriPermission</code>方法对该 Uri 进行权限申请则会 throw 下面的 Exception </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: No persistable permission grants found <span class="keyword">for</span> UID <span class="number">10200</span> and Uri  [user <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>所以我们可以通过 try catch 判断是否拥有对该目录的访问权限？</p><p>其实大可不必，通过 <code>contentResolver.getPersistedUriPermissions</code> 方法可以获取到该应用当前所拥有的权限列表，判断要使用的权限是否在列表当中即可</p><p>另外，授予了的 Uri 权限也可以通过 <code>contentResolver.releasePersistableUriPermission</code> 方法主动释放</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SAF 其实就是通过用户在 Picker 获取 DocumentProvider 提供的内容，转为 Uri 对象提供给 Client 对其进行操作，而不是 Client 直接通过 File Api 操作 External Storage ，通过将权限由开发者申请转变为了让用户自行通过系统改的 Picker 选择，从而避免了申请 <code>WRITE_EXTERNAL_STORAGE</code> 和 <code>READ_EXTERNAL_STORAGE</code> 权限 </p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>官方文档:<br>中文版:<a href="https://developer.android.google.cn/guide/topics/providers/document-provider#kotlin">使用存储访问框架打开文件</a><br>英文版:<a href="https://developer.android.com/training/data-storage/shared/documents-files">Access documents and other files from shared storage</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>对于 <code>Uri</code> 来说，可以通过 <code>ContentResolver</code> 的 Api 对文件进行处理</p><p>例如上文中提到的将 Uri 处理为 Bitmap 的方法<br>后续有空再来研究一下这些 api 以及 FileStream 的使用</p><p>下文代码大多转载于上述参考文章中的 Google 官方文档</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将图片 Uri 转为 Bitmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showImage</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>&#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main)&#123;</span><br><span class="line">        imageView.setImageBitmap(getBitmapFromUri(<span class="keyword">this</span><span class="symbol">@SAFActivity</span>,uri))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapFromUri</span><span class="params">(context: <span class="type">Context</span>,uri: <span class="type">Uri</span>)</span></span>: Bitmap&#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO)&#123;</span><br><span class="line">        <span class="keyword">val</span> parcelFileDescriptor = context.contentResolver.openFileDescriptor(uri,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> fileDescriptor = parcelFileDescriptor?.fileDescriptor</span><br><span class="line">        <span class="keyword">val</span> image = BitmapFactory.decodeFileDescriptor(fileDescriptor)</span><br><span class="line">        parcelFileDescriptor?.close()</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编辑文本文件 Uri 的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">alterDocument</span><span class="params">(uri: <span class="type">Uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//&quot;w&quot; 指写(write)权限</span></span><br><span class="line">        <span class="comment">//如果仅需要读(read)权限，传入 &quot;r&quot; 即可</span></span><br><span class="line">        contentResolver.openFileDescriptor(uri, <span class="string">&quot;w&quot;</span>)?.use &#123;</span><br><span class="line">            <span class="comment">// use&#123;&#125; lets the document provider know you&#x27;re done by automatically closing the stream</span></span><br><span class="line">            FileOutputStream(it.fileDescriptor).use &#123;</span><br><span class="line">                it.write(</span><br><span class="line">                    (<span class="string">&quot;Overwritten by MyCloud at <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>\n&quot;</span>).toByteArray()</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: FileNotFoundException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本 Uri 中的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTextFromUri</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> text = StringBuilder()</span><br><span class="line">    contentResolver.openFileDescriptor(uri,<span class="string">&quot;r&quot;</span>)?.use &#123;</span><br><span class="line">        FileInputStream(it.fileDescriptor).use&#123;</span><br><span class="line">            BufferedReader(InputStreamReader(it)).use &#123; bufferedReader-&gt;</span><br><span class="line">                <span class="keyword">var</span> line: String? = bufferedReader.readLine()</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">null</span> != line)&#123;</span><br><span class="line">                    text.append(line)</span><br><span class="line">                    line = bufferedReader.readLine()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取&amp;#x2F;保存&amp;#x2F;修改手机中的文件等&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="Storage" scheme="https://ppting.me/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title>Android MediaStore Api 使用</title>
    <link href="https://ppting.me/2020/04/19/2020_04_19_how_to_use_Android_MediaStore_Api/"/>
    <id>https://ppting.me/2020/04/19/2020_04_19_how_to_use_Android_MediaStore_Api/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2022-02-12T08:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<br><blockquote><p>本文是对 <a href="">关于 Android 的文件存储目录</a>的补充</p></blockquote><p>在 Android Q 后，<em>获得 External Storage 的权限后 使用 Environment.getExternalStorageDirectory 和 File Api 对外置存储中的文件进行操作</em> 这种方式已经不被允许了，需要开发者进行适配，后续开发者需要通过 <a href="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/"><strong>Storage Access Framework</strong></a> 或者 <strong>MediaStore</strong> 的 Api 来对 External Storage 中的文件进行操作</p><span id="more"></span><h2 id="关于权限"><a href="#关于权限" class="headerlink" title="关于权限"></a>关于权限</h2><blockquote><p>READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE</p></blockquote><p>通过 MediaStore Api 访问应用自身存放到公共目录下的文件不需要申请权限，而如果要访问其他应用保存到公共目录下的文件则需要申请权限</p><h2 id="关于-MimeType"><a href="#关于-MimeType" class="headerlink" title="关于 MimeType"></a>关于 MimeType</h2><p>从 <a href=""><code>com.android.media.MediaFormat</code></a> 源码中我们可以找到 Android 定义好的一些 MineType</p><p>例如：<br><img src="https://i.loli.net/2020/04/19/GQZdv4CSf7qVt2o.png" alt="carbon"></p><h2 id="创建-x2F-保存文件"><a href="#创建-x2F-保存文件" class="headerlink" title="创建&#x2F;保存文件"></a>创建&#x2F;保存文件</h2><p>构造一个 ContentValues 对象，通过 ContentResolver.insert 插入到对应的目录中，该方法会返回一个 Uri，通过对该 Uri 进行文件流写入即可</p><p>示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveImage</span><span class="params">(bitmap: <span class="type">Bitmap</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> values = ContentValues()</span><br><span class="line">    <span class="keyword">val</span> insertUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values)</span><br><span class="line">    insertUri?.let &#123;</span><br><span class="line">        contentResolver.openOutputStream(it).use &#123;outputStream-&gt;</span><br><span class="line">            bitmap.compress(Bitmap.CompressFormat.PNG,<span class="number">100</span>,outputStream)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>ContentValues 其实是内部使用了一个 ArrayMap 的数据结构用来存放数据，所以我们可以根据我们需要保存的文件信息，给 ContentValues 设置对应的值<br>例如：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = ContentValues().apply &#123;</span><br><span class="line">            put(MediaStore.Images.Media.MIME_TYPE,<span class="string">&quot;image/png&quot;</span>)</span><br><span class="line">            put(MediaStore.Images.Media.DISPLAY_NAME,<span class="string">&quot;<span class="subst">$&#123;System.currentTimeMillis()&#125;</span>.png&quot;</span>)</span><br><span class="line">            put(MediaStore.Images.Media.RELATIVE_PATH,<span class="string">&quot;Pictures/DemoPicture&quot;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>具体举几个例子，可见下面的表格</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>mime_type</td><td>设置文件的 MimeType</td></tr><tr><td>_display_name</td><td>指定保存的文件名，如果不设置，则系统会取当前的时间戳作为文件名</td></tr><tr><td>relative_path</td><td>指定保存的文件目录，例如上文我们将这个图片保存到了 Pictures&#x2F;DemoPicture 文件夹下，如果不设置这个值，则会被默认保存到对应的媒体类型的文件夹下，例如，图片文件(mimeType &#x3D; image&#x2F;*)会被保存到 Pictures(Environment#DIRECTORY_PICTURES) 中，需要注意的是，不能将文件放置到不对应的顶级文件夹下，比如将一个 mimeType 为 <code>audio/mpeg</code> 放大 Pictures 这样的行为是不被允许的，也就是如果设置 MIME_TYPE &#x3D; audia&#x2F;* 并将 RELATIVE_PATH 设置为 Environment#DIRECTORY_PICTURES 这样是会 Throw IllegalArgumentException 的</td></tr></tbody></table><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = ContentValues().apply &#123;</span><br><span class="line">            put(MediaStore.Images.Media.MIME_TYPE,<span class="string">&quot;image/png&quot;</span>)</span><br><span class="line">            <span class="comment">//这里将 Movies 设置为了 Primary directory </span></span><br><span class="line">            put(MediaStore.Images.Media.RELATIVE_PATH,<span class="string">&quot;<span class="subst">$&#123;Environment.DIRECTORY_MOVIES&#125;</span>/DemoPicture&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> insertUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values)</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Primary directory Video not allowed <span class="keyword">for</span> content:<span class="comment">//media/external/images/media; allowed directories are [DCIM, Pictures]</span></span><br><span class="line">        at android.database.DatabaseUtils.readExceptionFromParcel(DatabaseUtils.java:<span class="number">170</span>)</span><br><span class="line">        at android.database.DatabaseUtils.readExceptionFromParcel(DatabaseUtils.java:<span class="number">140</span>)</span><br><span class="line">        at android.content.ContentProviderProxy.insert(ContentProviderNative.java:<span class="number">481</span>)</span><br><span class="line">        at android.content.ContentResolver.insert(ContentResolver.java:<span class="number">1828</span>)</span><br></pre></td></tr></table></figure><p>Android 外部存储中的标准存储文件目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">               sdcard</span><br><span class="line">audio/*        ├── Alarms                  </span><br><span class="line">------         ├── Audiobooks           </span><br><span class="line">image/*        ├── DCIM                 </span><br><span class="line">file/*         ├── Documents            </span><br><span class="line">NA             ├── Download             </span><br><span class="line">video/*        ├── Movies               </span><br><span class="line">audio/*        ├── Music                        </span><br><span class="line">audio/*        ├── Notifications        </span><br><span class="line">image/*        ├── Pictures             </span><br><span class="line">               │   └── Screenshots      </span><br><span class="line">audio/*        ├── Podcasts             </span><br><span class="line">audio/*        └── Ringtones            </span><br></pre></td></tr></table></figure><blockquote><p>前面一列为 MimeType ，后一列为其对应的 Primary Directory<br>—— 表示未知</p></blockquote><p>需要注意的是，对于 Android 中的媒体类型，如果是需要提供给其他应用使用的，在卸载后仍需保留的媒体文件，按照规范，应当放到对应的公共目录媒体文件夹下</p><table><thead><tr><th>MimeType</th><th>对应文件夹</th></tr></thead><tbody><tr><td>图片(image&#x2F;*)</td><td>DCIM,Pictures</td></tr><tr><td>音频(audio&#x2F;*)</td><td>Alarms, Music, Notifications, Podcasts, Ringtones</td></tr><tr><td>视频(video&#x2F;*)</td><td>Movies</td></tr><tr><td>文档(file&#x2F;*)</td><td>Documents,Download</td></tr></tbody></table><p>当然，这些也都可以通过 MediaStore 放到 <code>Downloads</code> 文件夹下</p><ul><li>ContentValues 的 key 值可以通过 <code>MediaStore.XXX.Media.YYY</code> 获取到<br> XXX: 对应的媒体类型<br> YYY: 对应的字段常量</li><li>RELATIVE_PATH 的 String 值不需要以 <code>/</code> 开头</li><li>insert(uri: Uri,value: ContentValues) 的第一个参数可以通过 MediaStore 中的常量获取，具体如下</li></ul><h4 id="获取-insert-方法中的第一个入参的方式"><a href="#获取-insert-方法中的第一个入参的方式" class="headerlink" title="获取 insert 方法中的第一个入参的方式"></a>获取 insert 方法中的第一个入参的方式</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* Images</span><br><span class="line">MediaStore.Images.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">* Audio</span><br><span class="line">MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">* Video</span><br><span class="line">MediaStore.Video.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">* Download</span><br><span class="line">MediaStore.Downloads.EXTERNAL_CONTENT_URI</span><br><span class="line">* Documents</span><br><span class="line"><span class="comment">//Documents 稍微有些特殊，需要通过 Files 获取</span></span><br><span class="line">MediaStore.Files.getContentUri(<span class="string">&quot;external&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="疑问-1"><a href="#疑问-1" class="headerlink" title="疑问 1"></a>疑问 1</h4><p>有个疑问是前文图标中标记为 <code>------</code> 未知的地方，根据官方文档，Audiobooks 是可以存放 <code>audio/*</code> 类型的文件的，但通过以下代码插入一个  <code>audio/*</code> 类型的文件却抛出异常了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> values = ContentValues().apply &#123;</span><br><span class="line">            put(MediaStore.Audio.Media.MIME_TYPE,<span class="string">&quot;audio/*&quot;</span>)</span><br><span class="line">            put(MediaStore.Audio.Media.RELATIVE_PATH,<span class="string">&quot;<span class="subst">$&#123;Environment.DIRECTORY_AUDIOBOOKS&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> insertUri = contentResolver.insert(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,values)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception 信息</span></span><br><span class="line">Primary directory Audiobooks not allowed <span class="keyword">for</span> content:<span class="comment">//media/external/audio/media; allowed directories are [Alarms, Music, Notifications, Podcasts, Ringtones]</span></span><br></pre></td></tr></table></figure><p>其实就是 Android 会帮我们将这些媒体数据存放到一个数据库中，这些我们设置的数据都是数据库表中的字段，除了上面表格中罗列的一些常用的信息，还有很多数据可以设置，详细可以参考 <code>android.media.MediaStore.MediaColumns</code> 类，在这个类中我们发现了一个 <code>owner_package_name</code> 的字段，这个字段的作用，我们后面再说</p><h2 id="删除自己应用创建的文件"><a href="#删除自己应用创建的文件" class="headerlink" title="删除自己应用创建的文件"></a>删除自己应用创建的文件</h2><p>同 SAF ，获取到 Uri 后即可通过<br><code>contentResolver.delete(uri,null,null)</code> 删除即可</p><h2 id="查询自己应用的文件"><a href="#查询自己应用的文件" class="headerlink" title="查询自己应用的文件"></a>查询自己应用的文件</h2><blockquote><p>通过 <code>Cursor query(@RequiresPermission.Read @NonNull Uri uri,@Nullable String[] projection, @Nullable String selection,@Nullable String[] selectionArgs, @Nullable String sortOrder)</code> 方法</p></blockquote><p>参数解释:</p><table><thead><tr><th>参数</th><th>类型</th><th>释义</th></tr></thead><tbody><tr><td>uri</td><td>Uri</td><td>提供检索内容的 Uri，其 scheme 是<code>content://</code></td></tr><tr><td>projection</td><td>String[]</td><td>返回的列，如果传递 null 则所有列都返回(效率低下)</td></tr><tr><td>selection</td><td>String</td><td>过滤条件，即 SQL 中的 <code>WHERE</code> 语句(但不需要写 <code>where</code> 本身)，如果传 null 则返回所有的数据</td></tr><tr><td>selectionArgs</td><td>String[]</td><td>如果你在 selection 的参数加了 <code>?</code> 则会被本字段中的数据按顺序替换掉</td></tr><tr><td>sortOrder</td><td>String</td><td>用来对数据进行排序，即 SQL 语句中的 <code>ORDER BY</code>(单不需要写<code>ORDER BY</code> 本身)，如果传 null 则按照默认顺序排序(可能是无序的)</td></tr></tbody></table><p>举个🌰</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getImages</span><span class="params">()</span></span>: List&lt;Uri&gt;&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">external</span> = MediaStore.Images.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">    <span class="keyword">val</span> filesUris = mutableListOf&lt;Uri&gt;()</span><br><span class="line">    contentResolver.query(</span><br><span class="line">        <span class="comment">//从图片媒体信息中进行查询</span></span><br><span class="line">        <span class="keyword">external</span>,</span><br><span class="line">        <span class="comment">//只返回 |_ID|WIDTH|HEIGHT| 图片的 id和宽高的列信息</span></span><br><span class="line">        arrayOf(MediaStore.Images.Media._ID,MediaStore.Images.Media.WIDTH,MediaStore.Images.Media.HEIGHT) ,</span><br><span class="line">        <span class="comment">//过滤掉 id 不满足大于 230 的图片</span></span><br><span class="line">        <span class="string">&quot;<span class="subst">$&#123;MediaStore.Images.Media._ID&#125;</span> &gt; ? &quot;</span>,</span><br><span class="line">        arrayOf(<span class="string">&quot;230&quot;</span>),</span><br><span class="line">        <span class="comment">//返回的数据按照 id 降序排序</span></span><br><span class="line">        <span class="string">&quot;<span class="subst">$&#123;MediaStore.Images.Media._ID&#125;</span> DESC&quot;</span>)</span><br><span class="line">        ?.use &#123;</span><br><span class="line">            <span class="keyword">while</span> (it.moveToNext())&#123;</span><br><span class="line">                <span class="keyword">val</span> index = it.getColumnIndex(MediaStore.Images.Media._ID)</span><br><span class="line">                filesUris.add(ContentUris.withAppendedId(<span class="keyword">external</span>,it.getLong(index)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> filesUris</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="访问其他-App-的文件"><a href="#访问其他-App-的文件" class="headerlink" title="访问其他 App 的文件"></a>访问其他 App 的文件</h2><p>不知道大家有没有看到上面的标题写的都是「自己应用」的文件，这是因为我们的 App 至今还未申请 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code> 权限，通过 MediaStore Api 对自己应用创建的文件，是不需要权限的。这时因为在创建的时候系统会将我们的应用的 <code>packageName</code> 写入 <code>owner_package_name</code> 字段从而在后续的使用中判断这个文件是哪个应用创建的。</p><p>那如果应用需要访问或者修改其他应用的文件怎么办呢。</p><ol><li><p>如果只是要读取，则申请 <code>READ_EXTERNAL_STORAGE</code> 权限后即可通过 MediaStore Api 进行读取</p><p> 例如我们上述的<code>查询自己应用的文件</code>中的查询语句，如果申请了读取外置存储的权限后，返回的数据就会包含了其他 App 提供给 Media 的图片了<br> 如下图：<br> 没有读取权限时：<br> <img src="https://i.loli.net/2020/04/19/bz23sLSNlneFACZ.jpg"></p><p> 获得读取权限后：<br> <img src="https://i.loli.net/2020/04/19/zbYNDKIyV7vci6m.jpg"></p></li></ol><p>多出来几张其他 App 产生的图片</p><ol start="2"><li><p>如果需要编辑修改甚至删除其他应用的文件，则需要申请 <code>WRITE_EXTERNAL_STORAGE</code> 权限。</p><p> 如果当应用没有 <code>WRITE_EXTERNAL_STORAGE</code> 权限时，去修改其他 App 的文件时，则会 throw <code>java.lang.SecurityException: xxxx has no access to content://media/external/images/media/243</code> 的异常</p><p> 当应用拥有了 <code>WRITE_EXTERNAL_STORAGE</code> 权限后，当修改其他 App 的文件时，会 throw 另一个 Exception <code>android.app.RecoverableSecurityException: xxxxxx has no access to content://media/external/images/media/243</code></p><p> 如果我们将这个 RecoverableSecurityException 给 Catch 住，并向用户申请修改该图片的权限，用户操作后，我们就可以在 onActivityResult 回调中拿到结果进行操作了</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> editImageUri = Uri.parse(<span class="string">&quot;content://media/external/images/media/<span class="subst">$&#123;editOtherAppMediaId.text&#125;</span>&quot;</span>)</span><br><span class="line">    editImage(editImageUri)</span><br><span class="line">&#125;<span class="keyword">catch</span> (rse : RecoverableSecurityException)&#123;</span><br><span class="line"></span><br><span class="line">    rse.printStackTrace()</span><br><span class="line">    requestForOtherAppFiles(REQUEST_CODE_FOR_EDIT_IMAGE,rse)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">requestForOtherAppFiles</span><span class="params">(requestCode: <span class="type">Int</span>, rse: <span class="type">RecoverableSecurityException</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In your code, handle IntentSender.SendIntentException.</span></span><br><span class="line">        startIntentSenderForResult(</span><br><span class="line">            rse.userAction.actionIntent.intentSender</span><br><span class="line">            , requestCode,</span><br><span class="line">            <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (resultCode == Activity.RESULT_OK)&#123;</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            REQUEST_CODE_FOR_EDIT_IMAGE -&gt;&#123;</span><br><span class="line">                editImage(editImageUri)</span><br><span class="line">            &#125;</span><br><span class="line">            REQUEST_CODE_FOR_DELETE_IMAGE -&gt;&#123;</span><br><span class="line">                contentResolver.delete(deleteImageUri,<span class="literal">null</span>,<span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图，用户会收到这样的提示框。<br><img src="https://i.loli.net/2020/04/19/htFfIQ94J25XpBV.jpg"></p><p>PS. 当用户授权后，我们对该文件进行修改后，后续对这个文件的修改就不再会抛出 <code>RecoverableSecurityException</code> 了</p>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;本文是对 &lt;a href=&quot;&quot;&gt;关于 Android 的文件存储目录&lt;/a&gt;的补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Android Q 后，&lt;em&gt;获得 External Storage 的权限后 使用 Environment.getExternalStorageDirectory 和 File Api 对外置存储中的文件进行操作&lt;/em&gt; 这种方式已经不被允许了，需要开发者进行适配，后续开发者需要通过 &lt;a href=&quot;https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/&quot;&gt;&lt;strong&gt;Storage Access Framework&lt;/strong&gt;&lt;/a&gt; 或者 &lt;strong&gt;MediaStore&lt;/strong&gt; 的 Api 来对 External Storage 中的文件进行操作&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="Storage" scheme="https://ppting.me/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title>那些和 so 库有关的问题</title>
    <link href="https://ppting.me/2020/04/12/2020_04_12_about_android_so_lib/"/>
    <id>https://ppting.me/2020/04/12/2020_04_12_about_android_so_lib/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2022-02-12T08:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>旧文新发，看了自己的笔记应用，这是 18 年写的了，感觉应该还挺有用，分享一下吧</p><span id="more"></span><h2 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h2><blockquote><p>不同 Android 手机使用不同的 CPU，因此支持不同的指令集。CPU 与指令集的每种组合都有其自己的应用二进制界面（或 ABI）。 ABI 可以非常精确地定义应用的机器代码在运行时如何与系统交互。 您必须为应用要使用的每个 CPU 架构指定 ABI。</p></blockquote><p>Android 上支持的 ABI</p><p><img src="https://i.loli.net/2020/04/12/e73kWqZw5zfPFsJ.jpg"></p><h2 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h2><p>在 <code>Android Studio</code> 中，应该将 <code>so</code> 文件按照 <code>ABI</code> 分类并放置在 <code>jniLibs</code> 文件夹下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── jniLibs</span><br><span class="line">│   ├── armeabi-v7a</span><br><span class="line">│   │   └── libjcore110.so</span><br><span class="line">│   └── x86</span><br><span class="line">│       └── libjcore110.so</span><br></pre></td></tr></table></figure><h2 id="查看-Android-设备支持的-ABI-类型"><a href="#查看-Android-设备支持的-ABI-类型" class="headerlink" title="查看 Android 设备支持的 ABI 类型"></a>查看 Android 设备支持的 ABI 类型</h2><p>一般来说，设备 ABI 都是固定的，这是系统在编译时决定的，在 <code>/system/build.prop</code> 指定了设备的 ABI 类型</p><blockquote><p>primary ABI（主ABI）：对应当前系统中使用的机器码类型<br>secondary ABI（副ABI）：表示当前系统支持的其他ABI类型</p></blockquote><p>比如 Nexus 5 的 <code>build.prop</code> 文件中是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ro.product.cpu.abi=armeabi-v7a</span><br><span class="line">ro.product.cpu.abi2=armeabi</span><br><span class="line">ro.product.cpu.abilist=armeabi-v7a,armeabi</span><br><span class="line">ro.product.cpu.abilist32=armeabi-v7a,armeabi</span><br><span class="line">ro.product.cpu.abilist64=</span><br></pre></td></tr></table></figure><p>可以使用 adb 命令查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">getprop | grep abilist</span><br></pre></td></tr></table></figure><p>可以查看当前设备支持的 ABI 类型。<br>例如 Nexus 5 所支持的 ABI 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ro.product.cpu.abilist]: [armeabi-v7a,armeabi]</span><br><span class="line">[ro.product.cpu.abilist32]: [armeabi-v7a,armeabi]</span><br><span class="line">[ro.product.cpu.abilist64]: []</span><br></pre></td></tr></table></figure><p>或者在 <code>Java</code> 代码中，使用下面的代码获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Build.CPU_ABI//String 类型 primary ABI</span><br><span class="line">Build.CPU_ABI2//String 类型 secondary ABI</span><br><span class="line">Build.SUPPORTED_ABIS//String[] 类型 支持的 ABI 列表</span><br></pre></td></tr></table></figure><p>可以看到该设备(Nexus 5)的主 ABI 是 armeabi-v7a，副 ABI 是 armeabi</p><h2 id="apk-安装过程"><a href="#apk-安装过程" class="headerlink" title="apk 安装过程"></a>apk 安装过程</h2><p>apk 在安装的时候，Package Manager 会扫描 apk 文件，寻找符合条件的 so 库。<br>现根据当前设备的 primary-abi 值，寻找对应的 so 文件，当不存在 primary 的 so 库时，会寻找 secondary 的 so 库。</p><blockquote><p>即 lib&#x2F;{primary-abi}&#x2F;libName.so<br>或者 lib&#x2F;{secondary-abi}&#x2F;libName.so</p></blockquote><p>即当安装应用时，系统会根据当前设备的 CPU 架构寻找最优的 ABI 适配，如果找到合适的 so 文件，则会将整个 abi 文件夹下的 so 文件复制到 <code>/data/data/&#123;package.name&#125;/lib</code> 目录下。</p><blockquote><p>注意：apk安装过程对so选择是基于整个ABI文件夹的，而非以单个so文件为粒度，也就是说把lib&#x2F;armeabi 、lib&#x2F;armeabi-v7a、lib&#x2F;x86等等文件夹的其中一个文件夹内所有.so复制到应用的data目录下。</p></blockquote><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>在我的一个 app 中，由于使用了某个第三方的 SDK ，这个第三方 SDK 只提供了 armeabi-v7a 的 so 库，并且我在这个项目中还引用了 React Native ，React Native 中包含了 x86 和 armeabi-v7a 的 so 库。<br>所以当我在 Pad 上安装完后，打开应用后就奔溃了，奔溃日志如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.facebook.soloader.SoLoader$WrongAbiError: APK was built for a different platform</span><br></pre></td></tr></table></figure><p>使用 <code>Native Libs Monitor</code> 这个软件查看该 app 安装的 so 库时发现，该 app 使用的全是 <code>armeabi-v7a</code> 的 so 文件，所以导致了Crash。</p><p><em><strong>解决方案</strong></em></p><ul><li>方案一：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补齐 x86 下的 so 文件</span><br></pre></td></tr></table></figure><ul><li>方案二：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将第三方 SDK 提供的 so 文件复制一份到 x86 文件夹下，并在使用到这个 SDK 的功能时进行判断当前设备的 ABI ，如果是 x86 则提示用户该功能不可用。</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="ndkFilter"><a href="#ndkFilter" class="headerlink" title="ndkFilter"></a>ndkFilter</h3><p>在 <code>build.gradle</code> 中设置 ndkFilter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig&#123;</span><br><span class="line">    ndk &#123;</span><br><span class="line">         abiFilters &quot;armeabi-v7a&quot;,&quot;x86&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的配置会使得打包后的 apk 文件中只保留 <code>armeabi-v7a</code> 和 <code>x86</code> 的文件夹。</p><h3 id="splits"><a href="#splits" class="headerlink" title="splits"></a>splits</h3><p>可以通过 splits 生成指定的apk文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">splits &#123;</span><br><span class="line">    abi &#123;</span><br><span class="line">        enable true</span><br><span class="line">        reset()</span><br><span class="line">        include &#x27;x86&#x27;, &#x27;armeabi&#x27;, &#x27;armeabi-v7a&#x27;, &#x27;mips&#x27; //选择需要为 apk 编译的 ndk abi</span><br><span class="line">        universalApk false //是否打包一个包含所有 abi 的 apk 包</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://allenfeng.com/2016/11/06/what-you-should-know-about-android-abi-and-so/">谈谈 Android 的 so</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;旧文新发，看了自己的笔记应用，这是 18 年写的了，感觉应该还挺有用，分享一下吧&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 Android 的文件存储目录</title>
    <link href="https://ppting.me/2020/04/12/2020_04_12_about_android_file_path/"/>
    <id>https://ppting.me/2020/04/12/2020_04_12_about_android_file_path/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2022-02-12T08:14:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，在 Android 中，文件的存储有多个路径可供存储，也提供了多个 Api 使用，那这些 Api 到底是用来是哪个目录，又有什么区别呢。</p><span id="more"></span><h2 id="内部存储和外部存储"><a href="#内部存储和外部存储" class="headerlink" title="内部存储和外部存储"></a>内部存储和外部存储</h2><p>首先，要先知道 Android 存储中分为内部存储(Internal storage)和外部存储(External storage)</p><blockquote><p>下面用 com.application.id 作为我们的 applicationId 来举例</p></blockquote><h3 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h3><ul><li>内部存储指的是 App 私有的目录，即 &#x2F;data&#x2F;data&#x2F;com.application.id&#x2F;<blockquote><p>有些手机的目录是 &#x2F;data&#x2F;user&#x2F;0&#x2F;com.application.id&#x2F;<br>实际上是同一个目录，从下图可见，<code>/data/user/0</code> 目录是一个软连接，其实际指向的目录即 <code>/data/data</code></p></blockquote></li></ul><p>存储在这个目录下的文件是 App 私有的，其他 App 无法读写(root 用户除外)，目录会随着 App 的卸载而被删除<br><img src="https://i.loli.net/2020/04/12/vKrRneJ5ysNDgLm.jpg"></p><h3 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h3><blockquote><p>外部存储包含私有外部存储和公共目录存储</p></blockquote><h4 id="私有外部存储"><a href="#私有外部存储" class="headerlink" title="私有外部存储"></a>私有外部存储</h4><p>私有外部存储是指 <code>/storage/emulated/0/Android/data/com.application.id</code> </p><p>我们会在根目录里看到 <code>/sdcard</code>、<code>/mnt/sdcard</code>、<code>/storage/emulated/self/primary</code> 下的文件都跟上述的 <code>/storage/emulated/0</code> 中的文件一模一样，这不禁会让人感到疑惑，实际上，通过调研发现这些目录也都是软连接，可以看到其对应实际目录</p><blockquote><p><code>/sdcard</code> -&gt; <code>/storage/self/primary</code></p><p><code>/storage/self/primary</code> -&gt; <code>/mnt/user/0/primary</code></p><p><code>/mnt/user/0/primary</code> -&gt; <code>/storage/emulated/0</code></p></blockquote><p>所以其实到最后，其目录指向的都是我们的 <code>/storage/emulated/0</code> 目录</p><p>在私有外部存储中，App 可以读写自己的目录(<code>/storage/emulated/0/Android/data/com.application.id</code>)下的文件，如果 Api 大于 19，不需要申请写权限。<br>如果需要读写其他 App 的私有外部存储目录，则需要声明读写权限，若高于 23，还需要动态进行权限申请。</p><p>私有外部存储的目录也会随着 App 的卸载而被删除</p><blockquote><p>写权限 android.permission.WRITE_EXTERNAL_STORAGE</p></blockquote><p><strong>那么为什么会有这样的设计呢？这个 0 又代表什么</strong><br>我的猜测是 Android 系统中可以有多用户，这个 0 代表了当前用户，如果有第二个用户，应该就会有 1 的出现，使用软连接的方式，会保证在使用 api 获取到相对应的路径时，指向正确的用户下的文件目录，避免多个用户之间的文件系统混乱<br>当然，这只是我的猜测，未曾验证</p><h4 id="公共目录存储"><a href="#公共目录存储" class="headerlink" title="公共目录存储"></a>公共目录存储</h4><p>是指 sdcard 中根目录中的公共目录，即 <code>/storage/emulated/0</code>，例如图片文件夹(<code>/storage/emulated/0/DCIM</code>)，音乐文件(<code>/storage/emulated/0/Music</code>)</p><p>这部分的目录是共享的，所以如果 App 往这个目录下读写文件，需要申请读写权限，并且在 App 卸载后不会被删除。</p><h2 id="那我们接着看-Api-的使用"><a href="#那我们接着看-Api-的使用" class="headerlink" title="那我们接着看 Api 的使用"></a>那我们接着看 Api 的使用</h2><h3 id="获取内部存储目录"><a href="#获取内部存储目录" class="headerlink" title="获取内部存储目录"></a>获取内部存储目录</h3><blockquote><p>无需申请权限</p></blockquote><ul><li><p>Context.getFilesDir()</p><blockquote><p>获取内部存储中 files 目录<br><br>&#x2F;data&#x2F;data&#x2F;com.application.id&#x2F;files</p></blockquote></li><li><p>Context.getCacheDir()</p><blockquote><p>获取内部存储中 cache 目录<br><br>&#x2F;data&#x2F;data&#x2F;com.application.id&#x2F;cache</p></blockquote></li><li><p>Context.getDataDir()&#x2F;&#x2F;Api &gt;&#x3D; 24</p><blockquote><p>获取内部存储的存储目录的绝对路径<br><br>&#x2F;data&#x2F;data&#x2F;com.application.id</p></blockquote></li></ul><h3 id="获取外部私有存储目录"><a href="#获取外部私有存储目录" class="headerlink" title="获取外部私有存储目录"></a>获取外部私有存储目录</h3><blockquote><p>无需申请权限</p></blockquote><ul><li><p>Context.getExternalFilesDir(String type)</p><blockquote><p>获取外部私有存储中的 files 目录或其子文件夹<br><br>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;com.application.id&#x2F;files<br><br>or <br><br>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;com.application.id&#x2F;files&#x2F;type</p></blockquote></li><li><p>Context.getExternalCacheDir()</p><blockquote><p>获取外部私有存储中的 cache 目录<br><br>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;com.application.id&#x2F;cache</p></blockquote></li></ul><h3 id="获取公有目录"><a href="#获取公有目录" class="headerlink" title="获取公有目录"></a>获取公有目录</h3><blockquote><p>读写需要权限<br>写入权限 android.Manifest.permission#WRITE_EXTERNAL_STORAGE<br>读取权限 android.Manifest.permission#READ_EXTERNAL_STORAGE</p></blockquote><h4 id="对应的-API"><a href="#对应的-API" class="headerlink" title="对应的 API"></a>对应的 API</h4><ul><li><p>Environment.getExternalStorageDirectory()</p><blockquote><p>获取公有目录<br>&#x2F;storage&#x2F;emulated&#x2F;0</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_MUSIC</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_PODCASTS</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_RINGTONES</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_ALARMS</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_NOTIFICATIONS</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_PICTURES</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_MOVIES</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_DOWNLOADS</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_DCIM</span></span><br><span class="line"><span class="comment"> * #DIRECTORY_DOCUMENTS</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>Environment.getExternalStoragePublicDirectory(String type)</p><blockquote><p>获取公有目录下对应的类型文件夹<br><br>&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;DCIM 等</p></blockquote></li></ul><h2 id="Android-10-分区存储机制"><a href="#Android-10-分区存储机制" class="headerlink" title="Android 10 分区存储机制"></a>Android 10 分区存储机制</h2><p>然而，在 Android 10(Api 29) 上，我们发现通过 <code>Environment</code> 获取路径的 api 已经被标记为 Deprecated 的了</p><p><img src="https://i.loli.net/2020/04/12/S6x5utifrnPIRGz.jpg"></p><p>这…可咋整呢</p><p>其实，这对于 Android 用户来说，是一件好事来着。<br>随着 Android 的发展，Google 对用户的隐私越来越看重了，慢慢地收紧了开发者对用户设备 sdcard 的读写权限</p><p>从 Android 10 开始，对于 Target Api 为 29 的应用，根据官方文档所描述，其访问权限范围限定为外部存储，即分区存储(Scoped Storage)</p><p>简单来说，应用只能通过访问<code>Context.getFilesDir()</code> 等 api 访问自己的私有目录(<code>/data/data/packagename/</code>)，以及通过<code>Context.getExternalFilesDir(&quot;&quot;)</code> 等 api 访问外部存储中自己应用的目录(<code>/Android/data/packagename/</code>)，无需申请权限，这个行为同之前一样，没有变动。</p><p>在 <code>Target api &lt; 29</code> 时，只要应用获取到了 <code>WRITE_EXTERNAL_STORAGE</code> 权限，就可以对整个 sdcard 目录进行读取，包括其他应用的 <code>外部私有存储目录(/Android/data/otherAppPackageName/)</code></p><p>但是，在 <code>Target Api &gt;=29</code> 后，在 Android 10 设备上<strong>全新安装</strong>的应用，即便应用获得了<code>WRITE_EXTERNAL_STORAGE</code>权限后，应用也无法直接通过 <code>Java File Api</code> (例如 <code>Environment.getExternalStorageDirectory()</code>) 对 sdcard 中的非自己应用创建的文件进行读写操作。</p><blockquote><p>这里的全新安装加了着重提示，应用是从 Target Api &#x3D; 28 覆盖安装升级到 Target Api 29 的话，即便是安装在 Android 10 的手机上，若获得了<code>WRITE_EXTERNAL_STORAGE</code>权限，通过 Java File Api 仍然能够对 sdcard 中的任意文件进行读写操作</p></blockquote><p>那…问题来了，在 Target Api &gt;&#x3D; 29 上</p><ol><li>应用自身需要将多媒体文件进行存储读取，该怎么做呢。</li><li>需要访问用户其他 APP 存储的文件(例如照片，视频)，又该如何适配呢</li></ol><p>在 Android 的规范中，如果用户需要保存多媒体文件到手机中，应保存到共享目录(Share storage)中，以便其他应用访问，例如音乐应用中用户下载的音乐，拍照应用用户拍摄的照片，视频等</p><p>下面的表格总结了以上的内容，而至于如何通过 MediaStore Api 和 Storage Access Framework 进行增删查改，我们<del>下文再续</del></p><p>下文来啦：</p><p><a href="https://ppting.me/2020/04/19/2020_04_19_how_to_use_Android_MediaStore_Api/">Android MediaStore Api 使用</a></p><p><a href="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/">Android 存储访问框架 Storage Access Framework</a></p><p><img src="https://i.loli.net/2020/04/12/68YELOjySGlI4PN.jpg" alt="-w1235"></p><p>如有错误，望各位斧正</p><p>Google 官方文档：<br><a href="https://developer.android.com/about/versions/10/privacy/changes">Android 10 中的隐私权变更</a><br><a href="https://developer.android.com/training/data-storage/files/external">将文件保存到外部存储</a><br><a href="https://developer.android.com/training/data-storage/files/external-scoped">管理分区外部存储访问</a><br><a href="https://developer.android.com/training/data-storage">Data and file storage overview</a><br><a href="https://developer.android.com/guide/topics/providers/document-provider">使用存储访问框架打开文件</a><br><a href="https://developer.android.com/training/data-storage/shared">Overview of shared storage</a></p><p>本文参考文章：</p><blockquote><p>感谢各位大大的分享</p></blockquote><p><a href="https://feng.moe/archives/47/">Android Q 存储机制大变化</a><br><a href="https://www.liaohuqiu.net/cn/posts/storage-in-android/">Android 存储使用参考</a><br><a href="https://juejin.im/post/5e43ab2bf265da572660f777">Android 10 分区存储介绍及百度APP适配实践</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，在 Android 中，文件的存储有多个路径可供存储，也提供了多个 Api 使用，那这些 Api 到底是用来是哪个目录，又有什么区别呢。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="Storage" scheme="https://ppting.me/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title>从一次渠道包的渠道上报失败查看 ApplicationContext 的赋值过程</title>
    <link href="https://ppting.me/2020/02/01/2020_02_01_application_lifecycle/"/>
    <id>https://ppting.me/2020/02/01/2020_02_01_application_lifecycle/</id>
    <published>2020-02-01T07:34:22.000Z</published>
    <updated>2022-02-12T08:13:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前在项目的开发中，同事遇到了一个问题</p><blockquote><p>在某个版本后交给市场部门同事的 apk 文件，市场的同事反馈，线上的用户新装后的上报的渠道全是官方渠道</p><p>PS. 项目中使用美团的 <a href="https://github.com/Meituan-Dianping/walle">Walle</a> 进行多渠道打包</p></blockquote><span id="more"></span><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>组里的另一个同事开始排查问题，先是排查了交给市场同事的签渠道的工具是不是出了问题。于是先自己用该工具对 apk 进行渠道签入进行检查，发现确实不行。于是手动写入渠道，Debug 发现通过 <code>WalleChannelReader.getChannel(this.getApplicationContext())</code>方法获取到的值一直为空</p><p>后来，组内的同事来找我讨论这个问题，同事猜测是否跟之前引入了某个依赖库有关系，而按照我的理解，美团的渠道获取是通过获取到 .apk 文件然后从该文件中的某个分区里获取写入的渠道的，所以应该跟这个问题不会有关系。</p><p>我开始看项目中的代码，看似没有问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#XXXXApplication.<span class="function">java </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String channel = WalleChannelReader.getChannel(getApplicationContext(), <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(channel)) &#123;</span><br><span class="line">        channel = <span class="string">&quot;xxxx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实在没辙了，只好通过 git commit 对比在出现问题前的代码，看是否在做某个需求时不小心改动了此处的代码。</p><p>果不其然，发现是另一个同事在做另一个需求的时候，不小心将 <code>getChannel()</code> 的调用放到了 <code>Application#attachBaseContext()</code> 方法中。</p><p>而通过查看<code>walle</code> 的源码，发现 <code>WalleChannelReader.getChannel(Context context)</code> 中需要通过 <code>applicationContext</code> 获取到 .apk 文件的地址(path) 才能获取到写在分区内的渠道。</p><p>walle 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的 context 即 WalleChannelReader.getChannel(Context context) 中传入的 context</span></span><br><span class="line"><span class="comment">//所以这里的 context.getApplicationInfo() 为 null</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getApkPath</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">    String apkPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ApplicationInfo applicationInfo = context.getApplicationInfo();</span><br><span class="line">        <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        apkPath = applicationInfo.sourceDir;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> apkPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，bug 解决了，将上报渠道的代码重新恢复到 <code>onCreate()</code> 后即可</p><p>但，仅仅是修复了 bug ，但问题的背后，还有很多不了解的地方。</p><h2 id="思考🤔"><a href="#思考🤔" class="headerlink" title="思考🤔"></a>思考🤔</h2><p>于是我开始思考</p><p><strong>为何在 <code>attachBaseContext(base: Context?)</code> 方法中获取不到 applicationContext</strong></p><p>首先，看一下 application 的生命周期，他是如何被创建出来的，这就要从 App 启动流程说起，但这是个比较复杂的过程，但对于这个问题，我们查看源码时只关注跟 context 相关的代码，忽略其他代码，避免在其中浪费太多时间和消耗无谓的精力</p><p>首先看一下 <code>getApplicationContext()</code> 方法的实现，可以看到</p><p><code>ContextWrapper.java</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Context getApplicationContext() &#123;</span><br><span class="line">    return mBase.getApplicationContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪，看一下 <code>mBase.getApplicationContext()</code> 返回的是什么</p><p>在 <code>Context.java</code> 中可见，这是一个抽象(<code>abstract</code>)类，其 <code>Context getApplicaitonContext()</code> 是个抽象(<code>abstract</code>)方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return the context of the single, global Application object of the</span><br><span class="line"> * current process.  This generally should only be used if you need a</span><br><span class="line"> * Context whose lifecycle is separate from the current context, that is</span><br><span class="line"> * tied to the lifetime of the process rather than the current component.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Consider for example how this interacts with</span><br><span class="line"> * &#123;@link #registerReceiver(BroadcastReceiver, IntentFilter)&#125;:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt; &lt;p&gt;If used from an Activity context, the receiver is being registered</span><br><span class="line"> * within that activity.  This means that you are expected to unregister</span><br><span class="line"> * before the activity is done being destroyed; in fact if you do not do</span><br><span class="line"> * so, the framework will clean up your leaked registration as it removes</span><br><span class="line"> * the activity and log an error.  Thus, if you use the Activity context</span><br><span class="line"> * to register a receiver that is static (global to the process, not</span><br><span class="line"> * associated with an Activity instance) then that registration will be</span><br><span class="line"> * removed on you at whatever point the activity you used is destroyed.</span><br><span class="line"> * &lt;li&gt; &lt;p&gt;If used from the Context returned here, the receiver is being</span><br><span class="line"> * registered with the global state associated with your application.  Thus</span><br><span class="line"> * it will never be unregistered for you.  This is necessary if the receiver</span><br><span class="line"> * is associated with static data, not a particular component.  However</span><br><span class="line"> * using the ApplicationContext elsewhere can easily lead to serious leaks</span><br><span class="line"> * if you forget to unregister, unbind, etc.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span><br><span class="line">public abstract Context getApplicationContext();</span><br></pre></td></tr></table></figure><blockquote><p>简单解释一下这段注释</p><p>返回当前进程的全局唯一的 Application 单例对象</p><p>通常来说，仅当需要一个生命周期和当前上下文分开的 Context 时才使用此方法，该 Context 的生命周期和进程的生命周期相关，而和当前的组件无关</p><p>思考一下例如如何与 registerReceiver(BroadcastReceiver, IntentFilter) 交互</p><p>如果使用一个 Activity Context ，接收器会在 Activity 内被注册，这意味着你需要在 Activity 销毁之前取消注册，否则 framework 会在 activity 移除时清理掉你泄漏的注册并记录下错误。因此，如果你使用 Activity Context 注册一个静态的接收器（进程内全局的，与该 Activity 实例无关） 那么无论你使用的 Activity 什么时候被销毁，这个注册都会被移除</p><p>如果使用这里返回的 Context ，则会向你的应用程序相关的全局状态注册接收器，因此他永远不会为你注销。接收器与静态数据而不是特定的组件相关联，这是有必要的。</p><p>但是如果你忘记注销，取消绑定等，则在其他地方使用 Application Context 可能容易导致严重的泄漏</p></blockquote><p>那我们就接着看这个方法的实现，正是在 <code>ContextWrapper.java</code> 中，也就是说，<code>ContextWrapper</code> 继承自 <code>Context</code>，并实现了该方法</p><p>那我们看一下这个 <code>mBase</code> 是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Context mBase;</span><br><span class="line">public ContextWrapper(Context base)&#123;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void attachBaseContext(Context base)&#123;</span><br><span class="line">    if(mBase == null)&#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Base context already set&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不管 mBase 是在什么时候被赋值的，先去看 mBase 的 getApplicationContext() 方法到底做了些什么。<br>由断点处的信息可见，mBase 即 <code>ContextImpl</code> 的实例，我们也知道 Context 只有一个实现类，即 <code>ContextImpl</code>，找到 <code>ContextImpl.java</code> 类。找到 <code>getApplicaitonContext()</code> 方法的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPackageInfo != <span class="keyword">null</span>) ?</span><br><span class="line">            mPackageInfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们就知道 <code>getApplicaitonContext()</code> 方法返回的要么是<code>mPackageInfo.getApplication()</code> 要么是 <code>mMainThread.getApplication()</code></p><p>那么在 <code>attachBaseContext()</code> 方法时候调用 <code>getApplicaitonContext()</code> 方法到底是返回哪个呢，这取决于 <code>mPackageInfo</code> 是否为空。</p><p>那继续看 <code>mPackageInfo</code> 是在什么时候被赋值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContextImpl</span><span class="params">(<span class="meta">@Nullable</span> ContextImpl container, <span class="meta">@NonNull</span> ActivityThread mainThread,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@NonNull</span> LoadedApk packageInfo, <span class="meta">@Nullable</span> String splitName,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> IBinder activityToken, <span class="meta">@Nullable</span> UserHandle user, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Nullable</span> ClassLoader classLoader, <span class="meta">@Nullable</span> String overrideOpPackageName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//忽略对我们来说暂时不重要的其他代码</span></span><br><span class="line">        ...</span><br><span class="line">        mPackageInfo = packageInfo;</span><br><span class="line">        <span class="comment">//忽略对我们来说暂时不重要的其他代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即 <code>mPackageInfo</code> 是在 ContextImpl 的构造方法中赋值的，那也就是说非特殊情况下，<code>mPackageInfo</code> 是不会为 <code>null</code> 的。</p><p>那我们接着看 <code>mPackageInfo.getApplication()</code> 的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#LoadedApk.java</span><br><span class="line"><span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line"><span class="function">Application <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mApplication;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是 <code>LoadedApk</code> 实例中的一个私有变量，继续看是什么时候赋值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="params"><span class="function">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;makeApplication&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String appClass = mApplicationInfo.className;</span><br><span class="line">        <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            appClass = <span class="string">&quot;android.app.Application&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (!mPackageName.equals(<span class="string">&quot;android&quot;</span>)) &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        <span class="string">&quot;initializeJavaContextClassLoader&quot;</span>);</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">&quot;Unable to instantiate application &quot;</span> + appClass</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityThread.mAllApplications.add(app);</span><br><span class="line">        <span class="comment">//②</span></span><br><span class="line">        mApplication = app;</span><br><span class="line">        <span class="comment">//忽略暂时不关心的代码</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们重点看一下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line">app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);</span><br></pre></td></tr></table></figure><p>跟踪一下 <code>newApplication()</code> 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = getFactory(context.getPackageName())</span><br><span class="line">            .instantiateApplication(cl, className);</span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在这里调用了 Application 的 <code>attach(Context context)</code> 方法</p><p>而  <code>Application</code> 这个类中的 <code>attach</code> 方法中调用了 <code>attachBaseContext(Context context)</code> 方法，而这个，就是我们在自定义的 <code>XXApplication</code> 中 Override 的 <code>attachBaseContext(Context context)</code> ，而根据上面的分析，我们知道此时还未给 ②<code>mApplication</code> 赋值，所以我们在 <code>attachBaseContext(Context context)</code> 方法中调用 <code>getApplicaitonContext()</code> 就为 null</p><p>到此，真相大白</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前在项目的开发中，同事遇到了一个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在某个版本后交给市场部门同事的 apk 文件，市场的同事反馈，线上的用户新装后的上报的渠道全是官方渠道&lt;/p&gt;
&lt;p&gt;PS. 项目中使用美团的 &lt;a href=&quot;https://github.com/Meituan-Dianping/walle&quot;&gt;Walle&lt;/a&gt; 进行多渠道打包&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    <category term="记录" scheme="https://ppting.me/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="HTTP" scheme="https://ppting.me/tags/HTTP/"/>
    
    <category term="FixBug" scheme="https://ppting.me/tags/FixBug/"/>
    
    <category term="WebView" scheme="https://ppting.me/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>使用 Lint 进行代码检查</title>
    <link href="https://ppting.me/2019/10/25/2019_10_26_lint_check_code/"/>
    <id>https://ppting.me/2019/10/25/2019_10_26_lint_check_code/</id>
    <published>2019-10-25T12:37:24.000Z</published>
    <updated>2022-02-12T08:13:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Lint-进行代码检查"><a href="#使用-Lint-进行代码检查" class="headerlink" title="使用 Lint 进行代码检查"></a>使用 Lint 进行代码检查</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了进一步规范协同合作中的代码规范，避免写低级 Bug 和对代码进行规约，在调研了多种方案后，决定使用该种方案对代码进行自动化检查和规约</p><span id="more"></span><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Github 开源地址：<a href="https://github.com/PPTing/AwesomeLint">https://github.com/PPTing/AwesomeLint</a></p><ol><li>先在配置文件(<code>local.properties</code>)中配置 <code>nexusUrl</code> 的值为本地仓库的地址</li><li>复制 git hook 脚本<br></li></ol><p>2.1 在根目录下执行执行<br>Windows:</p><p>  2.1.1 修改 <code>pre-commit-windows</code> 文件中的第一行代码中的<code>D:/Git</code>为自己本机电脑的 <code>Git</code> 安装目录，即第一行代码为声明 <code>sh.exe</code> 的目录<br>  2.1.2 执行 <code>gradle installGitHooks</code></p><p>Mac OS&#x2F;Linux:  <code>./gradlew installGitHooks</code><br></p><p>或者在 <code>Android Studio</code> 中右边面板上找到 <code>root-Tasks-other-installGitHooks</code> 并双击执行</p><p>2.2 赋予执行脚本可执行权限 <code>chmod +x .git/hooks/pre-commit</code><br></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>使用<strong>git提交增量检查</strong>时需要配置ANDROID_HOME环境变量(需要以ANDROID_HOME命名并加入到path中，因为在Lint框架中执行Lint检查时需要获取Android环境变量)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows环境：在电脑-&gt;属性-&gt;环境变量中编辑即可</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mac OS/Linux环境：编辑 ~/.bashrc即可</span><br><span class="line">vi ~./bashrc</span><br><span class="line"><span class="built_in">export</span> ANDROID_HOME=<span class="variable">$HOME</span>/&#123;Android SDK 路径&#125;</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$ANDROID_HOME</span>/tools</span><br></pre></td></tr></table></figure><h3 id="实时提示"><a href="#实时提示" class="headerlink" title="实时提示"></a>实时提示</h3><blockquote><p>在 Android Studio 中进行实时提示</p></blockquote><h4 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h4><p><strong>方法一</strong></p><ul><li>将自定义 Lint 规则的 aar 包放入项目中，例如 <code>$&#123;root&#125;/libs</code> 目录①</li><li>在项目的根目录下的 <code>build.gradle</code> 文件内的 <code>repositories</code> block 中为所有的 module 添加 aar 的路径(主要是便于管理，不需要所有 module 的 build.gradle 文件都写一遍 aar 路径)</li></ul><p>eg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allprojects&#123;</span><br><span class="line">    repositories&#123;</span><br><span class="line">        flatDir&#123;</span><br><span class="line">            dirs &quot;../$&#123;root&#125;/libs&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在每个 module 中的 <code>dependencies</code> 中加入 <code>implementation (name:&#39;AAR的名字&#39;, ext:&#39;aar&#39;)</code> 即可</li></ul><p><strong>方法二</strong></p><p>将 <code>lintRules</code> 发布到仓库中，再通过远程依赖在每个 module 中进行依赖<br>即 <code>implementation &#39;me.ppting.plugin:lintPreview:1.0.0.beta&#39;</code></p><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><blockquote><p>目前只自定义了几个规则，例如</p></blockquote><ul><li>类名和方法名的命名需要符合驼峰命名法</li></ul><p>效果如下 <img src="https://raw.githubusercontent.com/PPTing/AwesomeLint/master/images/Xnip2019-09-16_16-00-10.png" alt="Lint 检测后的展示效果"></p><p>在 IDE 中会根据错误级别进行相应的提示，在 <code>Darcula</code> 主题下默认会以黄色的前景色进行提示，将鼠标移至该代码块则会有浮窗提示问题</p><h4 id="去除提示-SuppressLint"><a href="#去除提示-SuppressLint" class="headerlink" title="去除提示(SuppressLint)"></a>去除提示(SuppressLint)</h4><p>假如某个 Lint 规则提示代码有误，但实际上是因为自定义规则的检测有误导致误报，或者代码并没有错误，可以使用 <code>@SuppressLint</code> 对该代码段进行注解，注解的参数填写 Lint 规则的 id，一般会在浮窗中展示该规则 id。</p><p>如果实在不知道该规则 id ，可以使用 <code>@SuppressLint(&quot;All&quot;)</code> 忽略所有的规则，但这样就会导致该方法内新增的代码也无法进行 Lint 规则检测，请<em><strong>谨慎使用</strong></em></p><p>这样该方法就会忽略该规则的检测</p><h4 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h4><h4 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h4><p>在 lintRules module 中编写规则</p><ul><li>创建一个<code>继承 Detector 的类</code></li><li>类中创建一个 ISSUE 表示该类用来检测的问题</li><li>在 Register 类中对该 issue 进行注册</li></ul><blockquote><p>具体参考现有的代码</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>执行 lintAAR<code>中的</code>copyAAR&#96; 的 task 即可编译出 aar 文件并复制到 app module 中，</li><li>Sync Project With Gradle Files (点击 Gradle 的同步按钮)</li></ul><p>即可在 app module 中测试各个规则是否生效</p><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>测试完毕，将 aar 文件复制到其他应用到它的地方即可，并同步即可生效</p><blockquote><p>PS. 如果不生效，尝试重启 Android Studio </p></blockquote><h3 id="COMMIT-HOOKS"><a href="#COMMIT-HOOKS" class="headerlink" title="COMMIT HOOKS"></a>COMMIT HOOKS</h3><blockquote><p>为了强制进行一些编码规范等的执行，会在 git hooks 在进行 commit 后做检查，如果检测不通过，则会触发 git reset 进行回滚此次提交，并将错误提示日志打印到 <code>lint-check-result.log</code> 文件中</p></blockquote><h4 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h4><p>i. 在项目中应用 gradle plugin，在每次 git commit 后，在 <code>.git/hooks</code> 中的 <code>pre-commit</code> hook 会自动执行，会到项目根目录下执行 <code>./gradlew lintCheck -PisLintCheck</code></p><p>ii. lintCheck 会通过 <code>git diff</code> 获取暂存区中的代码修改，并记录其行数和文件名</p><p>iii. 将所有的改动的文件进行 lint 操作，并记录其 issue，如果某个 issue 对应的代码行正好是改动的代码行，则将记录数(记为 K)加一</p><p>iiii. 当结束 lintCheck 后，如果 K &gt; 0 ，则抛出异常，使本次提交失败</p><p>PS. 如果该 <code>Issue</code> 是 <code>Warning</code> 级别的，Android Studio 不会进行提示，如果该 <code>Issue</code> 是 <code>Error</code> 级别的，Android Studio 会有错误提示弹窗</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ol><li><p>在项目根目录下的 <code>build.gradle</code> 中应用插件 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:&quot;me.ppting.plugin.lint&quot;</span><br></pre></td></tr></table></figure></li><li><p>设置 lintCheck 配置</p><p> 在 根目录下的 <code>build.gradle</code> 中添加 lintCheck 配置</p><p> eg.</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lintConfig &#123;</span><br><span class="line">    //配置Lint检查文件的类型</span><br><span class="line">    lintCheckFileType = &quot;.java,.xml,.kt&quot;</span><br><span class="line">    //是否将检查文件的所有扫描结果都输出</span><br><span class="line">    lintReportAll = true</span><br><span class="line">    //是否进行 lint 检查，默认为 true</span><br><span class="line">    isOpenLint = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复制 <code>pre-commit</code> 脚本到本地的 <code>.git/hooks</code> 目录下</p><p> 在根目录下执行执行  </p><blockquote><p>Mac&#x2F;Linux: <code>./gradlew installGitHooks</code><br><br>Windows: <code>gradle installGitHooks</code></p></blockquote><p> 或者在 <code>Android Studio</code> 中右边面板上找到 <code>root-Tasks-other-installGitHooks</code> 并双击执行</p></li></ol><p>PS. 如果无法执行 <code>pre-commit</code> 脚本，可能是权限问题，给该脚本加上可执行权限</p><p><code>chmod +x .git/hooks/pre-commit</code></p><p>PSS. <strong>强制关闭 hook 操作</strong></p><ul><li>如果要强制关闭在 commit 之后的 hook 操作，可以使用 <code>deleteGitHooks</code> task 将 <code>.git/hooks/pre-commit</code> 文件删除</li><li>或者在 commit 时候加上 <code> --no-verify</code> 参数</li></ul><h3 id="遇到的一些坑和解决方案"><a href="#遇到的一些坑和解决方案" class="headerlink" title="遇到的一些坑和解决方案"></a>遇到的一些坑和解决方案</h3><p><em><strong>坑 1：</strong></em> 由于 lint 的 api 依赖于 kotlin-compiler ，而这会造成 Android Studio 的 Kotlin-Plugin 冲突，而导致无法编译</p><p><strong>错误提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments.setAllowNoSourceFiles(Z)V</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.</span><br><span class="line"></span><br><span class="line">* Get more help at https://help.gradle.org</span><br><span class="line"></span><br><span class="line">Deprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.</span><br><span class="line">Use &#x27;--warning-mode all&#x27; to show the individual deprecation warnings.</span><br><span class="line">See https://docs.gradle.org/5.4.1/userguide/command_line_interface.html#sec:command_line_warnings</span><br><span class="line"></span><br><span class="line">BUILD FAILED in 20s</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>在 buildSrc&#x2F;build.gradle 文件中控制 lint api 的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    all*.exclude group: &#x27;com.android.tools.external.com-intellij&#x27;,module:&quot;kotlin-compiler&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以编译，但会导致 lintCheck task 失败<br>于是我们使用一个变量 <code>isLintCheck</code> 来控制 lint api 是否要 exclude 掉 kotlin-compiler 的依赖</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* lintCheck 需要有 kotlin-compiler</span><br><span class="line">* run 不需要 kotlin-compiler</span><br><span class="line">*/</span><br><span class="line">configurations &#123;</span><br><span class="line">    boolean isLintCheck = project.hasProperty(&quot;isLintCheck&quot;)</span><br><span class="line">    if (!isLintCheck) &#123;</span><br><span class="line">        all*.exclude group: &#x27;com.android.tools.external.com-intellij&#x27;,module:&quot;kotlin-compiler&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以要求我们在执行 lintCheck 任务时加上参数 -PisLintCheck </p><p><em><strong>坑 2：</strong></em> 将 plugin 发布到仓库中作为插件使用</p><blockquote><p>当尝试将 plugin 发布到仓库中，并在项目中使用 classpath 进行依赖该插件，会导致无法编译</p></blockquote><p><strong>错误提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jetbrains.kotlin.resolve.diagnostics.DiagnosticSuppressor$Companion.getEP_NAME()Lcom/intellij/openapi/extensions/ExtensionPointName;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>只能将插件项目通过 buildSrc module 的方式引入到需要使用 lint 的项目中</p><p><em><strong>坑 3：</strong></em> walle 报错</p><blockquote><p>由于升级了 Gradle 的版本，项目中也使用了美团的 walle 作为多渠道打包的方案，在编译阶段会报错</p></blockquote><p><strong>错误提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API &#x27;variantOutput.getPackageApplication()&#x27; is obsolete and has been replaced with &#x27;variant.getPackageApplicationProvider()&#x27;. It will be removed at the end of 2019.</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>walle 已经修复了该<a href="https://github.com/Meituan-Dianping/walle/pull/285">问题</a>，详情请查阅 <a href="https://github.com/Meituan-Dianping/walle/commit/c3869bbce43254c2fd44d67edf81fc9ea925b037">fixAPI ‘variant.getAssemble()’ is obsolete and has been replaced with…</a><br><br>但 walle 并未将修复的版本发布(摊手)，可以自行下载<a href="https://github.com/Meituan-Dianping/walle">源码</a>编译到自己的仓库中引用</p><h2 id="如何生产进行实时-lintRules-的-aar"><a href="#如何生产进行实时-lintRules-的-aar" class="headerlink" title="如何生产进行实时 lintRules 的 aar"></a>如何生产进行实时 lintRules 的 aar</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发布 aar，直接运行 `lintRules-uploadArchives` 的 task 即可发布到仓库中</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>① ${root} 即项目的根地址文件夹名，请按需修改</p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>本文是在巨人的肩膀上进行探索并实践的，感谢 <br><br>①<a href="https://github.com/lsc1993">lsc1993</a> 的<a href="https://github.com/lsc1993/AwesomeLint">AwesomeLint</a> <br><br>②<a href="https://juejin.im/user/5995c9f2f265da248c3934a5">GitCode8</a> 的 <a href="https://juejin.im/post/5d307615f265da1b6b1d0dd9">代码洁癖症的我，学习Lint学到心态爆炸</a><br><br>本实践也是在该基础上进行改进并应用到项目中的，代码也是 fork 自该项目。在其基础上进行添加了对 Kotlin 的支持，并在应用到项目中时踩了很多坑也将其填完了。借此也将填坑经验分享出来，以供借鉴<br></p><p><strong>诚惶诚恐，若有错误，不吝赐教</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用-Lint-进行代码检查&quot;&gt;&lt;a href=&quot;#使用-Lint-进行代码检查&quot; class=&quot;headerlink&quot; title=&quot;使用 Lint 进行代码检查&quot;&gt;&lt;/a&gt;使用 Lint 进行代码检查&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;为了进一步规范协同合作中的代码规范，避免写低级 Bug 和对代码进行规约，在调研了多种方案后，决定使用该种方案对代码进行自动化检查和规约&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="Lint" scheme="https://ppting.me/tags/Lint/"/>
    
    <category term="效率" scheme="https://ppting.me/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>记录一次 Android 内嵌 WebView 白屏无法加载内容的事故</title>
    <link href="https://ppting.me/2019/08/09/record-an-white-screen-accident-for-webview-safe-browse/"/>
    <id>https://ppting.me/2019/08/09/record-an-white-screen-accident-for-webview-safe-browse/</id>
    <published>2019-08-09T01:32:44.000Z</published>
    <updated>2022-02-12T08:20:44.000Z</updated>
    
    <content type="html"><![CDATA[<br><blockquote><p>昨天下午，产品经理突然发来了一张截图，内容是我们的 APP 因为违反了 Google Play 的某些规定被下架了。</p></blockquote><p>这当然是马上排查原因并 fix 然后打包给测试同事重新测试一遍然后再提审啦。<br>但是问题来了，测试的同事发现 App 内的所有 HTML5 的页面都无法打开了，而主包(国内版本)却是正常的。</p><p>这怎么可能会发生呢，fix 被下架的问题并没有修改到 WebView 业务相关的代码，这就百思不得其解了。甚至一度以为是前端同事刚上线的代码影响到了海外版本的业务想甩锅。</p><p>拿起自己的手机装上 Google Play 版本的包打开对应的页面一看，基本上是第一次能正常加载，退出后再次点击进入 WebView 页面就无法加载了。</p><span id="more"></span><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ol><li><p>先抓包看 HTTP Request 是否有返回数据，由于是 HTTPS 的页面，尝试使用 Charles 的 Enable SSL Proxy 解开 SSL 加密，无法解开(<strong>这里为自己挖了个坑</strong>)，查看其他 HTTP 的页面也发现 HTML5 的页面 URL 返回的 Response 都是正常的。</p></li><li><p>尝试对比主包和海外版的 HTML5 页面的 HTTP Request 的区别，发现只有 User Agent 有所区别，试着将海外版的 User Agent 修改成和主包一样，结果相同，还是无法加载</p></li><li><p>只好尝试着调试 WebView<br>首先打开 WebView 的 debug 模式</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebContentsDebuggingEnabled(true);</span><br></pre></td></tr></table></figure><p>将手机连接到电脑，打开 Chrome，输入 <code>chrome://inspect</code> 通过 Chrome DevTools 调试手机上的 WebView 页面<br><img src="https://i.loli.net/2020/04/12/aGMBfkn7rITUi1W.jpg" alt="Chrome DevTools"><br>进入 <code>Devices Tab</code>，看到自己的手机设备和当前打开的 HTML5 页面，点击 <code>inspect</code> 打开 DevTools ，此时可以看到有一个提示’安全错误’，并且在刷新重新加载的时候发现页面偶尔会一闪而过一个红色的页面。</p><p>一开始不以为然，以为是自己为了解开 HTTPS 而导致的就没放在心上，这时前端的同事让我给他装个可以调试的包给他排查一下问题，我把 apk 文件给到他后，在他的手机上打开 HTML5 的页面是都正常可以访问的。</p><p>这就更让人百思不得其解了。<br><img src="https://i.loli.net/2020/04/12/yOxHaYCfMDZGLPr.jpg" alt="红屏页面"></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>后来经测试的另一个同事提醒，说会不会是因为什么原因导致访问会提示不安全了</p><p>于是乎上网 Google 了一下 “您要访问的网站包含有害应用” 这个关键字无果，紧接着在其前面加上 WebView，搜出来了一篇 CSDN 上的 Blog，终于找到了问题所在。</p><blockquote><p>自 2018 年 4 月起，随着 WebView 66 发布，Google Play 保护机制，将在 WebView 中默认开始此安全浏览策略。<br>而 Android 开发者在使用 WebView 时，无需再进行任何更改，即可享受此项保护服务。自 Android 8.0 开始，WebView 中即已经集成安全浏览功能，并且与 Android 版的 Chrome 采用相同的底层技术。<br>一旦触发 WebView 的安全机制，就会出现类似这样的“红屏”警告。</p><p>作者：承香墨影<br>链接：<a href="https://juejin.im/post/5c8899c56fb9a049b41d5432">https://juejin.im/post/5c8899c56fb9a049b41d5432</a></p><p>来源：掘金</p></blockquote><p>原来在 Android O 以后，WebView 的安全浏览策略(Google Safe Browsing) 会在 WebView 中默认开启，Google 自己会维护一份清单判断哪些网站是”有害的“提醒用户，并通过 Google Play Service 同步到用户设备中，而我们的域名刚好被 Google 认为是”有害的“，导致了我们的 HTML5 业务的页面无法打开。</p><p>而这也正好解决了我的疑问：为什么前端同事的手机可以正常打开，而我和测试同事的手机却不行，因为我和测试同事的手机为了测试海外版的支付功能都安装了 Google Play Service 而前端同事的手机没有安装 Google Play Service 。所以没有同步”有害网站“</p><p>知道了原因后解决起来就很容易了</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h4 id="申诉"><a href="#申诉" class="headerlink" title="申诉"></a>申诉</h4><p><a href="https://support.google.com/chrome/answer/99020">管理有关不安全网站的警告</a></p><p><a href="https://developers.google.com/web/fundamentals/security/hacked/request_review">请求审核的地址</a></p><h4 id="代码中强制设置不使用『安全浏览策略』"><a href="#代码中强制设置不使用『安全浏览策略』" class="headerlink" title="代码中强制设置不使用『安全浏览策略』"></a>代码中强制设置不使用『安全浏览策略』</h4><ul><li><p>Android O 以上</p><p>  <code>webviewSetting.setSafeBrowsingEnabled(false)</code></p><p>  但这个方法只能用于 API 26 以上，如果在 API 26 一下，则需要在 AndroidManifest 中进行声明</p></li><li><p>Android O 以下</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.webkit.WebView.EnableSafeBrowsing&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如果觉得这样一刀切的方案有点简单粗暴，WebView-还提供了一个设置白名单的方法，可以将业务上用到的域名列入应用的白名单"><a href="#如果觉得这样一刀切的方案有点简单粗暴，WebView-还提供了一个设置白名单的方法，可以将业务上用到的域名列入应用的白名单" class="headerlink" title="如果觉得这样一刀切的方案有点简单粗暴，WebView 还提供了一个设置白名单的方法，可以将业务上用到的域名列入应用的白名单"></a>如果觉得这样一刀切的方案有点简单粗暴，WebView 还提供了一个设置白名单的方法，可以将业务上用到的域名列入应用的白名单</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebView.setSafeBrowsingWhitelist(List&lt;String&gt; hosts, ValueCallback&lt;Boolean&gt; callback)</span><br></pre></td></tr></table></figure><h4 id="甚至还可以在-WebView-中设置是否被安全机制拦截的监听回调，在接收到被安全拦截后，进行处理"><a href="#甚至还可以在-WebView-中设置是否被安全机制拦截的监听回调，在接收到被安全拦截后，进行处理" class="headerlink" title="甚至还可以在 WebView 中设置是否被安全机制拦截的监听回调，在接收到被安全拦截后，进行处理"></a>甚至还可以在 WebView 中设置是否被安全机制拦截的监听回调，在接收到被安全拦截后，进行处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWebViewClient</span> : <span class="title">WebViewClient</span>() </span>&#123;</span><br><span class="line">    <span class="comment">// Automatically go &quot;back to safety&quot; when attempting to load a website that</span></span><br><span class="line">    <span class="comment">// Google has identified as a known threat. An instance of WebView calls</span></span><br><span class="line">    <span class="comment">// this method only after Safe Browsing is initialized, so there&#x27;s no</span></span><br><span class="line">    <span class="comment">// conditional logic needed here.</span></span><br><span class="line">    <span class="function">override fun <span class="title">onSafeBrowsingHit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            view: WebView,</span></span></span><br><span class="line"><span class="params"><span class="function">            request: WebResourceRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">            threatType: Int,</span></span></span><br><span class="line"><span class="params"><span class="function">            callback: SafeBrowsingResponse</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The &quot;true&quot; argument indicates that your app reports incidents like</span></span><br><span class="line">        <span class="comment">// this one to Safe Browsing.</span></span><br><span class="line">        <span class="comment">//在这里处理被安全浏览机制拦截</span></span><br><span class="line">        callback.backToSafety(<span class="keyword">true</span>)</span><br><span class="line">        Toast.makeText(view.context, <span class="string">&quot;Unsafe web page blocked.&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后感谢测试同事，又让我涨知识了</p><p>参考链接：</p><p><a href="https://blog.csdn.net/u010207898/article/details/89238551">Android webview（安全策略） 出现 您要访问的网站包含有害应用</a>(PS. 这篇文章最后的 AndroidManifest 中的写法是错误的)</p><p><a href="https://juejin.im/post/5c8899c56fb9a049b41d5432">WebView，我已经长大了，知道自己区分是否安全了！</a></p><p>最重要的！！！还是 Google 官方文档啊</p><p><a href="https://developer.android.com/guide/webapps/managing-webview">管理 WebView 对象</a></p><p><a href="https://developer.android.com/about/versions/oreo/android-8.1">Android 8.1 Features and APIs</a></p>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;昨天下午，产品经理突然发来了一张截图，内容是我们的 APP 因为违反了 Google Play 的某些规定被下架了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这当然是马上排查原因并 fix 然后打包给测试同事重新测试一遍然后再提审啦。&lt;br&gt;但是问题来了，测试的同事发现 App 内的所有 HTML5 的页面都无法打开了，而主包(国内版本)却是正常的。&lt;/p&gt;
&lt;p&gt;这怎么可能会发生呢，fix 被下架的问题并没有修改到 WebView 业务相关的代码，这就百思不得其解了。甚至一度以为是前端同事刚上线的代码影响到了海外版本的业务想甩锅。&lt;/p&gt;
&lt;p&gt;拿起自己的手机装上 Google Play 版本的包打开对应的页面一看，基本上是第一次能正常加载，退出后再次点击进入 WebView 页面就无法加载了。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="WebView" scheme="https://ppting.me/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>Charles 使用</title>
    <link href="https://ppting.me/2019/03/13/how_to_used_charles/"/>
    <id>https://ppting.me/2019/03/13/how_to_used_charles/</id>
    <published>2019-03-13T03:46:16.000Z</published>
    <updated>2022-02-12T08:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍 Charles 的使用</p><h2 id="Rewrite-功能"><a href="#Rewrite-功能" class="headerlink" title="Rewrite 功能"></a>Rewrite 功能</h2><blockquote><p>几乎可以用来修改 HTTP 请求中的所有数据<br>例如 Request 中的 path、query param 等等</p></blockquote><p>这样的好处是只需要篡改请求中的数据，而不需要修改代码，避免重新编译，可以节省时间，也不会污染代码，造成发版时忘记修改回来的问题。</p><span id="more"></span><p>具体操作如下，我们以 <strong>将请求中的 versionCode&#x3D;46 修改为 1111111为例</strong></p><ul><li>点击 Tools - Rewrite</li></ul><p><img src="https://i.loli.net/2020/05/02/PAwzqcU2b6O1hGI.jpg" alt="7bdcf253ly1g4rmbcpfs2j20uq0qstpi.jpg"></p><ul><li><p>新增规则<br> 在面板上分成了三个区域，如下<br> 第一个区域为 <strong>配置区</strong> ，用来管理各种配置<br> 第二个区域为 <strong>匹配区</strong> 用来匹配 Location<br> 第三个区域为 <strong>重写规则区</strong> 在这里新增各种重写规则<br> <img src="https://i.loli.net/2020/05/02/qkCX3UbHzj8o6Ny.jpg"></p></li><li><p>编辑 Location<br><img src="https://i.loli.net/2020/05/02/NYft7WjZ4L3ks6S.jpg" alt="7bdcf253ly1g4rm7k5dmgj20uo0lewhp.jpg"></p><p>  这里一共有五个地方，分别是<br>  Protocol 填写协议<br>  Host 填写域名<br>  Prot 填写端口<br>  Path 填写路径<br>  Query 填写查询的值</p></li></ul><p>如果不填写将会匹配所有的值，这里可以填写 <strong>*</strong> 和 <strong>?</strong> 通配符</p><h3 id="修改-Request"><a href="#修改-Request" class="headerlink" title="修改 Request"></a>修改 Request</h3><ul><li><p>填写 Rewrite 规则<br><img src="https://i.loli.net/2020/05/02/cd4egkLMaFTh2ZJ.jpg" alt="7bdcf253ly1g4rmhp99qzj211e0z2dok.jpg"></p><ol><li><p>首先选择 Type(类型) Modify Query Param </p><blockquote><p>即修改 Query 参数</p></blockquote></li><li><p>在 Match 中填写需要修改的参数的 name 以及对应的 value</p></li></ol><p>   <em><strong>在我们的例子中，就是 versionCode 及 46</strong></em><br>  3. 在 Replace 中填写相对应要修改的参数名和值<br>  <em><strong>在我们的这个例子中，我们只需要将 versionCode 的值改成 1111111</strong></em>，所以只需要将 Replace 中的 Value 填写为 1111111</p></li></ul><p>这样就可以将 HTTP 请求中的数据进行修改了，不需要修改代码和重新编译。节省了大量的时间</p><h3 id="修改-Response"><a href="#修改-Response" class="headerlink" title="修改 Response"></a>修改 Response</h3><p>同理，我们也可以修改 HTTP 请求中的 Response 中的数据，修改成我们调试所需要的信息</p><p>只需要在 Rewrite Rule 中的 Type 中选择所需要修改的类型，例如 <code>Response Status</code>、<code>Modify Header</code>、<code>Body</code> 等</p><p><img src="https://i.loli.net/2020/05/02/buNi497D5W2qzRm.jpg" alt="7bdcf253ly1g4rm8gorolj21080y67aw.jpg"></p><p>并在 <code>Where</code> 中选择是修改 <code>Request</code> 还是 <code>Response</code> ，下面的规则同理。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Location Match 包含了可用于匹配请求URL的协议，主机，端口和路径字段。<br>任何字段都可以留空，这种情况下会匹配上任何值。</p><ul><li>通配符(Wildcards)<br>通配符支持使用 <strong>*</strong> 、**?** 和 <strong>[…]</strong></li></ul><p><strong>*</strong> 匹配0个或者多个字符，**?<strong>匹配一个字符，字符范围</strong>[…]** 匹配范围内的一个字符，例如 [a-z] 或者 [aeiou]</p><ul><li>路径(Paths)<br>要匹配子路径，必须使用<code>/*</code>结尾<br>注意：在之前的 Charles 版本中这是隐含的，但现在是必须的</li><li>查询值(Query)<br>查询字段和查询字符串内容相匹配，并不匹配以 <code>?</code> 开头的字符，要注意到<code>？</code>是一个通配符<br>查询字段和其他字段一样可以包含通配符，因此你可以像这样，在 Query 中任何地方使用 <code>*page=1*</code> 去匹配 <code>page=1</code></li><li>常见用途<br>要将每个请求和给定的 host 匹配，填入 host 并将其他字段留空<br> 要将每个请求和给定的 host 以及路径匹配，填入 host 并把路径已 <code>/</code> 结尾，并把其他字段留空<br> 要将每个文件和给定的 host 上的后缀(suffix)相匹配，则填入 host 和 <code>/*.suffix</code>，并将其他字段留空</li></ul><table><thead><tr><th>Host</th><th>Path</th><th>Result</th></tr></thead><tbody><tr><td>charlesproxy.com</td><td></td><td>匹配所有到 charlesproxy.com 的请求</td></tr><tr><td>*.charlesproxy.com</td><td></td><td>匹配所有 host 以 .charlesproxy.com 结尾的请求</td></tr><tr><td>charlesproxy.com</td><td>&#x2F;charles&#x2F;</td><td>只会匹配所有到 charlesproxy.com&#x2F;charles&#x2F; 的请求</td></tr><tr><td>charlesproxy.com</td><td>&#x2F;charles&#x2F;*</td><td>匹配所有到 charlesproxy.com&#x2F;charles&#x2F; 的请求，包括文件和子路径</td></tr><tr><td>charlesproxy.com</td><td>&#x2F;charles</td><td>只会匹配所有到 charlesproxy.com&#x2F;charles 的请求</td></tr><tr><td>charlesproxy.com</td><td>&#x2F;index.html</td><td>只会匹配所有到 charlesproxy.com&#x2F;charles.html 的请求</td></tr><tr><td>charlesproxy.com</td><td>&#x2F;*.html</td><td>匹配所有到 charlesproxy.com 并且以 .html 结尾的所有请求</td></tr><tr><td></td><td>&#x2F;charles&#x2F;*.html</td><td>匹配任何 host 的所有在路径(包括子路径) &#x2F;charles&#x2F; 中以 .html 结尾的所有请求</td></tr></tbody></table><p>可以将协议和端口匹配添加到上面以进一步缩小位置匹配。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简单介绍 Charles 的使用&lt;/p&gt;
&lt;h2 id=&quot;Rewrite-功能&quot;&gt;&lt;a href=&quot;#Rewrite-功能&quot; class=&quot;headerlink&quot; title=&quot;Rewrite 功能&quot;&gt;&lt;/a&gt;Rewrite 功能&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;几乎可以用来修改 HTTP 请求中的所有数据&lt;br&gt;例如 Request 中的 path、query param 等等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的好处是只需要篡改请求中的数据，而不需要修改代码，避免重新编译，可以节省时间，也不会污染代码，造成发版时忘记修改回来的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="https://ppting.me/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Charles" scheme="https://ppting.me/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS 是如何保证安全的</title>
    <link href="https://ppting.me/2019/01/01/communication-with-https/"/>
    <id>https://ppting.me/2019/01/01/communication-with-https/</id>
    <published>2019-01-01T09:04:50.000Z</published>
    <updated>2022-02-12T08:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，HTTP 协议是明文传输的，在网络世界里用 HTTP 协议发送报文相当于裸奔，于是就有了 HTTPS<br>这个 S 是什么呢，是如何保证我们发送的报文就不被窃取和篡改了呢，让我们慢慢道来</p><span id="more"></span><p>其实这个 S 指的就是 SSL&#x2F;TLS<br>我们知道 HTTP 在网络协议中属于应用层，在发送报文时会将报文交给 TCP 进行传输，而 TCP 层面则是明文的，于是 HTTPS 在将报文发给 TCP 之前，通过 TLS 将报文进行加密后再通过 TCP 进行传输</p><p>那么 HTTPS 是如何进行加密的呢</p><p>说到这里，我们需要先来了解一下加密算法 </p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>所谓对称加密，就是用来加密和解密的密钥都是同一个， 当我们使用对称加密的时候，就是用密钥将元数据通过加密算法，转变成密文，当另一方需要将密文转成原文的时候，需要用同一个密钥和相对应的解密算法，将密文给还原成原文。<br>但对称加密的缺陷在于，如何保证<strong>密钥</strong>的安全性，如何保证只有通信的双方才持有该密钥而不被其他人窃取，而<em>非对称加密</em>就是来解决这个问题的</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密，是因为数学家们研究出了一种算法，这种算法两个不同的密钥，通过密钥 A 对原文进行加密后，只能通过密钥 B 进行解密。和对称加密不同的是，非对称加密只有一个算法，不需要『加密算法』和『解密算法』，也就是说同一个算法，经过密钥 A 加密过的密文只能由密钥 B 解密。</p><p>但所谓的『原文』和『密文』只是相对的，我们也可以将所谓的『原文』当做被加密过的数据，而把『密文』当做加密前的数据，所以从下图看，密钥 A 和密钥 B 其实也是可以相互交换的，密钥 B 可以用来当做加密用的密钥，而让密钥 A 当做解密用的密钥。<br><img src="https://i.loli.net/2020/07/30/HlKVyet7nGdLAi5.jpg" alt="0071ouepgy1fyr6z2wl0dj30w80f0q55.jpg"><br>但一般来说不会这么做，这是因为非对称加密的算法是有很多种的，而密钥 A 和密钥 B 是成对存在的，一般来说是不能相互推导的，即我不能通过密钥 A 计算出密钥 B，也不能通过密钥 B 计算出密钥 A，但也不是绝对的，其实也是可以推导出来的，只不过对于如今的计算运力来说不足以在短时间内推导出来，可能需要上百年上千年，所以我们姑且认为是无法推导出来的。<br>但也有一些非对称加密算法是例外的，有些非对称加密的算法是可以通过密钥 A 计算出来密钥 B 的。<br>所以这个时候，我们就不能用密钥 B 进行加密而把密钥 A 公开了。因为这样的话，就相当于所有人都知道了密钥 A 和 密钥 B 是什么，就相当于没有加密了。</p><p>而密钥 A ，我们把它称为私钥，密钥 B 称为公钥。<br>所谓私钥，就是要对信息进行加密的持有者所持有的密钥，这个密钥只能自己持有，不能公开，而公钥是可以在任何地方公开的，只有持有私钥的一方才可以将被公钥加密过的信息解密得到原文。</p><p>也就是说，假如我要发送一个消息给对方，我需要先得到对方的公钥，然后用对方的公钥对信息进行加密后再发送给对方，而只有对方(公钥对应的私钥拥有者)才能将信息还原成原文</p><p>在消息的发送前，发送方需要获取到接收方的公钥，而在这个过程中，发送方是如何确定这个公钥就真的是接收方的公钥而不是被篡改过的呢。<br>且听我娓娓道来。<br>让我们先来看一个知识点(敲黑板)</p><h3 id="非对称加密的应用"><a href="#非对称加密的应用" class="headerlink" title="非对称加密的应用"></a>非对称加密的应用</h3><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>所谓数字签名，就是证明这个东西是我发出的<br>在网络世界里，所有的数据包都有可能被截获篡改，所以当我们收到某个消息时，如何确定这条消息就是我认为的那个人发出的呢，这就需要用到『非对称加密』的一个应用–『数字签名』了。<br><img src="https://i.loli.net/2020/07/30/NaQ6ygMsRo1LGlD.jpg" alt="0071ouepgy1fyr6w822t9j31iw0petdo.jpg"><br>通过上图可见，当接收方对比 <em><strong>摘要</strong></em> 和 <em><strong>摘要’</strong></em> 相同时，就可以认为这条消息是没有被篡改过的，是来自于这个公钥所对应的私钥的拥有者发出的。</p><p>但在我们的消息发送的过程中还有个问题，接收方怎么就知道这个公钥就是我认为的消息的发送者的呢。万一中间有人把所有的信息(公钥修改了，同时用新的公钥计算出密文和 hash)都修改了，那接收方通过这种方式验证出来的结果都是正确的，那怎么办。</p><p>于是问题的痛点就落在了我们需要保证公钥的正确性上</p><p>这就需要证书了</p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>为了解决无法证明公钥的正确性的问题，有了数字证书。<br>数字证书是由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p><p>要得到一份数字证书，需要由服务器端的(或者说是信息的发送方)到数字证书认证机构去申请，而 CA 确认该身份后通过申请，则会给该申请者一个包含经过 CA 签名的公钥的数字证书。</p><p>数字证书中包括了「签名」+「csr 文件」</p><p>其中，csr 文件包括信息发送方的「公钥」、「申请者信息」、「域名」等<br>CA 机构通过对这些信息通过摘要算法计算出摘要(记为摘要 A)，并用私钥进行加密，得到「签名 A」，并把「签名 A」 和 csr 文件内容打包成证书</p><p>在网络传输中，接收者就会拿到这个证书，进行验证</p><p>首先接收者的系统&#x2F;浏览器中内置了 CA 机构的公钥，拿到公钥后对接收到的证书中的「签名 A」进行解密，得到「摘要 A」，再使用相同的摘要算法对 csr 文件进行计算，得到「摘要 B」，比对「摘要 A」和「摘要 B」，如果无法计算出「摘要 A」或者「摘要 A」和「摘要 B」不相同，则认为这个证书不可信，否则则认为这个证书可信，则可以获取到 csr 文件中信息发送者的公钥</p><p>至此就完成了信息发送者的公钥的安全传输过程(防止被篡改和替换)</p><p><img src="https://i.loli.net/2021/11/11/YINwnzfej45QX2q.jpg" alt="数字证书.jpg"></p><blockquote><p>图片来源于 <a href="https://network.51cto.com/art/202010/628890.htm">数字证书、签名到底是什么？这篇文章讲得太好了</a></p></blockquote><h2 id="TLS-四次握手"><a href="#TLS-四次握手" class="headerlink" title="TLS 四次握手"></a>TLS 四次握手</h2><h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><blockquote><p>客户端向服务端发送</p></blockquote><ul><li>TLS 支持的版本</li><li>支持的加密算法以及版本</li><li>支持的压缩算法</li><li>Client Random A</li></ul><h3 id="Server-Hello、Certificate、Server-Hello-Done"><a href="#Server-Hello、Certificate、Server-Hello-Done" class="headerlink" title="Server Hello、Certificate、Server Hello Done"></a>Server Hello、Certificate、Server Hello Done</h3><blockquote><p>服务器向客户端进行响应</p></blockquote><ul><li>选择的 TLS 版本</li><li>选择的加密算法</li><li>Client Random B</li></ul><h4 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h4><ul><li>发送服务器的证书<br>Client 在收到 Server 发送过来的证书后会对证书进行校验</li></ul><h4 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h4><h3 id="Client-Key-Exchange-Change-Clpher-Spec-Finish"><a href="#Client-Key-Exchange-Change-Clpher-Spec-Finish" class="headerlink" title="Client Key Exchange,Change Clpher Spec,Finish"></a>Client Key Exchange,Change Clpher Spec,Finish</h3><h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><ul><li>证书校验通过后，Client 会使用 Random A 和 Random B  生成一个 pre-master 的值，<br>通过 Server 的 Public Key 对 pre-master 进行加密后发送给 Server</li></ul><h4 id="Change-Clpher-Spec"><a href="#Change-Clpher-Spec" class="headerlink" title="Change Clpher Spec:"></a>Change Clpher Spec:</h4><ul><li>并告知服务端后续使用算法计算出来的 key 对通信内容进行加密<blockquote><p>此时 Client 已经拥有了 Random A 、 Random B 和 pre-master，用这三个值可以计算出 session-key，用于作为对称加密的密钥</p></blockquote></li></ul><h4 id="Finish"><a href="#Finish" class="headerlink" title="Finish:"></a>Finish:</h4><ul><li>对上述所有握手过程中的数据使用商量好的 Hash 算法计算 HashCode，并使用 session-key 进行加密</li></ul><h3 id="New-Session-Ticket-Change-Cliper-Spec-Finish"><a href="#New-Session-Ticket-Change-Cliper-Spec-Finish" class="headerlink" title="New Session Ticket,Change Cliper Spec,Finish"></a>New Session Ticket,Change Cliper Spec,Finish</h3><p>Server 使用自己的私钥对上一步中发来加密过的 pre-master 进行解密，得到明文的 pre-master<br>此时 Server 也拥有了 Random A 、 Random B 和 pre-master ，使用商量好的算法计算出 session-key<br>并使用 session-key 对上一步中 Client 中发来的数据和 HashCode 进行校验，<br>以用来证明 Client 计算的 session-key 是正确的</p><h4 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title="New Session Ticket"></a>New Session Ticket</h4><p>Server 发送给 Client 的 Session，用于下一次会话使用，Client 的下一次请求在 Client Hello 中带上 Session Ticket，Server 判断该 Session Ticket 有效且正确则可以跳过握手中的部分过程</p><h4 id="Change-Cliper-Spec"><a href="#Change-Cliper-Spec" class="headerlink" title="Change Cliper Spec:"></a>Change Cliper Spec:</h4><ul><li>告知 Client 后续的信息都通过 session-key 进行加密</li></ul><h4 id="Finish-1"><a href="#Finish-1" class="headerlink" title="Finish:"></a>Finish:</h4><ul><li>对上述所有握手过程中的数据使用商量好的 Hash 算法计算 HashCode，并使用 session-key 进行加密</li></ul><h3 id="Application-Data"><a href="#Application-Data" class="headerlink" title="Application Data"></a>Application Data</h3><p>这一步不算是 TLS 的范畴了而是 HTTP 协议的范畴<br>Client 使用商量出来的 session-key 对数据进行对称加密发送给 Server ，Server 接收到数据后使用 session-key 进行解密得到明文数据，再将结果进行加密后返回给 Client</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>TLS 的握手示意过程如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|----------Client----------|----------Server----------|</span><br><span class="line">|      Client Hello       --&gt;                         |</span><br><span class="line">|-----------------------------------------------------|</span><br><span class="line">|                          |     Server Hello         |</span><br><span class="line">|                          |     Certificate          |</span><br><span class="line">|                         &lt;--  Server Hello Done      |</span><br><span class="line">|-----------------------------------------------------|</span><br><span class="line">|   Client Key Exchange    |                          |</span><br><span class="line">|   Change Cipher Spec     |                          |</span><br><span class="line">|          Finish         --&gt;                         |</span><br><span class="line">|-----------------------------------------------------|</span><br><span class="line">|                          |    New Session Ticket    |</span><br><span class="line">|                          |    Change Cipher Spec    |</span><br><span class="line">|                         &lt;--         Finish          |</span><br><span class="line">|-----------------------------------------------------|</span><br><span class="line">|     Application Data    &lt;-&gt;      Application Data   |</span><br><span class="line">|-----------------------------------------------------|</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Wireshark 抓包的握手过程<br><img src="https://i.loli.net/2021/11/17/yqW1mkZHCn5hKTI.jpg" alt="Xnip2020-07-12_15-26-06.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://network.51cto.com/art/202010/628890.htm">数字证书、签名到底是什么？这篇文章讲得太好了</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，HTTP 协议是明文传输的，在网络世界里用 HTTP 协议发送报文相当于裸奔，于是就有了 HTTPS&lt;br&gt;这个 S 是什么呢，是如何保证我们发送的报文就不被窃取和篡改了呢，让我们慢慢道来&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTTP" scheme="https://ppting.me/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>使用 tools 命名空间实现 View 的预览</title>
    <link href="https://ppting.me/2019/01/01/preview_recyclerview_in_preview_window/"/>
    <id>https://ppting.me/2019/01/01/preview_recyclerview_in_preview_window/</id>
    <published>2019-01-01T08:30:36.000Z</published>
    <updated>2022-02-12T08:19:55.000Z</updated>
    
    <content type="html"><![CDATA[<br><blockquote><p>使用 tools 命名空间实现 View 的预览</p></blockquote><p><a href="https://developer.android.google.cn/studio/write/tool-attributes">官方文档</a></p><p>在开发过程中，有时候需要对 View 进行预览，以前需要把 application run 到手机或者是模拟器上后才能看到效果，现在，我们有了更加方便快捷的方法。</p><span id="more"></span><p>对于一个 <code>RecyclerView</code> 来说，一般来说，我们会在 xml 文件中写下面这样的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/rv_list&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这时候会在<code>Android  Studio</code> 右边的预览窗口中看到这样的画面<br><img src="https://i.loli.net/2020/05/02/S7PseZAKHoquLbI.png" alt="Android_Studio_Preview_View_01.png"></p><p>这时候我们会在想，能不能把我们的 item 的布局文件也给展示出来呢，这样就可以预览效果了。</p><p>当然可以，我们可以借助 tools 命名空间来实现这个想法。<br>要使用 <code>tools</code> 的一些 xml 属性，我们需要在 xml 文件的根布局中添加 tools 的命名空间，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RootTag</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><p>这个时候我们就可以开始使用一些属性了。</p><p>我们给 RecyclerView 添加 <code>tools:listitem=&quot;@layout/xxxx&quot;</code> 的话，我们就可以预览到每个 Item 在 RecyclerView 中的样子了。如下图所示<br><img src="https://i.loli.net/2020/05/02/CrcQpP9RkfS4aBW.png" alt="Android_Studio_Preview_View_02.png"></p><p>但这时候你会发现，我们每一个 item 都是一模一样的，没法预览和模拟真实的情景呀。<br>不用怕，Android Studio 3.0 给我们提供了这么一个功能。</p><p>|<strong>“@tools:sample&#x2F;*” resources</strong></p><p>我们可以在每个 Item 中使用这些提供给我们使用的资源文件，这些属性允许您将占位符数据或图像插入到视图中。例如，如果要测试布局如何与文本行为相关，但尚未为应用程序定制UI文本，则可以使用占位符文本，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:text</span>=<span class="string">&quot;@tools:sample/lorem&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下图所示</p><p><img src="https://i.loli.net/2020/05/02/9mjdkyTSoprqIga.png" alt="Android_Studio_Preview_View_03.png"></p><p>系统给我们提供了很多的 sample resource ，如下表所示</p><table><thead><tr><th>Attribute value</th><th>Description of placeholder data</th></tr></thead><tbody><tr><td>@tools:sample&#x2F;full_names</td><td>Full names that are randomly generated from the combination of @tools:sample&#x2F;first_names and @tools:sample&#x2F;last_names.</td></tr><tr><td>@tools:sample&#x2F;first_names</td><td>Common first names.</td></tr><tr><td>@tools:sample&#x2F;last_names</td><td>Common last names.</td></tr><tr><td>@tools:sample&#x2F;cities</td><td>Names of cities from across the world.</td></tr><tr><td>@tools:sample&#x2F;us_zipcodes</td><td>Randomly generated US zipcodes.</td></tr><tr><td>@tools:sample&#x2F;us_phones</td><td>Randomly generated phone numbers with the following format: (800) 555-xxxx.</td></tr><tr><td>@tools:sample&#x2F;lorem</td><td>Placeholder text that is derived from Latin.</td></tr><tr><td>@tools:sample&#x2F;date&#x2F;day_of_week</td><td>Randomized dates and times for the specified format.</td></tr><tr><td>@tools:sample&#x2F;date&#x2F;ddmmyy</td><td></td></tr><tr><td>@tools:sample&#x2F;date&#x2F;mmddyy</td><td></td></tr><tr><td>@tools:sample&#x2F;date&#x2F;hhmm</td><td></td></tr><tr><td>@tools:sample&#x2F;date&#x2F;hhmmss</td><td></td></tr><tr><td>@tools:sample&#x2F;avatars</td><td>Vector drawables that you can use as profile avatars.</td></tr><tr><td>@tools:sample&#x2F;backgrounds&#x2F;scenic</td><td>Images that you can use as backgrounds.</td></tr></tbody></table><p>但是我们还会发现，我们其实远远不满足于系统提供的这些模拟资源文件，我们需要自己定义一些数据来源怎么办？</p><p>当然也没问题</p><p>在 Android Studio 中，我们可以新建一个 <code>Sample Data Directory</code> 文件夹，在这个文件夹里，我们可以自己定义一些 json 数据来源，并且更重要的是，这个文件夹里的资源文件并不会被打包到我们的 apk 文件中。<br><img src="https://i.loli.net/2020/05/02/jYuhBiIfso91Ew8.png" alt="Android_Studio_Preview_View_04.png"><br>例如我们新建一个 <code>mockData.json</code> 文件，用来存放我们这个 RecyclerView 所对应的模拟数据，比如说</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;menus&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;menuUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;menuIcon&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;menuName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;showOrder&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;iconUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;avatar&quot;</span>:<span class="string">&quot;@tools:sample/avatars&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;menuUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;menuIcon&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;menuName&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;showOrder&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;iconUrl&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;avatar&quot;</span>:<span class="string">&quot;@tools:sample/avatars&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，在这个文件编辑完毕后，我们需要 build 一下工程，才能引用到这里的数据</p></blockquote><p>在 build 完毕后，我们就可以通过 <code>tools:text=&quot;@sample/mockdata.json/menus/menuName&quot;</code> 这样的方式引用我们自定义的 json 里的数据了</p><p>例如，我们的 item 布局是这样的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;94dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_work_icon&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;42dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;42dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:src</span>=<span class="string">&quot;@sample/mockdata.json/menus/avatar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_work_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;9dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">&quot;@sample/mockdata.json/menus/menuName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个时候我们可以在预览窗看到我们的预览页面是这样的，已经将文字替换成我们自定义的 json 文件里的数据了。</p><p><img src="https://i.loli.net/2020/05/02/uCfRzJpXcsQZVke.png" alt="Android_Studio_Preview_View_05.png"></p><p>接着再来看我们的 RecyclerView 的预览窗口，我们把 RecyclerView 的 <code>tools:listitem</code> 的值换成我们上面的这个布局，可以看到我们的预览窗口变成了这样<br><img src="https://i.loli.net/2020/05/02/YHUA7FBm4Mxeh8G.png" alt="Android_Studio_Preview_View_06.png"><br>默认的 RecyclerView 是使用垂直的LinearLayoutManager，那如果我们想修改成九宫格的呢，也没问题。</p><p>RecyclerView 中提供了下面的几个属性可供我们修改。</p><table><thead><tr><th>属性</th><th>介绍</th><th>值</th></tr></thead><tbody><tr><td>itemCount</td><td>设置展示 item 的数量</td><td>数字，例如6</td></tr><tr><td>layoutManager</td><td>设置布局方式，三种方式可供选择</td><td>GridLayoutManager、LinearLayoutManager 以及 StaggeredGridLayoutManager</td></tr><tr><td>listitem</td><td>item 的布局</td><td>@layout&#x2F;xxxx</td></tr><tr><td>orientation</td><td>布局的方向</td><td>horizontal vertical</td></tr><tr><td>spanCount</td><td>布局横、纵的列数</td><td>数字，例如3</td></tr></tbody></table><p>举个例子，假如我们的 RecyclerView 是要作为九宫格菜单使用的，平时我们只能在 Java 代码中设置其 LayoutManager 以及 spanCount ，等到跑在手机上以后我们才能预览到效果，但现在，我们可以使用 tools 将这个步骤在开发阶段就提前，在编写 xml 文件时候就可以直接预览了，例如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/rv_third_list&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/item_menu&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:layoutManager</span>=<span class="string">&quot;GridLayoutManager&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:spanCount</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预览图如下图所示</p><p><img src="https://i.loli.net/2020/05/02/2hsRXOJ57qadmpI.png" alt="Android_Studio_Preview_View_07.png"></p>]]></content>
    
    
    <summary type="html">&lt;br&gt;

&lt;blockquote&gt;
&lt;p&gt;使用 tools 命名空间实现 View 的预览&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/studio/write/tool-attributes&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在开发过程中，有时候需要对 View 进行预览，以前需要把 application run 到手机或者是模拟器上后才能看到效果，现在，我们有了更加方便快捷的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Android" scheme="https://ppting.me/categories/Android/"/>
    
    
    <category term="Trick" scheme="https://ppting.me/tags/Trick/"/>
    
    <category term="RecyclerView" scheme="https://ppting.me/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码阅读笔记</title>
    <link href="https://ppting.me/2018/06/07/hashmap/"/>
    <id>https://ppting.me/2018/06/07/hashmap/</id>
    <published>2018-06-07T15:01:16.000Z</published>
    <updated>2022-02-12T08:17:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li>位与 <code>&amp;</code></li></ul><blockquote><p>1 &amp; 1 &#x3D; 1 ，其余都是 0 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sample : </span><br><span class="line">0011</span><br><span class="line">1010</span><br><span class="line">0010</span><br><span class="line">即 `3 &amp; 10 = 2`</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>位或 <code>|</code></li></ul><blockquote><p>0 | 0 &#x3D; 0 ，其余都是 1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sample : </span><br><span class="line">0011</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">即 `3 | 10 = 11`</span><br></pre></td></tr></table></figure><ul><li>位异或 <code>^</code></li></ul><blockquote><p>相同为 0， 不同为1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sample : </span><br><span class="line">0011</span><br><span class="line">1010</span><br><span class="line">1001</span><br><span class="line">即 `3 ^ 10 = 9`</span><br></pre></td></tr></table></figure><ul><li>非 <code>~</code></li></ul><blockquote><p>按位取反</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sample : </span><br><span class="line">0011</span><br><span class="line">1100</span><br><span class="line">即 `~3 = -4`</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><blockquote><p><code>&amp;</code> 是都得为1才能得到1 ，<code>|</code> 是只要有1就为1，<code>^</code> 是相同则为 0，不同则为 1。</p></blockquote><ul><li>原码<br>第一位是符号位，<code>1</code> 是负数，<code>0</code>是正数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000,1000 是 -8</span><br><span class="line">0000,1000 是 +8</span><br></pre></td></tr></table></figure><p>因此可用的范围只是后七位，即8进制的数值范围是 [1111 1111,0111 1111]，用十进制表示是 -(2^7 -1) ~ (2^7 -1 ) 即 [-127,127]</p><ul><li>反码</li></ul><p>正数的反码是其原码本身<br>负数的反码是在符号位不变，其余的按位取反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+10：[0000 1010]原 == [0000 1010]反</span><br><span class="line">-10：[1000 1010]原 == [1111 0101]反</span><br></pre></td></tr></table></figure><ul><li>补码</li></ul><p>正数的补码是其原码本身<br>负数的补码是符号位不变，其余的按位取反，再加一。即</p><blockquote><p>[负数的补码] &#x3D; [负数的反码] + 1;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+10：[0000 1010]原 == [0000 1010]反 == [0000 1010]补</span><br><span class="line">-10：[1000 1010]原 == [1111 0101]反 == [1111 0110]补</span><br></pre></td></tr></table></figure><ul><li>左移 <code>&lt;&lt;</code></li></ul><blockquote><p>逻辑左移 N 位，空缺部分补 0 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&lt; 3 == 8;</span><br><span class="line">即 0001 =&gt; 1000</span><br></pre></td></tr></table></figure><ul><li>无符号右移 <code>&gt;&gt;&gt;</code></li></ul><blockquote><p>逻辑右移 N 位，空缺部分补 0 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 &gt;&gt;&gt; 3 == 1;</span><br><span class="line">即 1000 =&gt; 0001</span><br></pre></td></tr></table></figure><ul><li>有符号右移 <code>&gt;&gt;</code></li></ul><blockquote><p>左边的空出的所有位数根据移位前原来的内容，原来为0就补0，原来为1就补1</p></blockquote><p><em><strong>注意</strong></em>：<em>负数是使用补码进行计算</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-8 &gt;&gt;&gt; 3 (-8 无符号右移 3 位)</span><br><span class="line">-8 ==</span><br><span class="line">[1000,0000,0000,0000,0000,0000,0000,1000]原</span><br><span class="line">[1111,1111,1111,1111,1111,1111,1111,0111]反</span><br><span class="line">[1111,1111,1111,1111,1111,1111,1111,1000]补</span><br><span class="line">右移三位(高位补充0) =&gt;</span><br><span class="line">[0001,1111,1111,1111,1111,1111,1111,1111]补</span><br><span class="line">[0001,1111,1111,1111,1111,1111,1111,1111]反</span><br><span class="line">[0001,1111,1111,1111,1111,1111,1111,1111]原</span><br><span class="line">== 2^29 -1</span><br><span class="line"></span><br><span class="line">-8 &gt;&gt; 3 (-8 有符号右移 3 位)</span><br><span class="line">-8 == </span><br><span class="line">[1000,0000,0000,0000,0000,0000,0000,1000]原</span><br><span class="line">[1111,1111,1111,1111,1111,1111,1111,0111]反</span><br><span class="line">[1111,1111,1111,1111,1111,1111,1111,1000]补</span><br><span class="line">右移三位(根据原内容补充) =&gt;</span><br><span class="line">[1111,1111,1111,1111,1111,1111,1111,1111]补</span><br><span class="line">[1111,1111,1111,1111,1111,1111,1111,1110]反</span><br><span class="line">[1000,0000,0000,0000,0000,0000,0000,0001]原</span><br><span class="line">== -1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p>对于正数 x 来说，<br>左移 n 位<code>&lt;&lt;</code>相当于 <code>x * 2^n</code>，<br>右移 n 位<code>&gt;&gt;</code>相当于 <code>x mod 2^n</code>，取余<br>无符号右移 n 位 <code>&gt;&gt;&gt;</code>相当于 <code>x mod 2^n</code>，取余</p><p>对负数 y 来说，<br>左移 n 位<code>&lt;&lt;</code>相当于 <code>y * 2^n</code>，<br>右移 n 位<code>&gt;&gt;</code>相当于 </p><h3 id="HashMap-的基本原理"><a href="#HashMap-的基本原理" class="headerlink" title="HashMap 的基本原理"></a>HashMap 的基本原理</h3><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul><li>DEFAULT_INITIAL_CAPACITY</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The default initial capacity - MUST be a power of two.</span><br><span class="line"> * 默认初始化容量，必须是2的幂</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 4;//JDK7</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //即16 JDK8 </span><br></pre></td></tr></table></figure><ul><li>MAXIMUM_CAPACITY</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="line"> * by either of the constructors with arguments.</span><br><span class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="line"> * 最大的容量，必须是2的幂，并且在 [2,2^30]之间</span><br><span class="line"> * int 型的最大值为 2^31 -1 ，但 HashMap 的容量必须是 2 的幂，所以最大值只能是 2^30</span><br><span class="line"> */</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_LOAD_FACTOR</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The load factor used when none specified in constructor.</span><br><span class="line"> * 默认的负载因子值，用来计算扩容的临界值，0.75f</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure><ul><li>EMPTY_TABLE</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An empty table instance to share when the table is not inflated.</span><br><span class="line"> * 当 table 还没扩容时的实例，即一个空的table</span><br><span class="line"> */</span><br><span class="line">static final HashMapEntry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>table ;HashMap 中的存放键值对的单链表数组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="line"> * 可以随时调整的 table，长度必须是2的幂</span><br><span class="line"> */</span><br><span class="line">transient HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><ul><li>size</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The number of key-value mappings contained in this map.</span><br><span class="line"> * 这个 map 中键值对的数量</span><br><span class="line"> */</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><ul><li>threshold</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The next size value at which to resize (capacity * load factor).</span><br><span class="line"> * 下一次进行扩容的值，即阈值，等于最大容量 * 负载因子</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">// If table == EMPTY_TABLE then this is the initial capacity at which the</span><br><span class="line">// table will be created when inflated.</span><br><span class="line">//如果 table 是空的时候，即 table == EMPTY_TABLE ， threshold 的值就是 table 扩容时的初始容量</span><br><span class="line">int threshold;</span><br></pre></td></tr></table></figure><ul><li>loadFactor</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The load factor for the hash table.</span><br><span class="line"> * hash table 的负载因子</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">// Android-Note: We always use a load factor of 0.75 and ignore any explicitly</span><br><span class="line">// selected values.</span><br><span class="line">//Android-Note: 使用 0.75 这个固定的值，忽略其他明确的值</span><br><span class="line">final float loadFactor = DEFAULT_LOAD_FACTOR;</span><br></pre></td></tr></table></figure><ul><li>modCount</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap 的结构被修改的次数</span><br><span class="line">结构修改指的是那些 HashMap 中映射数量或者是其内部结构(比如 rehash)的修改</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>好了，现在开始来看构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">        initialCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// Android-Note: We always use the default load factor of 0.75f.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This might appear wrong but it&#x27;s just awkward design. We always call</span></span><br><span class="line">    <span class="comment">// inflateTable() when table == EMPTY_TABLE. That method will take &quot;threshold&quot;</span></span><br><span class="line">    <span class="comment">// to mean &quot;capacity&quot; and then replace it with the real threshold (i.e, multiplied with</span></span><br><span class="line">    <span class="comment">// the load factor).</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中，接收两个参数，一个是初始容量(initialCapacity)，一个是负载因子(loadFactor)</p><p>从代码中可见，前面都是在进行判断这两个值的合法性，比如初始容量必须大于等于0，如果大于可容纳的最大容量，则赋值为最大值<code>MAXIMUM_CAPACITY(2^30)</code> ，如果小于默认的容量，则赋值为最小容量。<br>负载因子的必须大于0，并且是个浮点数(Float)</p><p>最后一步将初始容量赋值给 threshold<br><code>init()</code> 方法是个空方法，忽略不计</p><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>向 HashMap 中添加一个键值对，并返回 value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当 table 是空的时候，对 table 进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);<span class="comment">//①</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key 是 null，则放入 value并返回旧的值</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);<span class="comment">//②</span></span><br><span class="line">        <span class="comment">//key 不为 null，计算 key 的 hash 值</span></span><br><span class="line">        <span class="keyword">int</span> hash = </span><br><span class="line">sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">        <span class="comment">//通过 key 的 hash 值和数组 table 的长度计算出这个`键值对`应在数组中的索引值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//③</span></span><br><span class="line">        <span class="comment">//获取到当前索引值存放的链表，并进行循环</span></span><br><span class="line">        <span class="keyword">for</span> (HashMapEntry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//如果该链表上有一个键值对 e ，并且这个键值对 e 的 hash 值和新放入的键值对的hash相同，并且key值也相同，则将新的 value 替换旧的 value，并返回旧的 value 值</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，即当前链表上没有 key 值以及 hash 值相同的键值对，则 modCount 自增</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//新增一个键值对</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//④</span></span><br><span class="line">        <span class="comment">//返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>① 先看 <code>inflateTable(int toSize)</code> 方法</p><ul><li>先计算 table 的容量</li><li>再计算新的阈值</li><li>创建 table 对象，即 HashMapEntry 数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  扩容 table ，toSize 是要扩大到的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">//计算 table 的容量，因为必须是2的幂，所以通过 roundUpToPowerOf2() 方法计算出大于等于 toSize 值的 2的幂</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Android-changed: Replace usage of Math.min() here because this method is</span></span><br><span class="line">    <span class="comment">// called from the &lt;clinit&gt; of runtime, at which point the native libraries</span></span><br><span class="line">    <span class="comment">// needed by Float.* might not be loaded.</span></span><br><span class="line">    <span class="comment">//再计算新的阈值，即 table 容量 * 负载因子，如果超过了最大的容量，则将阈值设置为 table 最大值 + 1</span></span><br><span class="line">    <span class="keyword">float</span> thresholdFloat = capacity * loadFactor;</span><br><span class="line">    <span class="keyword">if</span> (thresholdFloat &gt; MAXIMUM_CAPACITY + <span class="number">1</span>) &#123;</span><br><span class="line">        thresholdFloat = MAXIMUM_CAPACITY + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) thresholdFloat;</span><br><span class="line">    <span class="comment">// 新建一个 HashMapEntry 对象，即 table</span></span><br><span class="line">    table = <span class="keyword">new</span> HashMapEntry[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 再接着看 <code>putForNullKey(V value)</code> 方法</p><blockquote><p>可见 HashMap 是可以存入键值(key) 为 <code>null</code> 的键值对的，并且会将 <code>key = null</code> 的键值对放到数组的第一位，即 <code>table[0]</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Offloaded version of put for null keys</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//取出数组中索引为 0 的链表，进行循环，</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果链表中有 key 为 null 的键值对，即该 HashMap 中有 key 为 null 的键值对，则将新值替换旧值，并返回旧值。</span></span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果原来链表中没有 key 为 null 的键值对，将 modCount 自增</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//并向链表中添加一个键值对</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 再看计算索引的方法 <code>indexFor(int hash, int length)</code><br>hash -&gt; hash 值<br>length -&gt; 数组长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns index for hash code h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="comment">//即相当于 h % length，取余数</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④ 接着看 <code>addEntry(int hash, K key, V value, int bucketIndex)</code> 方法<br>这个方法有四个入参分别是</p><table><thead><tr><th>入参</th><th>意义</th></tr></thead><tbody><tr><td>hash</td><td>key 的 hash 值</td></tr><tr><td>key</td><td>key(键)</td></tr><tr><td>value</td><td>value(值)</td></tr><tr><td>bucketIndex</td><td>该键值对应该放在 table 中的索引</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前的键值对数量是否超过阈值</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//当前的键值对数量大于阈值，且该键值对应放入的索引位置的链表不为空（即发生了 hash 碰撞），则进行扩容操作，扩容2倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//⑤</span></span><br><span class="line">        <span class="comment">//重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新计算在扩容后的 table 中的索引</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的节点</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);<span class="comment">//⑥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤ 下面看 <code>resize(int newCapacity)</code> 扩容的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个局部变量存放原来的 table 的引用</span></span><br><span class="line">    HashMapEntry[] oldTable = table;</span><br><span class="line">    <span class="comment">//算出旧 table 的长度，即旧 table 的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//如果之前的容量已经达到最大了，修改阈值为最大值并返回</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量还没达到最大，新建一个 table (链表数组)，长度为新的容量(newCapacity)</span></span><br><span class="line">    HashMapEntry[] newTable = <span class="keyword">new</span> HashMapEntry[newCapacity];</span><br><span class="line">    <span class="comment">//转移新的键值对，将原来的键值对转移到新的 table 中</span></span><br><span class="line">    transfer(newTable);<span class="comment">//⑦</span></span><br><span class="line">    <span class="comment">//将新的 table(newTable) 的引用赋值给 table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//计算新的阈值，即（新的容量 * 负载因子）或者是（最大容量 + 1）的最小值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑦ <code>transfer()</code> 转移到新 table 的方法</p><blockquote><p>注意，这份方法在转移键值对到新的table中时，会将链表的顺序给倒序了，插入时插到链表的最前面<br>即原来链表是 [A] -&gt; [B] -&gt; [C]，转移到新的链表后变成 [C] -&gt; [B] -&gt; [A] {假设扩容后这三个键值对的 hash 索引还相同}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(HashMapEntry[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算新的 table 的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//对旧的 table 数组进行循环</span></span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">//下面对链表进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//计算当前节点在新 table 中的索引值</span></span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">//取新的 table 中第i个位置的链表中第一个键值对，赋值给 e.next</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">//①</span></span><br><span class="line">            <span class="comment">//将当前的 键值对 放入新 table 的第一个位置</span></span><br><span class="line">            newTable[i] = e;<span class="comment">//②</span></span><br><span class="line">            <span class="comment">//将原来的链表上的下一个节点赋值给 e</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解<br><img src="https://i.loli.net/2020/05/02/GIUbRardgenqSyQ.png" alt="HashMap_transfer.png"></p><p>在 for 循环时，e 指向旧 table 数组中的某条链表</p><ul><li><p>第一次循环时，e 指向该链表的第一个键值对，next 指向 e.next 即第二个键值对</p><blockquote><p>PS.我们假设转移前后我们的这两个键值对的 hash 值计算出来的索引仍然相同</p></blockquote></li><li><p>将新 table 数组第 i 个位置的链表接到 e 的后面，再把 e 放到 <code>newTable[i]</code> 的位置</p></li><li><p>将 next 赋值给 e ，继续循环，直到链表循环结束</p></li></ul><p>⑥ <code>createEntry(int hash, K key, V value, int bucketIndex)</code> 创建新的键值对</p><blockquote><p>新插入的键值对会插入到链表最前面</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将该键值对对应的索引的位置的键值对table[bucketIndex] 的引用赋值给局部变量 e</span></span><br><span class="line">    HashMapEntry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//新建一个键值对，即新放入的 hash，key，value，该键值对的 next 是原来的在这个索引位置的键值对</span></span><br><span class="line">    <span class="comment">//可见插入键值对时会插入到链表的最前面</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> HashMapEntry&lt;&gt;(hash, key, value, e);⑦</span><br><span class="line">    <span class="comment">//对 size 自增，即键值对数量 + 1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑦ <code>HashMapEntry</code> 构造方法，可见传入的第四个参数 n 会被放到这个新的 entry 的 next ，即放到第四个参数在链表位置上的前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMapEntry(<span class="keyword">int</span> h, K k, V v, HashMapEntry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h2><p>从 HashMap 中通过 <em>key</em> 移除某个键值对，当这个键值对存在时，返回该 key 对应的 value，若不存在，则返回 null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往下看 <code>removeEntryForKey(key)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//若该 HashMap 的长度为 0 ，说明没有键值对，直接返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取该 key 对应的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : sun.misc.Hashing.singleWordWangJenkinsHash(key);</span><br><span class="line">    <span class="comment">//获取该 hash 值所对应的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//获取该索引处的链表</span></span><br><span class="line">    HashMapEntry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    <span class="comment">//将该链表赋值给 e</span></span><br><span class="line">    HashMapEntry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对链表进行循环，当链表上的节点 e 不为 null 时</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        将链表的下一个节点赋值给 next</span><br><span class="line">        HashMapEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//当该节点的 hash 值和所要删除的 key 的 hash 值相同，并且 key 值相同，或者 key 不为 null，则找到了所要删除的键值对</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//自增修改次数</span></span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="comment">//将 HashMap 键值对数量减一</span></span><br><span class="line">            size--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">            <span class="comment">//如果 prev == e ，即刚好链表中的第一个节点就是所要查找的节点，则直接将链表的 next 指向第二个节点，就把该节点删除了</span></span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则将 e 节点的下一个节点赋值给，prev 的下个节点，即将 prev 的 next 指向 e.next </span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//返回删除的节点 e</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 e ，这里已经循环链表完毕，e 为 null</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当第一个节点就是所要查询的节点时候<br><img src="https://i.loli.net/2020/05/02/w2Vbk17NYMHDSI5.png" alt="HaspMap_截图_1.png"></li></ul><p>此时 <code>prev == e</code>，则直接将 <code>e.next(即 next)</code>直接赋值给 <code>table[i]</code>，则把 node a 直接删除了</p><ul><li>从链表中不能查到该节点</li></ul><p><img src="https://i.loli.net/2020/05/02/rX6oDc27s48gOyi.png" alt="HaspMap_截图_2.png"></p><p>prev 和 e 是链表对象，每次循环后 e 会先往链表下走，直到查找到满足条件的节点，如果都不满足，则 <code>e == null</code> 此时会退出循环，并返回 e ，即返回 null。</p><ul><li>从链表中能查到该节点</li></ul><p><img src="https://i.loli.net/2020/05/02/cStraUJXR5QupYm.png" alt="HaspMap_截图_3.png"></p><p>若找到了满足条件的节点 node b(即 e)，则将 prev.next &#x3D; e.next ，等效于将 node b 从链表中删除了</p><h2 id="Java-8-中的-put-方法"><a href="#Java-8-中的-put-方法" class="headerlink" title="Java 8 中的 put 方法"></a>Java 8 中的 put 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果当前 table 为 null 或者数组长度为 0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//扩容，并将扩容后的数组赋值给 tab ，n 则为当前数组的长度</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面的 `(n - 1) &amp; hash]` 就是 Java 7 中计算索引的方法</span></span><br><span class="line">        <span class="comment">//如果计算出的索引处要插入的地方为 null ，则直接新增一个 Node 键值对</span></span><br><span class="line">        <span class="comment">//此时将 tab[index] 赋值给了 p ，即 p = tab[index]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果走到这里，可以说明该键值对的 key 在原先的 HashMap 中是不存在的</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//要插入的索引处已经有 Node 了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//假如该索引处的 Node p 的 hash 值和新放入的键值对的hash相同，并且key值也相同</span></span><br><span class="line">            <span class="comment">//将 p 赋值给 e</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//key 不相同的话，并且 p 是红黑树的一个节点，则直接插入红黑树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key 不相同，并且不为红黑树，即链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//进行循环</span></span><br><span class="line">                <span class="comment">//如果 p 的下个节点为空(即 p 是最后一个节点)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将该需要插入的节点插到链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果链表长度超过 8 ，则转为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">//跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果 p 的下个节点 e 不为空，且 e 的 hash 值等于插入的节点的 hash 并且 key 相同，即 e 就等于需要插入的节点，则直接跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//将链表的下个节点 `e` 在循环中赋值给 `p`</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//如果 e 不为空，即原来的 table 中存在相同的 key ，e 为旧的 node</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//替换掉旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回 key 对应的旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果 HashMap 中不存在该 key，会走到这里</span></span><br><span class="line">    <span class="comment">//mod 次数自增</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果键值对数量大于阈值，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结下思路</p><ol><li>在插入时，计算出 key 值对应的 hash 值，接着计算 hash 值对应的索引</li><li>判断该索引处是否为空</li></ol><p>2.1 如果为空，则直接插入该键值对<br>2.2 如果不为空，说明该索引处已经存在『链表』或者『红黑树』了<br>2.2.1 如果『链表』的第一个节点或者『红黑树』的根节点的 key 值等于要插入的 key 并且 hash 值相同，则进行替换<br>2.2.2 否则，如果是『红黑树』，则进行插入<br>2.2.3 否则，如果是『链表』，则进行循环链表插入（如果链表长度超过 8，则转换为红黑树）<br>2.2.4 经过 2.2.1 - 2.2.3 之后，如果原来中有相同的 key ，则直接 return 旧值<br>2.3 原 HashMap 中没有插入的 key，则键值对数量自增，判断扩容，return null</p></blockquote><h3 id="Java-8-中的-resize-方法"><a href="#Java-8-中的-resize-方法" class="headerlink" title="Java 8 中的 resize() 方法"></a>Java 8 中的 resize() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//获取旧的数组引用</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//计算旧数据的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//获取旧阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//如果旧数组长度大于等于最大容量，则直接返回旧数组</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                 <span class="comment">//新数据容量 = 旧数据容量左移一位，即 * 2</span></span><br><span class="line">                 <span class="comment">//如果新数组容量小于最大值，且旧数组容量大于等于默认长度（16）</span></span><br><span class="line">                 <span class="comment">//同时将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">         <span class="comment">// 如果原来的 threshold 大于0则将容量设为原来的 threshold</span></span><br><span class="line">        <span class="comment">// 在第一次带参数初始化时候会有这种情况</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在默认无参数初始化会有这种情况</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//16</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//16 * 0.75 = 12</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果新的阈值为 0</span></span><br><span class="line">        <span class="comment">//计算新的阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//如果新的容量小于最大容量且新的阈值也小于最大容量</span></span><br><span class="line">        <span class="comment">//则新的阈值等于 ft ，否则设置为 Integer.MAX_VALUE</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的阈值赋值给 threshold</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//创建新的数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        <span class="comment">//将新数组赋值给 table </span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//进行扩容复制</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//旧数组不为 null ，进行循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 将当前索引处的第一个节点赋值给 e </span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将旧数组的引用置为 null</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果当前索引处只有一个节点，则直接计算在新数组中的索引并赋值</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果 e 是红黑树，则调用红黑树的方法进行处理</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//处理链表长度为 1 ~ 8 的情况</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//低位的链表头节点，低位的链表尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//高位的链表头节点，高位的链表尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//！！这里 e.hash &amp; oldCap 不是计算索引，计算索引应该是 e.hash &amp; (oldCap -1)</span></span><br><span class="line">                            <span class="comment">//如果节点 e 的 hash 值和 oldCap 计算出来值为 0 ，说明在扩容后该节点的索引相同，不需要移动索引</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="comment">//第一次才会走入这个地方</span></span><br><span class="line">                                <span class="comment">//如果低位尾部节点为 null，将 e 赋值给头部节点，即链表第一个节点</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//否则(即第二次以后)，将 e 赋值给尾部节点的 next，即 loTail.next </span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">//再将 e 赋值给尾部节点 loTail，</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//否则，该节点需要移动索引位置到新的索引去</span></span><br><span class="line">                            <span class="comment">//方法同上</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">// 将 next 赋值给 e，直到没有 next ，即链表循环完毕</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果低位的尾节点不为 null ，则将其 next 置为 null</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//并将低位的头节点放到该低位索引处</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果高位的尾节点不为 null ，则将其 next 置为 null</span></span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//并将高位的头节点放到该高位索引处</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点看一下处理链表长度为 1~ 8 的情况</p><p>首先我们知道，对于一个键值对节点，其索引的计算方式为 <code>index = hash(key) &amp; (n - 1)</code> </p><p>假设现在有两个节点 <code>Node A</code> 和 <code>Node B</code> ,其 key 的 hash 值分别为 hash(a)、hash(b)，n &#x3D; 16</p><p>计算其索引过程如下</p><p>n - 1     0000 0000 0000 0000 0000 0000 0000 1111<br>hash(a)   1111 1111 1111 1111 0000 1111 0000 0101<br>hash(b)   1111 1111 1111 1111 0000 1111 0001 0101</p><p>计算索引 <code>index = hash(key) &amp; (n - 1)</code></p><p>index(a)  0000 0000 0000 0000 0000 0000 0000 0101 &#x3D;&#x3D; 5<br>index(b)  0000 0000 0000 0000 0000 0000 0000 0101 &#x3D;&#x3D; 5</p><p>则 <code>Node A</code> 和 <code>Node B</code> 计算出来的索引相同，则放在同一个链表中，当进行扩容时，数组的长度会变为原来长度的两倍<br>即 n &#x3D; n * 2;<br>扩容后要重新计算索引</p><p>n - 1     0000 0000 0000 0000 0000 0000 0001 1111<br>hash(a)   1111 1111 1111 1111 0000 1111 0000 0101<br>hash(b)   1111 1111 1111 1111 0000 1111 0001 0101<br>计算索引 <code>index = hash(key) &amp; (n - 1)</code></p><p>index(a)  0000 0000 0000 0000 0000 0000 0000 0101 &#x3D; 5<br>index(b)  0000 0000 0000 0000 0000 0000 0001 0101 &#x3D; <code>21 = 5 + 16</code></p><p>由此可见，当同一个链表中的节点在进行重新索引时，并不需要重新通过 <code>index = hash(key) &amp; (n - 1)</code> 方法计算索引，同一个链表中的节点在扩容后要么还在当前索引<code>index</code>处，要么在 <code>index + oldCap</code>处。</p><p>所以当扩容时重新计算索引，可以不需要重新计算 hash 值，节省了计算 hash 的时间，并且只需要看原来的 hash 值新增的那个高位的值是 1 还是 0 即可⑨，如果是 1 ，则新的索引为 <code>index = index + olcCap</code>，否则 <code>index</code> 不变</p><p>⑨计算方法</p><blockquote><p>e.hash &amp; oldCap 判断是否为 0 </p></blockquote><p><img src="https://i.loli.net/2020/05/02/dl6RxSMi3HEA9ze.png" alt="HaspMap_截图_4.png"></p><p>更简单来说，</p><ul><li><p>第一次: </p><blockquote><p>e -&gt; A,next -&gt; B,<br>loHead -&gt; e(A) ,loTail -&gt; e(A)<br>e -&gt; next(B)</p></blockquote></li><li><p>第二次: </p><blockquote><p>e -&gt; B,next -&gt; C,loTail -&gt; A<br>loTail.next -&gt; e(B)<br>此时 loHead 和 loTail 指向同一个内存地址，所以 loHead.next &#x3D; e(B)<br>loTail -&gt; e(B),e -&gt; next(C)</p></blockquote></li><li><p>第三次:</p><blockquote><p>e -&gt; C,next -&gt; null,loTail -&gt; B<br>loTail.next -&gt; e(C)<br>则此时 B.next  指向了 C ,而 loHead.next 指向的也是 B ,即 loTail,所以此时 loHead.next.next -&gt; C<br>loTail -&gt; e(C),e -&gt; next(null)</p></blockquote></li><li><p>结束循环<br>loHead &#x3D; A -&gt; B -&gt; C</p></li></ul><p><strong>通过上面的分析也可以看出，Java 8 在扩容过程中，链表的顺序是不变的，链表在扩容后还保持原来的顺序，而 Java 7 是倒序的</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;位运算符&quot;&gt;&lt;a href=&quot;#位运算符&quot; class=&quot;headerlink&quot; title=&quot;位运算符&quot;&gt;&lt;/a&gt;位运算符&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;位与 &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1 &amp;amp; 1 &amp;#x3D; 1 ，其余都是 0 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sample : &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;即 `3 &amp;amp; 10 = 2`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://ppting.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://ppting.me/categories/Java/"/>
    
    <category term="源码" scheme="https://ppting.me/categories/%E6%BA%90%E7%A0%81/"/>
    
    <category term="数据结构" scheme="https://ppting.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Map" scheme="https://ppting.me/tags/Map/"/>
    
  </entry>
  
</feed>
