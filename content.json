{"pages":[{"title":"About Me","text":"Android Developer in Guangzhou,China Former Frisbee Player cause injure","link":"/about/index.html"}],"posts":[{"title":"极限飞盘","text":"那一次美丽的邂逅，我爱上你第一次接触飞盘是在大一的时候，那是因为学校体育课选课，因为之前没有接到通知要选体育课，所以等到快截止的时候才匆匆选择了这一个项目。 刚开始不太情愿去上，体育课很热，一开始也是练习基本功，传盘接盘，正手反手，枯燥而无味，考试也考得不好，直到第二学期，开始有点进步了，老师开始让我们打比赛，在场上奔跑，得分，那个时候开始喜欢上了这项运动–开心，快乐，团结，无裁判 今年3月份，去参加了在南京举办的邀请赛，真正地在草地上享受飞盘的乐趣，也碰到了全国各地的飞盘爱好者，大家一起比赛吃喝玩乐，其乐融融。比起去年6月份在南邮举办的城际邀请赛(真心不想吐槽。。。天气太热场地不好）好多了,后来又一次路过南师大随园校区，之前一直听杜老师说过每周日都会有人在这边玩飞盘，于是我怀着好奇的心态去看了看，遇到 Simon 和 Lucy ，还有 Chris 之前在南体比赛的时候就认识他们了，玩了一个下午，氛围很好，从那以后我每个周日都会过去南师大随园校区玩飞盘，希望自己能够坚持下去，并且让更多的人参与到其中来。","link":"/2014/05/26/2014_05_26_ultimate/"},{"title":"暑假充电之————HTML5 NO.1","text":"###暑假充电之——HTML5学习笔记NO.1今天下午在慕课网上学习了HTML5的第一二两章，都是一些很基本的标签知识，下面做下笔记，以便以后复习。 首先知道了HTML5的语法编写风格和之前的都变得不一样了，变得简单易懂容易记忆。变化： doctype 从``变成了`` 字符编码 从``变成了`` 从以上可以看出HTML5的语法风格变得更加简洁，例外，HTML5可以全部使用**大写**，可以**不使用引号**，可以**忽略闭合斜杠**，也可以**混合使用**，但是为了编码的规范和代码的易懂性，还是最好不要这么做。 HTML5文件基本结构 网页的标题信息 暂时还不懂，以后补充 暂时还不懂，以后补充 暂时还不懂，以后补充 段落 标题文本//x从1~6代表标题从最重要到次要 加粗文字 斜体文字 //无语义，为了设置单独的样式（比如颜色等），表示强调 引用文本//无语义，表现为双引号，一般为短引用 引用文本//长引用，表现为缩进 换行//表现为回车换行，和一样无内容 &nbsp；//表现为空格 以上是今天的学习内容，总结几点： 在学习过程中发现有些标签和Markdown是差不多的，因为之前写过Blog所以上手起来比较容易； Markdown是兼容HTML的，所以以上说法就能说得通了。 下面进行一点实践：源代码如下： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;Hello HTML5&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;欢迎来到HTML5的世界标题1&lt;/h1&gt; &lt;h2&gt;欢迎来到HTML5的世界标题2&lt;/h2&gt; &lt;h3&gt;欢迎来到HTML5的世界标题3&lt;/h3&gt; &lt;h4&gt;欢迎来到HTML5的世界标题4&lt;/h4&gt; &lt;h5&gt;欢迎来到HTML5的世界标题5&lt;/h5&gt; &lt;h6&gt;欢迎来到HTML5的世界标题6&lt;/h6&gt; &lt;p&gt;这是一个(这里有一个加了&quot;&amp; nbsp&quot;的空格→)&amp;nbsp段落&lt;/p&gt; &lt;p&gt;这是另外一个段落&lt;/p&gt; &lt;!--这是注释&gt;&lt;!--&gt;&lt;br&gt; &lt;span&gt;用蓝色字体表示强调&lt;/span&gt;&lt;br&gt; &lt;style&gt;span{color:blue}&lt;/style&gt; &lt;strong&gt;定义加重语气（会加粗字体）&lt;/strong&gt;&lt;br&gt; &lt;em&gt;斜体&lt;/em&gt;&lt;br&gt; &lt;q&gt;咬定青山不放松&lt;/q&gt; &lt;blockquote&gt;咬定青山不放松，&lt;br&gt;立根原在破岩中，&lt;br&gt;千磨万击还坚劲，&lt;br&gt;任尔东西南北风&lt;/blockquote&gt; &lt;img&gt; &lt;/body&gt; &lt;/html&gt; 以下是在markdown的显示效果，因为Markdown支持HTML，所以显示基本效果相同： Hello HTML5 欢迎来到HTML5的世界标题1 欢迎来到HTML5的世界标题2 欢迎来到HTML5的世界标题3 欢迎来到HTML5的世界标题4 欢迎来到HTML5的世界标题5 欢迎来到HTML5的世界标题6 这是一个(这里有一个加了\"& nbsp\"的空格→)&nbsp段落 这是另外一个段落 用蓝色字体表示强调 span{color:blue} 加粗字体 斜体 咬定青山不放松 咬定青山不放松，立根原在破岩中，千磨万击还坚劲，任尔东西南北风 在Chrome浏览器中显示效果如下： ![Chrome显示效果](https://ooo.0o0.ooo/2017/01/07/5870e7b76d7a2.jpg)","link":"/2014/07/07/2014_07_07_learn_html5_no1/"},{"title":"暑假充电之————HTML5 NO.2","text":"##暑假充电之——HTML5学习笔记NO.2 span{color:blue} ###&lt;ul&gt;&lt;ol&gt;&lt;li&gt;标签语法：&lt;ul&gt;&lt;li&gt;信息&lt;/li&gt;&lt;/ul&gt;此标签为无序标签，显示效果会在“信息”前面加一个小黑点 ·&lt;ol&gt;&lt;li&gt;信息&lt;/li&gt;&lt;/ol&gt;此标签为有序标签，显示效果为在每个信息点前面加数字编号（默认从1开始） ###&lt;div&gt;标签语法：&lt;div id=&quot;板块名称&quot;&gt;信息&lt;/div&gt;&lt;div&gt;标签相当于一个容器，用id属性为&lt;div&gt;提供唯一的名称###&lt;table&gt;表格标签创建表格有4个元素：table，tr（行），th（单元格），tb（表头）语法： &lt;table&gt; &lt;table summary=&quot;XXX&quot;&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;表格表头&lt;/th&gt;(默认加粗居中) &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 边框属性：在中添加&lt;table border=&quot;1&quot;&gt;，会显示边框###&lt;a&gt;链接标签####链接&lt;a hrdf=&quot;目标网址&quot;&gt;链接显示文字&lt;/a&gt;本语句会在当前浏览器窗口打开此链接&lt;a href=&quot;目标网站&quot; target=&quot;_blank&quot;&gt;链接显示文字&lt;/a&gt;本语句会在新的浏览器窗口打开此链接，但是此属性不符合w3c规范，在HTML5中被废除了可以用图片作为链接，只需要将“链接显示文字”修改成图片的位置例如：&lt;a href=&quot;/example/html/lastpage.html&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;/i/eg_buttonnext.gif&quot; /&gt;&lt;/a&gt;####使用mailto在网页中链接Email地址语法：&lt;a href=&quot;mailto:Email@email.com&quot;?subject=test&amp;body=test&gt;链接文字&lt;/a&gt; mailto功能表 功能 关键字 邮箱地址 mailto 抄送地址 cc= 密件抄送地址 bcc= 多收件人 ； 邮件主题 subject= 邮件内容 body= PS:若mailto后面有多个参数，第一个参数必须以***“？”***开头，后面的每一个都由***“&”***分隔 ####name属性（书签） name属性规定锚（anchor）的名称 `锚（显示在页面上的文本）` 先命名一个锚：`基本的注意事项 - 有用的提示` 再创建指向该锚的链接：`有用的提示` 例： 文本输入输出框 ###&lt;img&gt;图片标签语法：&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title=&quot;提示文本&quot; width=&quot;&quot; height=&quot;&quot;&gt;src:标识图像位置alt:指定图像的描述性文本title:提供在图像可见时对图像的描述（鼠标滑过时的显示文本）width:宽height:高###&lt;form&gt;标签在HTML5中可以使用id进行串联表单比如： &lt;html&gt; &lt;form id=&quot;ting&quot;&gt;&lt;/form&gt; &lt;input type=&quot;text&quot; name=&quot;text&quot; value =&quot;&quot; form=&quot;ting&quot;&gt; &lt;/html&gt; ####使用表单标签，与用户交互语法： &lt;form&gt; &lt;input method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt; &lt;/form&gt; action:用户输入的数据被传输到的地方 method:数据传送的方式（get/post） ####文本输入输出框 语法: `&lt;form&gt;`&lt;br&gt; `&lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot;&gt;`&lt;br&gt; `&lt;/form&gt;` type: a.当type为text时，为文本输入框（明文） b.当type为password时，为密码输入框（星号点） name:为文本框命名，方便后台程序ASP/PHP调用 value:为文本输入框设置默认值 ####文本域 语法： `文本` 举例如下： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;文本域&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt; &lt;label&gt;个人简介：&lt;/label&gt; &lt;textarea cols=&quot;20&quot; rows=&quot;3&quot;&gt;别试了，只是一个例子而已o(╯□╰)o没有后台的&lt;/textarea&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot; name=&quot;submit&quot; /&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot; name=&quot;reset&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如下： 文本域 测试框 别试了，只是一个例子而已o(╯□╰)o没有后台的 ####单选域，复选框 语法： `文本` type: &nbsp;当type为radio时，控件为单选框； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当type为checkbox时，控件为复选框。 value:提交数据到服务器的值（供后台程序PHP使用） name:维空间命名，以备后台程序PHP，ASP使用 checked:当设置为checked=\"checked\"时，被默认选中 PS：单选框的 **name** 值要一样 举例： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;单选框、复选框&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt; &lt;label&gt;性别:&lt;/label&gt; &lt;label&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; value=&quot;1&quot; name=&quot;sex&quot; /&gt; &lt;label&gt;女&lt;/label&gt; &lt;input type=&quot;radio&quot; value=&quot;2&quot; name=&quot;sex&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如下： 单选框、复选框 是否成年: 是 否 ####下拉列表 语法: `选项` 当加入selected=\"seleted\"属性时，该选项被默认选中 当在``标签中设置multiple=\"multiple\"属性时，为多选框，按住Ctrl选择 举例： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;下拉列表框&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt; &lt;label&gt;职业:&lt;/label&gt; &lt;select&gt; &lt;option value=&quot;学生&quot;&gt;学生&lt;/option&gt; &lt;option value=&quot;工人&quot;&gt;工人&lt;/option&gt; &lt;option value=&quot;教师&quot;&gt;教师&lt;/option&gt; &lt;option value=&quot;企业家&quot; selected=&quot;selected&quot;&gt;企业家&lt;/option&gt;&lt;!--将企业家设置为默认值&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果如下： 下拉列表框 职业: 学生 工人 教师 企业家","link":"/2014/07/08/2014_07_08_learn_html5_no2/"},{"title":"暑假充电之————HTML5 NO.3","text":"##暑假充电之——HTML5学习笔记NO.3###HTML布局属性&lt;div&gt;定义文档中的分区域节（division/section）&lt;span&gt;定义span，用来组合文档中的行内元素 span{color:blue} ###HTML框架语法：&lt;frameset&gt; cols/rows=&quot;25%,75%&quot;&gt;&lt;/frameset&gt;假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 &lt;frame&gt; 标签中加入：noresize=”noresize”不能将&lt;body&gt;&lt;/body&gt;和&lt;frameset&gt;&lt;/frameset&gt;同时使用，加入添加包含一段文本的&lt;noresize&gt;标签，就必须将文字嵌套于&lt;body&gt;&lt;/body&gt;中例如： &lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;/example/html/frame_a.html&quot;&gt; &lt;frame src=&quot;/example/html/frame_b.html&quot;&gt; &lt;frame src=&quot;/example/html/frame_c.html&quot;&gt; &lt;noframes&gt; &lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt; &lt;/noframes&gt; &lt;/frameset&gt; ####内联框架iframe语法：&lt;iframe src=&quot;URL&quot;&gt;&lt;iframe&gt;设置宽度/高度:&lt;iframe src=&quot;URL&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt;属性值默认是像素，但也可以用百分比来设定frameborder=”0”可以移除边框#####使用iframe作为连接的目标&lt;iframe src=&quot;URL&quot; name=&quot;ppting&quot;&gt;&lt;iframe&gt;&lt;a href=&quot;Another URL&quot; target=&quot;ppting&quot;&gt;文本&lt;/a&gt;内联框架先是显示URL的内容，点击“文本”后显示Another URL的内容###HTML背景####背景颜色&lt;body bgcolor=&quot;#000000&quot;,text=&quot;black&quot;&gt;&lt;/body&gt;bgcolor 的属性可以是：①#000000；②rgb(0,0,0);③black。####背景图片&lt;body background=&quot;图片URL&quot;&gt;","link":"/2014/07/12/2014_07_14_learn_html5_no3/"},{"title":"暑假充电之————HTML5 NO.4","text":"##暑假充电之————HTML5 NO.4###HTML5&lt;video&gt;当前video支持三种视频格式，MPEG4，Ogg，WebMOgg：带有Theora视频编码和Vorbis音频的Ogg文件；MPEG4:带有H.264视频编码和AAC音频的Ogg文件；WebM:带有VP8视频编码和Vorbis音频的Ogg文件；语法：&lt;video src=&quot;url&quot; controls=&quot;controls&quot; width=&quot;宽&quot; height=&quot;高&quot;&gt;文本&lt;/video&gt;·controls 属性提供播放、暂停和音量控件；·&lt;video&gt;&lt;/video&gt;中插入的文本内容是供不支持video元素的浏览器显示的；video元素允许多个source元素，可以链接多个不同的视频文件（浏览器使用第一个可以识别的格式）； &lt;video&gt; &lt;source src=&quot;url&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt; &lt;video&gt;标签的属性 属性 值 说明 autoplay autoplay 视频在就绪后马上播放 controls controls 向用户显示播放，暂停，音量等控件 loop loop 播放后再次播放（循环） preload preload 在页面加载时进行加载，并与播放 ###HTML5``标签 相关用法同``基本相同 ###HTML5 拖放 1.设置元素为可拖放 `` 2.拖动什么 ondragstart和setData() ondragstart属性调用了一个函数，drag（event）规定了被拖动的数据 3.放到何处 ondraover规定在何处放置被拖动的数据 默认无法将数据/元素到其他元素中，若需要设置允许，必须阻止对元素的默认处理方式（通过调用ondragover事件的event.preventDefault（）方法） 4.进行放置 当放置被拖数据时，会发生drop事件 ondrop属性调用了一个函数drop（event） function drop(ev) { ev.preventDefault();&lt;!--调用preventDefault（）避免浏览器对数据的默认处理（drop事件的默认行为是以链接的形式打开）--&gt; var data=ev.dataTransfer.getData(&quot;Text&quot;);&lt;!--获得被拖的数据，该方法将返回在setData（）方法中设置为相同类型的任何数据--&gt; ev.target.appendChild(document.getElementById(data)); } 被拖数据是被拖元素的 id (“drag1”)把被拖元素追加到放置元素（目标元素）中###HTML5 Canvas用于在网页上绘制图形创建Canvas元素&lt;canvas id=&quot;mycanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;canvas元素本身是没有绘图能力的，所有工作在javascript内完成每个canvas元素都有一个对应的context对象（上下文对象），Canvas API定义在这个context对象上面，所以需要获取这个对象，方法是使用getContext方法。 12345var canvas = document.getElementById('myCanvas');//Javascript使用id寻找canvas元素if (canvas.getContext) { var cxt = canvas.getContext('2d');然后创建context对象&lt;br&gt;} Canvas APIstroke();//给线段着色fill();//填充（实心）cxt.fillStyle = &quot;#008600&quot;;//设置填充颜色 cxt.strokeStyle=&quot;yellow&quot;;//设置笔触颜色填充或画路径需要先闭合再画1.绘制线段 12345678cxt.moveTo(20,20);//设置起点坐标cxt.lineTo(20,200);//设置终点坐标cxt.lineTo(200,200);cxt.lineTo(200,20);cxt.lineWidth = 1.0; // 设置线宽cxt.strokeStyle = &quot;#CC0000&quot;; // 设置线的颜色cxt.closePath();//关闭路径，使用此方法可以将当前点到起点封闭起来，省去一步cxt.lineTo(20,20);cxt.stroke();//给线段着色 2.绘制圆形/扇形 1arc(x,y,r,startAngle, endAngle, anticlockwise);//(横坐标，纵坐标，半径，起始角度，结束角度，顺（false）/逆（true）时针) 3.绘制矩形 1rect(x,y,width,height);//(横坐标，纵坐标，长，宽) 4.文本 1234fillText(&quot;string&quot;,x,y);//(&quot;文本&quot;，横坐标，纵坐标)cxt.font = &quot;Bold 20px Arial&quot;; // 设置字体cxt.textAlign = &quot;left&quot;;// 设置对齐方式cxt.strokeText(&quot;Hello!&quot;, 10, 100); // 绘制空心字 5.图片chrome内核的浏览器不支持 123var img = new Image();img.src=&quot;image.jpg&quot;;cxt.drawImage(img,x,y);//（图像文件的DOM元素（即img标签），横坐标，纵坐标） 6.旋转 123456789//1.设置旋转环境cxt.save();cxt.restore();//2.重置（0,0）坐标点cxt.translate(x1,y1);//3.设置旋转角度 参数是弧度 （角度*Math.PI/180）cxt.rotate(-10*Math.PI/180);//4.画图//同1~5 7.练习： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;canvas width=&quot;1000&quot; height=&quot;1000&quot; style=&quot;background:blue&quot; id='canvas'&gt;您的浏览器不支持canvas画布&lt;/canvas&gt;&lt;script&gt;//获取画布 var canvas=document.getElementById('canvas'); if (canvas.getContext) { var cxt = canvas.getContext('2d'); }//画线段 cxt.beginPath();//开启路径 cxt.moveTo(20,20);//设置起点坐标 cxt.lineTo(20,200);//设置终点坐标 cxt.lineTo(200,200); cxt.lineTo(200,20); cxt.lineWidth = 1.0; // 设置线宽 cxt.strokeStyle = &quot;#CC0000&quot;; // 设置线的颜色 cxt.closePath();//关闭路径，使用此方法可以将当前点到起点封闭起来，省去一步cxt.lineTo(20,20); cxt.stroke();//给线段着色//画圆形 //画实心圆 cxt.beginPath(); cxt.arc(110,110,80,0,360,false);//ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); cxt.lineWidth = 10.0; // 设置线宽 cxt.strokeStyle=&quot;green&quot;; cxt.stroke(); cxt.fillStyle=&quot;yellow&quot;; cxt.fill(); cxt.closePath(); //画空心圆 cxt.beginPath(); cxt.arc(110,310,80,0,360,false);//ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); cxt.lineWidth = 1.0; // 设置线宽 cxt.strokeStyle=&quot;green&quot;; cxt.stroke(); cxt.closePath();//画矩形 //画空心矩形 cxt.beginPath(); cxt.rect(20,500,180,20); cxt.stroke(); cxt.closePath(); //画空心矩形的另一种方法 cxt.strokeRect(20,540,180,20); //画实心矩形 cxt.beginPath(); cxt.rect(20,580,180,20); cxt.fill(); cxt.closePath(); //画实心矩形的另一种方法 cxt.fillRect(20,620,180,20);//文字 //实心文字 cxt.font=(&quot;60px 宋体&quot;); cxt.fillText(&quot;Hello World&quot;,20,700); cxt.fill(); //空心文字 cxt.font=(&quot;60px 宋体&quot;); cxt.strokeStyle=&quot;yellow&quot;; cxt.strokeText(&quot;Hello World&quot;,20,800); cxt.stroke();//旋转//设置旋转环境 cxt.save(); //转换参考点 cxt.translate(20,20); //设置旋转角度 参数是弧度 角度*Math.PI/180 cxt.rotate(-10*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,0); cxt.lineTo(0,180); cxt.stroke(); cxt.closePath(); cxt.restore();&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 预览：源代码文件：点击下载###HTML5 内联SVGSVG是指可伸缩矢量图形 可通过文本编辑器创建/修改； SVG图像可以被搜索索引，脚本化或压缩； 可以伸缩； 可以高质量地打印语法：&lt;svg xmlns=&quot;url&quot; version=&quot;1.1&quot; height=&quot;100&quot;&gt;&lt;/svg&gt;继续学习： ###HTML5 地理位置 使用getCurrentPosition()方法获取用户的位置 若成功，则getCurrentPosition（）方法返回对象，始终会返回latitude，longitude以及accuracy属性 属性描述 coords.latitude十进制数的纬度 coords.longitude十进制数的经度 coords.accuracy位置精度 coords.altitude海拔 coords.altitudeAccuracy位置的海拔精度 coords.heading方向，以正北开始以读 coords.speed速度，以米/秒计 timestamp响应的日期和时间 Getlocation（）对象 watchPosition（） 返回用户当前位置，并继续返回用户移动时的更新位置 clearWatch（） 停止watchPosition（）方法","link":"/2014/07/16/2014_07_16_learn_html5_no4/"},{"title":"修改Fuubo尾巴","text":"##1.下载下载所需要的工具1.Fuubo客户端2.ApkIDE（Apk改之理）谢谢小米人 XIAOMIREN.NET的分享3.新浪微博尾巴appkey（文后）4.打包后的工具（ 密码: uwxo）##2.配置环境先配置系统java环境并添加到ApkIDE（略）##3.反编译使用ApkIDE打开Fuubo.apk文件，软件会自动进行反编译 ##4.修改文件在左下角进入smali\\me\\imid\\fuubo\\ui\\LoginActivity.smali这个文件并进行修改将图片中红色字体部分（即Fuubo的尾巴以及appkey）修改为所需要的尾巴的appkey##5.保存编译保存后进行编译生成apk文件（菜单栏第三个）##6.提取文件用压缩软件将上一步生成的apk文件打开，将其中的classes.dex文件提取出来，然后放入原版的Fuubo客户端中覆盖使用也就是说上面所做的所有工作都是为了拿到这个classes.dex文件然后将其取代原版的文件##7.进行签名用Apk上上签对我们修改过classes.dex文件的Fuubo.apk进行签名（使用方法很简单）最后附上一个appkeyGoogle.Nexus5App Key：1737571893App Secret：dd9234b12ea7c0c46849b69c220924f3来自百度Nexus5吧吧友linux_0922的分享，若有侵犯请联系我删除更多appkey请自行Google本文借鉴了@不给力的面条 学长的博客","link":"/2014/08/19/2014_08_19_change_Fuubo/"},{"title":"Canvas标签例子","text":"# Canvas标签例子 # 这是几个在网上找到的几个例子，学着做了一下 这几个例子都是使用Canvas标签和javascript写成的 ~~***这一句话没有意义,为的只是把主页面博文的简介去掉很多很多很多很多很多很多的1234567891011121314啊尼玛，谁能教我应该怎么办？万分感谢T^T***~~ 现在懂了，只需要加上``这个标签就好了 ##时钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!doctype html&gt;&lt;html&gt;&lt;title&gt;clock&lt;/title&gt;&lt;body&gt;&lt;canvas id=&quot;clock&quot; width=&quot;500&quot; height=&quot;500&quot; &gt;&lt;/canvas&gt;&lt;script&gt; var clock=document.getElementById('clock');//Javascript使用id寻找canvas元素 var cxt=clock.getContext('2d');//然后创建context对象&lt;br&gt; function makeclock() { cxt.clearRect(0,0,500,500);//删除画布的所有内容 var time=new Date();//定义一个函数 time，获取当前时间 var hour=time.getHours(); var minute=time.getMinutes(); var second=time.getSeconds(); hour=hour+minute/60+second/3600;//为了使时针指在刻度中间 hour=hour&gt;12?hour-12:hour;//将24小时制换算为12小时制 //画表盘 cxt.strokeStyle=&quot;blue&quot;;//设置表盘颜色为蓝色 cxt.lineWidth=10;//设置宽度为10 cxt.beginPath(); cxt.arc(250,250,200,0,360,false); cxt.closePath(); cxt.stroke(); cxt.fillStyle=&quot;yellow&quot;; cxt.fill(); //时针刻度 for(var i=0;i&lt;12;i++) { cxt.save(); cxt.lineWidth=10; cxt.strokeStyle=&quot;#000&quot;; cxt.translate(250,250); cxt.rotate(i*30*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-190); cxt.lineTo(0,-170); cxt.closePath(); cxt.stroke(); cxt.restore();//translate（）；rotate（）；函数要在beginPath（）；之前定义 } //分针刻度 for(var i=0;i&lt;60;i++) { cxt.save(); cxt.lineWidth=7; cxt.strokeStyle=&quot;black&quot;; cxt.translate(250,250); cxt.rotate(i*6*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-190); cxt.lineTo(0,-180); cxt.closePath(); cxt.stroke(); cxt.restore(); } //画时针 cxt.save(); cxt.lineWidth=10; cxt.translate(250,250); cxt.rotate(hour*30*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-120); cxt.lineTo(0,10); cxt.closePath(); cxt.strokeStyle=&quot;black&quot;; cxt.stroke(); cxt.restore(); //画分针 cxt.save(); cxt.lineWidth=6; cxt.translate(250,250); cxt.rotate(minute*6*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-160); cxt.lineTo(0,10); cxt.closePath(); cxt.strokeStyle=&quot;black&quot;; cxt.stroke(); cxt.restore(); //画秒针 cxt.save(); cxt.lineWidth=3; cxt.translate(250,250); cxt.rotate(second*6*Math.PI/180); cxt.beginPath(); cxt.moveTo(0,-185); cxt.lineTo(0,15); cxt.closePath(); cxt.strokeStyle=&quot;red&quot;; cxt.stroke(); //画中心圆 cxt.beginPath(); cxt.arc(0,0,5,0,360,false); cxt.closePath(); cxt.fillStyle=&quot;gray&quot;; cxt.fill(); cxt.strokeStyle=&quot;red&quot;; cxt.stroke(); //画秒针的圆 cxt.beginPath(); cxt.arc(0,-160,5,0,360,false); cxt.closePath(); cxt.strokeStyle=&quot;red&quot;; cxt.stroke(); cxt.fill(); cxt.restore(); }makeclock();//避免第一次刷新时空白，先画一遍时钟setInterval(makeclock,1000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图如下： ![时钟](https://ooo.0o0.ooo/2017/01/07/5870e2030ee88.jpg) 点击下载源代码 ##地球公转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;canvas width=&quot;1000&quot; height=&quot;1000&quot; Style=&quot;background:black&quot; id=&quot;canvas&quot;&gt;您的浏览器不支持Canvas标签&lt;/canvas&gt; &lt;script&gt; var canvas=document.getElementById('canvas');//单引号 var cxt=canvas.getContext('2d'); var time=0; function sun() { cxt.clearRect(0,0,1000,1000); //画地球轨迹 cxt.beginPath(); cxt.arc(500,500,100,0,360,false); cxt.closePath(); cxt.strokeStyle=&quot;white&quot;; cxt.lineWidth=&quot;2&quot;; cxt.stroke(); //画太阳 cxt.beginPath(); cxt.arc(500,500,20,0,360,false); cxt.closePath(); //填充太阳的颜色 var suncolor=cxt.createRadialGradient(500,500,0,500,500,20); suncolor.addColorStop(0,&quot;#f00&quot;); suncolor.addColorStop(1,&quot;#f90&quot;); cxt.fillStyle=suncolor; cxt.fill(); //画地球 cxt.save(); cxt.translate(500,500); cxt.rotate(time*365/360*Math.PI/180); cxt.beginPath(); cxt.arc(0,100,10,0,360,false); cxt.closePath(); //填充地球颜色 var earthcolor=cxt.createRadialGradient(0,100,0,0,100,10); earthcolor.addColorStop(0,&quot;#78B1E8&quot;); earthcolor.addColorStop(1,&quot;#050C12&quot;); cxt.fillStyle=earthcolor; cxt.fill(); cxt.restore(); time+=1; } //让地球动起来 setInterval(sun,10); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果图如下： ![地球公转](https://ooo.0o0.ooo/2017/01/07/5870e2472286f.jpg) 点击下载源代码 ##太阳系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!doctype html&gt;&lt;html&gt; &lt;title&gt;太阳系&lt;/title&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;1000&quot; height=&quot;1000&quot; style=&quot;background:black&quot;&gt;您的浏览器不支持Canvas标签&lt;/canvas&gt; &lt;script&gt; var cxt=document.getElementById('canvas').getContext('2d'); //画轨道 function drawTrack() { for(var i=1;i&lt;9;i++) { cxt.beginPath(); cxt.arc(500,500,i*50,0,360,false); cxt.closePath(); cxt.strokeStyle=&quot;#fff&quot;; cxt.stroke(); } } drawTrack(); //画星球 function Star(x,y,r,cycle,lightcolor,darkcolor) { this.x=x; this.y=y; this.r=r; this.lightcolor=lightcolor; this.darkcolor=darkcolor; this.cycle=cycle; this.time=0; this.color=null; this.draw=function() { cxt.save(); cxt.translate(500,500); cxt.rotate(this.time*(360/this.cycle)*Math.PI/180); cxt.beginPath(); cxt.arc(this.x,this.y,this.r,0,360,false); cxt.closePath(); this.color=cxt.createRadialGradient(this.x,this.y,0,this.x,this.y,this.r); this.color.addColorStop(0,this.lightcolor); this.color.addColorStop(1,this.darkcolor); cxt.fillStyle=this.color; cxt.fill(); cxt.restore(); this.time+=1; } } function Sun() { Star.call(this,0,0,20,0,&quot;#F00&quot;,&quot;#f90&quot;); } function Mercury() { Star.call(this,0,50,10,87.70,&quot;#A69697&quot;,&quot;#5C3E40&quot;); } function Venus() { Star.call(this,0,100,10,224.701,&quot;#C4BBAC&quot;,&quot;#1F1315&quot;); } function Earth() { Star.call(this,0,150,10,365.2422,&quot;#78B1E8&quot;,&quot;#050C12&quot;); } function Mars() { Star.call(this,0,200,10,686.98,&quot;#CEC9B6&quot;,&quot;#76422D&quot;); } function Jupiter() { Star.call(this,0,250,10,4332.589,&quot;#C0A48E&quot;,&quot;#322222&quot;); } function Saturn() { Star.call(this,0,300,10,10759.5,&quot;#F7F9E3&quot;,&quot;#5C4533&quot;); } function Uranus() { Star.call(this,0,350,10,30799.095,&quot;#A7E1E5&quot;,&quot;#19243A&quot;); } function Neptune() { Star.call(this,0,400,10,164.8*365,&quot;#0661B2&quot;,&quot;#1E3B73&quot;); } var sun=new Sun(); var mercury=new Mercury(); var venus=new Venus(); var earth=new Earth(); var mars=new Mars(); var jupiter=new Jupiter(); var saturn=new Saturn(); var uranus=new Uranus(); var neptune=new Neptune(); function move() { cxt.clearRect(0,0,1000,1000); drawTrack(); sun.draw(); mercury.draw(); venus.draw(); earth.draw(); mars.draw(); jupiter.draw(); saturn.draw(); uranus.draw(); neptune.draw(); } setInterval(move,10); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 效果图如下： ![太阳系](https://ooo.0o0.ooo/2017/01/07/5870e247112e6.jpg) 点击下载源代码","link":"/2014/07/25/2014_07_25_canvas_example/"},{"title":"课程设计实训——Android app开发","text":"这两个星期是我们专业的“服务外包实训”，说的好听就是和中兴合作搞的实训，其实说白了就是实验周，第一天去中兴南京研发中心参观，下午在研发大楼上了半天课，分了小组分了课题，我们组做的是学生信息管理系统。这两个星期来虽然没有多大的收获，但是至少学到了一些东西，知道了自己的不足之处，自己还是比较喜欢Android的，趁着这个机会继续学习Android，去图书馆借几本书，自己多多实践吧，加油，不要像暑假一样。。。半途而废了总结一下经验吧： 实验环境搭建就花了两天的时间，还好之前就有点基础所以知道怎么配环境变量，自己也有梯子所以全靠网速，队友的环境没有梯子搭了很久。。 没有合理分配好时间还有精力，导致最后的结果没有实现要求中的导入文件功能，虽然大多数也不是我们自己写的（捂脸 还是要学下数据库 实验报告就不上传了，主要是设计文档和我们老师要求的一些东西，答辩用的PPT是用别人之前分享的PPT模板修改的点击下载：源代码答辩PPT","link":"/2014/11/27/2014_11_27_android_train/"},{"title":"Android5.0上实现小米手环解锁","text":"今天下午小米手环更新了1.1.861版本，新版本特新如下：而这其中最让我兴奋的是一点 增加对安卓5.0设备解锁的支持 于是我赶紧更新小米手环的App（下载地址)升级手环固件! 准备工作搞定，现在开始进入正题 第一 在“系统设置-安全”中设定屏幕解锁方式（密码、图案）都可以第二 打开小米手环App，点击右上角的三个点（菜单键） “···” 选择“我的设备”第三 点击“屏幕解锁功能”，跳转到另一个界面，点击“进入设置”，之后手环会自动进行配对，通知栏会出现一把小锁第四 配对完成后返回“系统设置-安全”，点击Smart Lock输入原来设定的密码或者图案，在“信任的设备”中选择我们的小米手环。第五 OK，All is Done！ 我们就可以愉快地用手环解 （Zhuang） 锁 （Bi） 了PS.有些同学可能找不到Smart Lock这个选项，要先在“系统设置-安全-信任的代理程序”中把Google service 的Smart Lock功能打开。下面是我的解（Zhuang）锁（Bi）截图手环在手上时，屏幕下方会有一个开着的小锁：手环不在手上时候，屏幕下方会有一个关着的小锁：(我测试的时候手环距离手机大概有6，7米的样子)欢迎转载，转载请注明源地址：http://tingya.github.io/2014/12/01/mi-band/","link":"/2014/12/01/2014_12_01_mi_band/"},{"title":"hexo优化--向Google提交sitemap","text":"Step 1安装 sitemap 到本地 npm install hexo-generator-sitemap Step 2在/hexo/_config.yml(Hexo根目录)下编辑，添加以下代码： plugins: - hexo-generator-sitemap Step 3将文件部署到 Github 上 hexo g hexo d Step 4访问 域名.sitemap就可以看到站点地图，如下图所示 Step 5向 Google 提交你的主页用你的 Google 账号登陆 Google 网站管理中心(自备梯子)点击添加网站并输入你的主页，点击继续 Step 6这里可以使用 Google 提供的多种方法进行验证，我使用的是备用方法中的HTML标记 Step 7复制 Google 提供的一行代码&lt;meta name=&quot;google-site-verification&quot; content=&quot;**********&quot; /&gt;，将其添加到Hexo\\themes\\jacman\\layout\\_partial\\head.ejs中&lt;head&gt; &lt;/head&gt;之间，如下图所示 Step 8部署到 Github 上 hexo g hexo d Step 9点击 Step 6 图中的**验证** Step 10打开 Google 站长工具在站点地图中添加你刚刚在 Step 4 中已经生成的站点地图，并点击提交 Step 11等提交完毕之后就大功告成了，你会看到如下的界面 欢迎转载，转载请注明源地址：https://ppting.me/2015/01/25/sitemap/本文参考Fiona’s Blog &amp; zippera’s Blog","link":"/2015/01/25/2015_01_25_sitemap/"},{"title":"同时将博客部署在Github和Gitcafe上，并通过DNSPOD分流","text":"##修改根目录下的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式 &gt;deploy: type: git message: [message] repo: github: ,[branch] gitcafe: ,[branch]例如我的文件如下： 只需要将自己在Github和Gitcafe上的git写进去就好了##接着就hexo clean hexo g hexo d一系列命令但有可能遇到 &gt;remote part of refspec is not a valid name in master:[gitcafe-pages]这样的错误报告，不需要输入密码就直接跳过不能Push到Github和Gitcafe上的情况##放大招哈哈哈，下面就让我们来放大招吧！ 将根目录下的.deploy文件夹删除！对没错就是删除（当然我建议你先备份一下再删除，要是这招不管用搞坏了您别怪我） 然后重新执行一遍hexo clean hexo g hexo d一系列命令,就会出现下面熟悉的界面了Hoooo ##输入密码 分别输入Github和Gitcafe的密码，就会同时部署到Github和Gitcafe上去啦（听说还有可以添加私钥的方法可以省去输入密码的方法，待我再来研究看看）#通过DNSPOD分流因为国内访问Github有点慢，原因多多了不需多讲所以可以通过DNSPOD设置不同的路线访问不同的网站即 设置默访问 GitHub 设置电信、联通、教育网访问 GitCafe 可以参考我的设置如下：本文参考资料：把Hexo同时部署到GitHub和GitCafeSandy’s Blog同时使用 GitHub 与 GitCafe 托管博客Hexo 同时支持Github和Gitcafe同时部署到github与gitcafe时，只能够成功一个 #893Hexo多Repo部署——使用Github和GitCafe同时托管博客同时部署博客到GitHub/GitCafe","link":"/2015/02/08/2015_02_08_gitcafe/"},{"title":"修改 jacman 主题颜色","text":"今天在群里看到大家在讨论，看到了一个博客，使用了暗色的主题，我看了一下就被吸引了，觉得暗色看起来比较舒服，于是就把自己的博客的所有颜色都换了一下，顺便把jacman主题中的颜色配置（路径是**themes\\jacman\\source\\css\\_base\\variable.styl**）都写了出来，方便大家以后自行修改，以下是我现在博客的颜色配置 1234567891011121314151617181920212223//Colorcolor-background = #242424 //文章以外的背景颜色color-content = #FFFFFF //文章字体颜色color-font = #ffffff //各个标签字体颜色以及友链,微博分享等的图标颜色color-white = #ffffff //导航栏字体颜色，右侧RSS订阅，底栏字体已经个人信息图标颜色color-blue = #9C27B0 //标题字体颜色，包括超链接&lt;a&gt;&lt;/a&gt; 以及作者名字，右侧主标签（分类，标签，友链）颜色color-orange = #ea6753 //标题鼠标移到标题等部分color-blue处后颜色color-theme = #222222 //主题背景颜色color-font-nav = #727272 //导航栏鼠标移至后的颜色color-section = #363636 //文章的背景颜色color-footer = #252525 //页面最下方的背景颜色color-gray = #000000 //分割线的颜色，以及标签的底色color-meta = #808080 //图片信息字体颜色color-heading = #ffffff //部分字体颜色 ##号字体color-quote = #4B4B4B //四个空格后的代码块背景颜色color-code = #eee //``之间的代码背景颜色color-twitter = #00aced //分享至Twitter处 鼠标移至后的颜色color-facebook = #3b5998 //分享处 鼠标移至后的颜色color-weibo = #c64d3e //分享处 鼠标移至后的颜色color-google = #dd4b39color-qrcode= #49ae0fcolor-renren= #369 //分享处 鼠标移至后的颜色color-top = #762c54","link":"/2015/01/26/2015_01_26_change_jacman_theme/"},{"title":"Github学生包注册域名","text":"今天用Github的学生包上提供的namecheap提供的一年免费域名（原价8.99美元/年）注册了这个我一直想要注册的域名–&gt;ppting.me###领取条件这个就不多说了，国内的edu邮箱也是可以申请的Github学生包的，不过我申请了一个月还没有得到批准，就一直发邮件给客服催催催，到后面就给我批下来了，edu邮件加上学生证应该就可以了 ###注册namespace在Github学生包中的namecheap处点击申请，虽然说是免费的（一年的.me域名），但还是要和付费的一样一步一步来呀。搜索.me域名，买买买 别怕，免费的啦,然后验证edu邮箱，注册，Done！一路下来还是很简单的，具体步骤可以看这里 然后打开namecheap官网后登陆就发现我们的域名已经注册完成了啦！！！可喜可贺 ###注册dnspod注册过程也是很简单的说。。看着就懂了然后在域名管理中如下图一样设置 A A的两个记录值是指向Github Pages的IP地址分别为：192.30.252.153192.30.252.154如果有一天不能打开Blog，请及时查看Github Pages的IP并进行修改 CANME CANME的记录值是我们在Github上的仓库，即tingya.github.io这种方式需要我们在Hexo的source文件加下添加一个命名为CANME无后缀的文件，在文件中写入我们的域名，例如ppting.me，如果想以www.ppting.me的形式访问，则可以在文件中写入www.ppting.me，也可以采用下面的方法在域名管理中主机记录修改为www @是指直接以ppting.me的形式访问博客www是指以www.ppting.me的形式访问博客这是我个人的理解不知道对不对 ###修改namecheap的DNS服务商点击这里并登陆namecheap进行修改点击进入需要修改DNS的域名，在左边的界面中选择Transfer DNS to Webhost，接着在右侧下方的输入框中输入f1g1ns1.dnspod.netf1g1ns2.dnspod.net添加后保存具体可以参考官方的文档–&gt; 看这里啦不要往别的地方看按照官方的说法 新修改域名DNS指向DNSPod的DNS域名，虽DNSPod服务器的生效时间是实时的，但因各地ISP服务商刷新域名DNS的时间不一致，所以导致解析在全球生效一般需要0–72小时哦，请您耐心的等待~~ So ~ 慢慢等吧，我修改了以后在移动端就能打开ppting.me这个域名了，但是在PC端还是会被解析到http://about.me 我也不知道为什么。求解释求帮助","link":"/2015/02/07/2015_02_07_apply_domains/"},{"title":"Android Eclipse 实验环境搭建","text":"##Java环境（配置jdk 下载JDK（windows X86 or X64）； 安装JDK到电脑中，不修改任何路径； 配置环境变量； 找到JDK安装目录下的bin 目录的路径并复制； 右击“计算机”打开属性，并按照下图操作，将bin的路径添加到PATH 的变量值中，注意在路径后面加上英文字符的分号”;”例如:C:\\Program Files\\Java\\jdk1.8.0_25\\bin; 打开 win+R，输入cmd 运行，试运行javac，应该是有下图出现 ##2.下载ADT（包含SDK和Eclipse； 下载地址：http://developer.android.com/sdk/index.html （请自备梯子 下载完毕解压，打开文件夹内的SDK manager 下载所需要的SDK（请自备梯子 ##完毕~~可以愉快地coding了","link":"/2015/02/09/2015_02_09_build_android_environment_in_windows/"},{"title":"git学习笔记","text":"终于了解了一下git的使用，也知道了怎样使用git将本地的文件传到github上大多数是从廖雪峰到官方网站－Git教程和git-简易指南这里学习到的，下面记录一下自己的笔记吧 1.命令行 git init //将当前目录变成git可以管理的仓库 git add * //用命令告诉git本地添加了文件 git commit -m &quot;description&quot; //将文件添加到仓库，并加以描述 git status //查看 git remote add origin git@github.com:username/repository.git //连接到远程github的仓库 git push -u origin master //将本地目录中的所有文件都push到远程仓库中（第一次）以后就可以使用“git push origin master” git push -u origin gh-pages //git到分支 2.如果是直接fork他人的仓库需先fork他人的仓库，然后在本地git clone 自己的仓库.git后，在本地进行修改，再执行以上命令（不需要git init和git remote add origin git@github.com:username/repository.git）即可 3.如果是在本地建立一个目录并想上传到github上，需要执行以上所有命令 4.版本回滚 123456git log //打印git提交历史git reflog //查看命令历史git reset --hard cb926e7ea50ad11b8f9e909c05226233bf755030 //回滚到这个commit或者git reset --hard HEAD^ `*HEAD* 表示当前版本，HEAD^表示上一个版本 HEAD^^表示上上个版本，HEAD~100 表示往上100个版本` git reset –soft | –mixed| –hard–mixed 会保留源码,只是将git commit和index 信息回退到了某个版本.–soft 保留源码,只回退到commit 信息到某个版本.不涉及index的回退,如果还需要提交,直接commit即可.–hard 源码也会回退到某个版本,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)","link":"/2015/03/08/2015_03_08_use_git_tips/"},{"title":"足记 像电影般生活着","text":"Live like a movie这几天朋友圈微博到处都充满了大片一般的照片，刨根问底是“足记”这个App 这几天我也尝试着使用了一下“足记”，写几点自己的感受吧我第一次看到“大片般的照片”是在朋友圈，我就在好奇，咦，难道有哪一部电影有这一帧和字幕是这样的吗？图文这么相配而后就发现足记这个app 足记的定位是什么我原以为足记是一个美图的app，打开以后才发现不是我想象中那样的，却发现，哇这和ins怎么这么相似足记最初的定位是做“推荐电影取景地”，你可以在“发现”中寻找到很多电影的取景地，然后可以看到这些取景地的详细资料比如经纬度，取景地的介绍，你可以看到你同取景地的距离，也可以在下面评论和网友一起交流这个地点 但实际上呢？我想很多人只是每次想在朋友圈微博发照片的时候就打开这个App，用来把自己的照片裁剪加滤镜加字幕，就像电影的某一帧一样 足记需求分析就我而言，我为什么会使用这个App呢？ zhuangbiliti 我想很多人使用这个App都是因为在朋友圈或者微博看到了很多“大片即视感”的照片吧，然后就想，咦这些照片都是怎么做出来的呢，我也能用来装装逼呀。于是乎，足记的用户量就蹭蹭的往上涨了 与其他app的对比和Instagram相同的是，足记是一个以照片浏览为重点的app，而这正是Instagram的表现形式，不同的是，ins是好友之间的分享，而足记确是以热门推荐加好友分享的方式，在主屏上给你推送热门的照片，而这或许就是用来打发时间的一个好契机吧？ 下一步足记该怎么做引导用户从“zhuangbility”到乐于分享才是最重要的吧把用户留在足记而不是让用户只是把足记作为一个加特效的工具，让用户乐于在足记中分享自己的照片，产生对这个应用的依赖性，把自己的特别之处做的更好，就像“大片”般效果这个特色，把照片的质量变得更高，因为很多时候裁剪过后加了“大片”特效的照片就变得不是特别清晰了做好用户体验，好像足记火起来的这几天服务器被挤爆了吧。。。？应用的UI和交互其实看起来觉得有点难以理解可以以话题的形式征集照片，让用户分享在足记上，分享同该话题有关的图片，大家一起晒照片，晒晒自己的书桌晒晒自己的旅途“飞呀”这个功能其实有点重复也有点鸡肋，在“发现”中其实可以看到附近的取景地或者景点了，所以并没有必要把这个功能单独拿出来做，或者可以把这个功能并入“个人”中，以地图的形式，把用户去过的地点插上“小红旗” 让用户产生一种每当到了一个地方就会打开足记标记一下自己到了这个地点给自己插上“小红旗” 就像~发微博的时候加上定位发朋友圈的时候加上定位一样，分享给好友我来过这里我在这里 其他以上都是我自己的一点思考和胡思乱想，很久之前写的了，一直不敢发上来怕被别人笑话，但是我想，如果没有别人的笑话和批评指正又哪里来的进步呢？希望有人能对我提出宝贵的意见，欢迎和我交流。","link":"/2015/03/19/2015_03_19_zuji_live_as_a_moive/"},{"title":"Nexus5刷机命令记录","text":"mark记录下免得下次又忘了 首先用电源键+音量下 或者 adb reboot bootloader进入Fastboot模式 将整个刷机镜像包解压，并将压缩包里面的另一个压缩包解压并将其中的所有.img文件复制到根目录下 用命令行进入该根目录 fastboot device 查看手机是否已经和电脑连接好了如果连接好了会出现下图所示的一行命令 adb reboot bootloader 重启至bootloader adb sideload XXXXX.zip 先进入recovery 然后按电源键 和 音量+ 选择 Apply update from adb fastboot flash bootloader bootloader-XXXXXXX.img 刷入bootloader-XXXXXXX文件 fastboot flash radio radio-XXXXXXX.img 刷入基带文件（因为我不想刷入该基带所以我没有刷入） fastboot reboot-bootloader 刷入成功后重启bootloader进入fastboot模式 fastboot flash recovery recovery.img 刷入recovery文件（我没有刷入，后面自己刷入了TWRP） fastboot flash boot boot.img 刷入内核 fastboot flash system system.img 刷入系统文件 下面两步刷入会清除数据我不想清除数据所以没有刷入 fastboot flash cache cache.img fastboot flash userdata userdata.img fastboot reboot 重启手机等待优化升级大功告成 ##其他命令 fastboot oem unlock解锁 fastboot oem lock重新上锁","link":"/2015/05/21/2015_05_21_nexus_fastboot/"},{"title":"Android程序设计—RunMan","text":"##百度地图key申请1.先到百度LBS开放平台注册2.到这里申请密钥 key 其中在 Mac 版本的 Android Studio 获取sha1的方法如下 cd .Android keytool -list -v -keystore debug.keystore 其中默认密码是android如下图所示 ##配置开发环境（百度地图SDK官方文档）###第一步：在工程app/libs目录下放入baidumapapi_vX_X_X.jar包,在src/main/目录下新建jniLibs目录，放入libBaiduMapSDK_vX_X_X_X.so如下图所示，注意jar和so的前3位版本号必须一致，并且保证使用一次下载的文件夹中的两个文件，不能不同功能组件的jar或so交叉使用。 ###第二步：导入jar包。菜单栏选择File-&gt;Project Structor-&gt;Modules-&gt;Dependencies,点击+号，选择File dependency，选择jar包导入。 通过以上两步操作后，您就可以正常使用百度地图SDK为您提供的全部功能了。##修改当前定位图标 在初始化定位中初始化定位图标 1mIconLocation = BitmapDescriptorFactory.fromResource(R.mipmap.navi_map_gps_locked); 在监听类中显示图标 12MyLocationConfiguration config = new MyLocationConfiguration(MyLocationConfiguration.LocationMode.NORMAL,true,mIconLocation);mBaiduMap.setMyLocationConfigeration(config); ##将地图定位到当前位置 123456private void centerToMyLocation() { LatLng latLng = new LatLng(mLatitude, mLongtitude); MapStatusUpdate msu = MapStatusUpdateFactory.newLatLng(latLng); mBaiduMap.animateMapStatus(msu); } ##定位初始化定位并设置监听类实时刷新GPS坐标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private void initLocation() { mlocationClient=new LocationClient(this); myLocationListener=new MyLocationListener(); mlocationClient.registerLocationListener(myLocationListener);//进行注册 //设置定位的相关设置 LocationClientOption option=new LocationClientOption(); option.setCoorType(&quot;bd09ll&quot;);//定位SDK可以返回bd09、bd09ll、gcj02三种类型坐标，若需要将定位点的位置 // 通过百度Android地图SDK进行地图展示，请返回bd09ll，将无偏差的叠加在百度地图上。 option.setIsNeedAddress(true); option.setOpenGps(true);//打开GPS option.setScanSpan(1000);//一秒钟刷新一次 mlocationClient.setLocOption(option); //初始化定位图标 mIconLocation = BitmapDescriptorFactory.fromResource(R.mipmap.navi_map_gps_locked);//不是drawable //方向传感器相关 myOrientationListener = new MyOrientationListener(context); myOrientationListener.setmOrientationListener(new MyOrientationListener.OnOrientationListener() { @Override public void OnOrientationChange(float x) { mCurrentX = x; } }); } //全局点坐标 private class MyLocationListener implements BDLocationListener { @Override public void onReceiveLocation(BDLocation location) { LatLng curLatlng = new LatLng(location.getLatitude(),location.getLongitude()); MyLocationData data=new MyLocationData.Builder()// .direction(mCurrentX)//方向 .accuracy(location.getRadius())// .latitude(location.getLatitude())//经纬度 .longitude(location.getLongitude())//经纬度 .build(); mBaiduMap.setMyLocationData(data); //自定义图标 MyLocationConfiguration config = new MyLocationConfiguration(MyLocationConfiguration.LocationMode.NORMAL,true,mIconLocation); mBaiduMap.setMyLocationConfigeration(config); //更新经纬度 mLatitude=location.getLatitude(); mLongtitude=location.getLongitude(); if(isFirstIn) { mPoint=curLatlng;//将取得的值赋予mPoint //设置经纬度 //LatLng latLng =new LatLng(location.getLatitude(),location.getLongitude()); //设置地图中心点 MapStatusUpdate msu= MapStatusUpdateFactory.newLatLng(mPoint); mBaiduMap.setMapStatus(msu); //mBaiduMap.animateMapStatus(mus); isFirstIn=false; Toast.makeText(context,location.getAddrStr(),Toast.LENGTH_LONG).show(); } else { LatLng lastPoint = new LatLng(mLatitude, mLongtitude);//得到当前点 //画折线 List&lt;LatLng&gt; points = new ArrayList&lt;LatLng&gt;(); points.add(lastPoint); points.add(mPoint); //折线属性 OverlayOptions ooPolyline = new PolylineOptions().width(10) .color(0xAAFF0000).points(points); mBaiduMap.addOverlay(ooPolyline); mPoint=lastPoint; } } } ##绘制运动轨迹1.先设置一个全局的点A，设为空2.然后再第一次定位时的点设为B，将获取到的坐标赋值给A 3.随着监听类的刷新，每次获取一个点C4.连接AC5.将C赋值给A （A=C）每隔一个刷新时间重复3~5进行连续绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108if(isFirstIn) { mFirstPoint=curLatlng;//将取得的值赋予mPoint //设置经纬度 //LatLng latLng =new LatLng(location.getLatitude(),location.getLongitude()); //设置地图中心点 MapStatusUpdate msu= MapStatusUpdateFactory.newLatLng(mFirstPoint); mBaiduMap.setMapStatus(msu); //mBaiduMap.animateMapStatus(mus); isFirstIn=false; Toast.makeText(context, location.getAddrStr(), android.widget.Toast.LENGTH_LONG).show(); Log.d(&quot;第一次进入&quot;, &quot;进行定位&quot;); } else { if(isStarttag)//starttag用来点击开始按钮开始记录 { if (isStartPoint) {//打印第一个点 // 2015.6.14 修改mPoint=curLatlng 为 mFirstPoint mFirstPoint = curLatlng;//获取当前点 //添加起点标志物开始 //回到中心点开始 //MapStatusUpdate startPoint = MapStatusUpdateFactory.newLatLng(mPoint); //mBaiduMap.animateMapStatus(startPoint); //回到中心点结束 Log.d(&quot;打印&quot;, &quot;起始点mPoint&quot;); BitmapDescriptor bitmap = BitmapDescriptorFactory.fromResource(R.mipmap.starticon); OverlayOptions option = new MarkerOptions().position(mFirstPoint).icon(bitmap); mBaiduMap.addOverlay(option); //添加起点标志物结束 isStartPoint = false; } //if(isFirstFirstIn){mFirstPoint=curLatlng;isFirstFirstIn=false;} if (isContinueTag)//点击继续 { Log.d(&quot;继续&quot;, &quot;打点mFirstPoint&quot; + mFirstPoint); //重新开始 isStarttag=true; //isStartPoint = true; isPauseTag = false; isContinueTag = false; mFirstPoint=new LatLng(location.getLatitude(),location.getLongitude()); BitmapDescriptor bitmap = BitmapDescriptorFactory.fromResource(R.mipmap.starticon); OverlayOptions option = new MarkerOptions().position(mFirstPoint).icon(bitmap); mBaiduMap.addOverlay(option); } if(isPauseTag)//点击暂停 { if(isStopPause) { //点击暂停 LatLng mLastesPoint = new LatLng(location.getLatitude(), location.getLongitude()); //画标志 BitmapDescriptor bitmap = BitmapDescriptorFactory.fromResource(R.mipmap.starticon); //构建MarkerOption，用于在地图上添加Marker OverlayOptions option = new MarkerOptions().position(mLastesPoint).icon(bitmap); mBaiduMap.addOverlay(option); Log.d(&quot;打印&quot;, &quot;暂停点mLastesPoint&quot;); isStopPause=false; } //LatLng mFirstPoint = new com.baidu.mapapi.model.LatLng(location.getLatitude(),location.getLongitude()); }else { LatLng mNextPoint = new LatLng(location.getLatitude(), location.getLongitude());//得到当前点 if(DistanceUtil.getDistance(mFirstPoint,mNextPoint)&gt;50) { //判断当前点是否太远，舍去 }else { Log.d(&quot;mnextpoint&quot;, &quot;&quot; + mNextPoint); Log.d(&quot;mfirstpoint&quot;, &quot;&quot; + mFirstPoint); //画折线 List&lt;LatLng&gt; points = new ArrayList&lt;LatLng&gt;(); points.add(mNextPoint); points.add(mFirstPoint); //折线属性 OverlayOptions ooPolyline = new PolylineOptions().width(20) .color(0xAAFF0000).points(points); mBaiduMap.addOverlay(ooPolyline); //计算距离 double distances = DistanceUtil.getDistance(mFirstPoint, mNextPoint); sum = sum + distances; //sum=formatDouble(sum); Log.d(&quot;距离&quot;, &quot;&quot; + distances); Log.d(&quot;距离和&quot;, &quot;&quot; + sum); mFirstPoint = mNextPoint; } } if (isStopTag)//点击结束 { LatLng mLastesPoint = new LatLng(location.getLatitude(), location.getLongitude()); Log.d(&quot;打印&quot;, &quot;结束点&quot;); //画标志 BitmapDescriptor bitmap = BitmapDescriptorFactory.fromResource(R.mipmap.starticon); // 构建MarkerOption，用于在地图上添加Marker OverlayOptions option = new MarkerOptions().position(mLastesPoint).icon(bitmap); mBaiduMap.addOverlay(option); Log.d(&quot;结束&quot;, &quot;&quot; + mLastesPoint); mBaiduMap.setMyLocationEnabled(false);//停止定位 mlocationClient.stop(); myOrientationListener.stop(); } } } ##使用伪 Material Design 整个项目源码已经开源在Github上并记录了这阵子的功能以及Debug记录","link":"/2015/06/01/2015_06_01_runman_android/"},{"title":"Mac上配置Android adb以及sqlite3","text":"##配置Android adb环境 打开终端Terminal进入Home目录echo $HOME 创建.bash_profile文件touch .bash_profile 打开bash_profile文件open -e .bash_profile 键入该命令后会自动弹出文本编辑框 配置路径 export ANDROID_HOME=/Users/PPTing/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/tools export PATH=$PATH:$ANDROID_HOME/platform-tools 如下图所示 其中ANDROID_HOME后面的路径为本机SDK的路径，自己修改一下就好了 关闭并保存.bash_profile文件 更新环境变量source .bash_profile ##配置sqlite3（手机需要root权限）有些虚拟机或者真机中没有sqlite3，从拥有sqlite3的虚拟机中的/system/xbin/目录下提取出sqlite3(5.1) sqlite3(6.0) 用DDMS中从拥有sqlite3的虚拟机中导出sqlite3文件 连接手机，并用DDMS将上一步导出的sqlite3 导入手机的sdcard中 修改手机读写权限 mount -o rw,remount /system 将sdcard中的sqlite3 push到 /system/xbin中cat /mnt/sdcard/sqlite3 &gt; /system/xbin/sqlite3 修改权限chmod 4755 /system/xbin/sqlite3 大功告成 这时候敲入sqlite3发现已经不是 not found了","link":"/2015/07/27/2015_07_27_make_android_adb_path_in_Mac/"},{"title":"解析json数据","text":"解析从服务器返回的json数据这阵子在做一个天气预报的demo，使用百度天气的api获取json数据进行解析。json数据如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283{ &quot;error&quot;: 0, &quot;status&quot;: &quot;success&quot;, &quot;date&quot;: &quot;2015-10-01&quot;, &quot;results&quot;: [ { &quot;currentCity&quot;: &quot;nanjing&quot;, &quot;pm25&quot;: &quot;76&quot;, &quot;index&quot;: [ { &quot;title&quot;: &quot;穿衣&quot;, &quot;zs&quot;: &quot;舒适&quot;, &quot;tipt&quot;: &quot;穿衣指数&quot;, &quot;des&quot;: &quot;建议着长袖T恤、衬衫加单裤等服装。年老体弱者宜着针织长袖衬衫、马甲和长裤。&quot; }, { &quot;title&quot;: &quot;洗车&quot;, &quot;zs&quot;: &quot;较不宜&quot;, &quot;tipt&quot;: &quot;洗车指数&quot;, &quot;des&quot;: &quot;较不宜洗车，未来一天无雨，风力较大，如果执意擦洗汽车，要做好蒙上污垢的心理准备。&quot; }, { &quot;title&quot;: &quot;旅游&quot;, &quot;zs&quot;: &quot;适宜&quot;, &quot;tipt&quot;: &quot;旅游指数&quot;, &quot;des&quot;: &quot;天气较好，温度适宜，是个好天气哦。这样的天气适宜旅游，您可以尽情地享受大自然的风光。&quot; }, { &quot;title&quot;: &quot;感冒&quot;, &quot;zs&quot;: &quot;较易发&quot;, &quot;tipt&quot;: &quot;感冒指数&quot;, &quot;des&quot;: &quot;昼夜温差较大，较易发生感冒，请适当增减衣服。体质较弱的朋友请注意防护。&quot; }, { &quot;title&quot;: &quot;运动&quot;, &quot;zs&quot;: &quot;适宜&quot;, &quot;tipt&quot;: &quot;运动指数&quot;, &quot;des&quot;: &quot;天气较好，赶快投身大自然参与户外运动，尽情感受运动的快乐吧。&quot; }, { &quot;title&quot;: &quot;紫外线强度&quot;, &quot;zs&quot;: &quot;中等&quot;, &quot;tipt&quot;: &quot;紫外线强度指数&quot;, &quot;des&quot;: &quot;属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。&quot; } ], &quot;weather_data&quot;: [ { &quot;date&quot;: &quot;周四 10月01日 (实时：15℃)&quot;, &quot;dayPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/day/duoyun.png&quot;, &quot;nightPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/night/duoyun.png&quot;, &quot;weather&quot;: &quot;多云&quot;, &quot;wind&quot;: &quot;西北风4-5级&quot;, &quot;temperature&quot;: &quot;23 ~ 14℃&quot; }, { &quot;date&quot;: &quot;周五&quot;, &quot;dayPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/day/qing.png&quot;, &quot;nightPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/night/qing.png&quot;, &quot;weather&quot;: &quot;晴&quot;, &quot;wind&quot;: &quot;东南风微风&quot;, &quot;temperature&quot;: &quot;24 ~ 14℃&quot; }, { &quot;date&quot;: &quot;周六&quot;, &quot;dayPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/day/duoyun.png&quot;, &quot;nightPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/night/duoyun.png&quot;, &quot;weather&quot;: &quot;多云&quot;, &quot;wind&quot;: &quot;东风微风&quot;, &quot;temperature&quot;: &quot;24 ~ 17℃&quot; }, { &quot;date&quot;: &quot;周日&quot;, &quot;dayPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/day/yin.png&quot;, &quot;nightPictureUrl&quot;: &quot;http://api.map.baidu.com/images/weather/night/yin.png&quot;, &quot;weather&quot;: &quot;阴&quot;, &quot;wind&quot;: &quot;东风3-4级&quot;, &quot;temperature&quot;: &quot;24 ~ 19℃&quot; } ] } ]} 发送请求网络请求需要在非主线程中使用，避免拥塞 12345678910111213141516171819202122232425262728293031323334public void getWeatherInfo() { new Thread(new Runnable() { @Override public void run() { try { HttpClient httpClient = new DefaultHttpClient(); location = &quot;南京&quot;; url = &quot;http://api.map.baidu.com/telematics/v3/weather?location=&quot;+location+&quot;&amp;output=json&amp;ak=gVdU1hNhSplDXKmdLtoRvK0O&quot;; HttpGet httpGet = new HttpGet(url); HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode()==200) { Log.d(TAG,&quot;服务器返回的代码为 &quot;+httpResponse.getStatusLine().getStatusCode()); Log.d(TAG,&quot;获取json成功&quot;); HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, &quot;UTF-8&quot;); //调用解析 Log.d(TAG,&quot;获取到的数据 &quot;+response); //创建对象调用解析方法 ParseJson parseJson = new ParseJson(); parseJson.parseJsonWithGson(response); parseJson.parseJson(response); } } catch (Exception e) {e.printStackTrace();} } }).start(); } 解析数据使用原生先获取三个对象，error、status和date再通过数组遍历results中的对象，以此类推将数组中的所有数据取出 123456789101112131415161718192021222324252627282930313233public void parseJson(String jsonData) { try { Log.d(TAG,&quot;解析json数据&quot;); JSONObject jsonObject = new JSONObject(jsonData); Log.d(TAG,&quot;error is &quot;+jsonObject.get(&quot;error&quot;)); Log.d(TAG,&quot;status is &quot;+jsonObject.get(&quot;status&quot;)); Log.d(TAG,&quot;date is &quot;+jsonObject.get(&quot;date&quot;)); //找到今天的日期 String strGetDate = jsonObject.get(&quot;date&quot;).toString(); String regExGetDate = &quot;(\\\\d{4})-(\\\\d{2})-(\\\\d{2})&quot;; Pattern patternGetDate = Pattern.compile(regExGetDate); Matcher matcherGetDate = patternGetDate.matcher(strGetDate); boolean isFindDate = matcherGetDate.find(); final String date = matcherGetDate.group(); Log.d(TAG,&quot;是否找到日期 &quot;+isFindDate); Log.d(TAG,&quot;今天日期是 &quot;+date); JSONArray resultsJsonArray = jsonObject.getJSONArray(&quot;results&quot;);//遍历results for (int i = 0;i&lt;resultsJsonArray.length();i++) { org.json.JSONObject jsonObjectInResults = resultsJsonArray.getJSONObject(i); Log.d(TAG,&quot;pm25 is &quot;+jsonObjectInResults.get(&quot;pm25&quot;)); String currentCity = jsonObjectInResults.get(&quot;currentCity&quot;).toString(); Log.d(TAG,&quot;currentCity is &quot;+currentCity); } }catch (Exception e) { e.printStackTrace(); } } 使用GsonGson 是Google 的一个解析json的库，使用起来比 org.json.JSONArray 和 org.json.JSONObject 简便一些 首先需要定义一个类类中的成员变量必须和json中的 key 是一样的，变量类型也要相互对应 解析单个对象 1234{ &quot;name&quot;: &quot;PPTing&quot;, &quot;age&quot;: 21,} 对应的类应该这么定义 12345public class Person{ public String name; public int age;} 解析嵌套对象 12345678{ &quot;name&quot;:&quot;PPTing&quot;, &quot;age&quot;:21, &quot;other&quot;:{ &quot;email&quot;:&quot;i@ppting.me&quot;, &quot;location&quot;:&quot;nanjing&quot; }} 对应的类应该这么定义 1234567891011public class Person{ public String name; public int age; public Other other; public static class Other { public String email; public String location; }} 解析数组 12345678{ &quot;name&quot;: &quot;PPTing&quot;, &quot;age&quot;: 21, &quot;results&quot;:[ &quot;email&quot;:&quot;i@ppting.me&quot;, &quot;location&quot;:&quot;nanjing&quot; ]} 对应的类应该这么定义 1234567891011public class Person{ public String name; public int age; public List&lt;Results&gt; results = new ArrayList&lt;Results&gt;(); public static class Results { public String email; public String location; }} 然后再在类中加入set和get方法 在Android Studio 中添加set 和 get 方法的快捷键是 command + N ####开始解析 1234567public void parseJsonWithGson(String jsonData){ Log.d(TAG,&quot;用gson进行解析&quot;); Gson gson = new Gson(); Person person = gson.fromJson(jsonData,Person.class); Log.d(TAG,&quot;email is &quot;+person.getEmail());} 这样就可以获取到email 的值 这里贴上用来解析文章开头的天气json的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package me.ppting.weather;import android.util.Log;import java.util.ArrayList;import java.util.List;/** * Created by PPTing on 15/9/22. */public class WeatherInfo{ private String error; private String status; private String date; public String getError() {return error;} public void setError(String error) {this.error = error;} public String getStatus() {return status;} public void setStatus(String status) {this.status = status;} public String getDate(){return date;} public void setDate(String date){this.date = date;} public List&lt;Results&gt; results = new ArrayList&lt;Results&gt;(); public List&lt;Results&gt; getResults(){return results;} public void setresults(List&lt;Results&gt; results){this.results = results;} public static class Results { public String currentCity; public String pm25; public List&lt;Index&gt; getIndex() { return index; } public void setIndex(List&lt;Index&gt; index) { this.index = index; } public List&lt;Index&gt; index = new ArrayList&lt;Index&gt;(); public List&lt;Weather_data&gt; getWeather_data() { return weather_data; } public void setWeather_data(List&lt;Weather_data&gt; weather_data) { this.weather_data = weather_data; } private List&lt;Weather_data&gt; weather_data = new ArrayList&lt;Weather_data&gt;(); //get and set public String getCurrentCity(){return currentCity;} public void setCurrentCity(String currentCity){this.currentCity = currentCity;} public String getPm25(){return pm25;} public void setPm25(String pm25){this.pm25 = pm25;} public static class Index { private String title; private String zs; private String des; private String tipt; public String getTitle(){return title;} public void setTitle(String title){this.title = title;} public String getZs(){return zs;} public void setZs(String zs){this.zs = zs;} public String getTipt() {return tipt;} public void setTipt(String tipt) {this.tipt = tipt;} public String getDes() {return des;} public void setDes(String des) {this.des = des;} } public class Weather_data { private String data; private String dayPictureUrl; private String nightPictureUrl; private String weather; private String wind; private String temperature; public String getData() { return data; } public void setData(String data) { this.data = data; } public String getDayPictureUrl() { return dayPictureUrl; } public void setDayPictureUrl(String dayPictureUrl) { this.dayPictureUrl = dayPictureUrl; } public String getNightPictureUrl() { return nightPictureUrl; } public void setNightPictureUrl(String nightPictureUrl) { this.nightPictureUrl = nightPictureUrl; } public String getWeather() {return weather;} public void setWeather(String weather) { this.weather = weather; } public String getWind() { return wind; } public void setWind(String wind) { this.wind = wind; } public String getTemperature() { return temperature; } public void setTemperature(String temperature) { this.temperature = temperature; } } }} 参考：Stackoverflow Android gson通过Gson解析Json数据Android中使用Gson解析稍复杂的JSON数据 这里有两个小工具： Json Editor Online 根据json自动生成gson解析代码 Tips：[]: 定义成一个List{}: 定义成一个类","link":"/2015/10/02/2015_10_02_parse_json/"},{"title":"使用 AsyncTask 进行异步加载 ListView 图文并排","text":"##一些 AsyncTask 的知识 AsyncTask&lt;Params,Progress,Results&gt;是一个抽象类，通常用于被继承需要指定三个参数 123Params: 启动任务时输入参数的类型Progress: 后台任务进行中返回进度值的类型Results: 后台任务执行完毕后返回结果的类型 必须重写 doInBackground() 方法 这是异步执行后台线程任务将要完成的任务 在这里操作耗时操作 onPreExecute() 执行后台耗时操作前被调用，用来进行初始化操作 onPostExecute() 当doInBackground() 方法完成后会自动调用这个方法，并将 doInBackground() 方法中返回的值传递给该方法 onProgressUpdate() 在doInBackground() 方法中调用publishProgress() 方法更新任务的执行进度后就会调用该方法 ##一些 Tips 在 Android Studio 中 Command + N 后点击 Override Methods 可以选择重载函数 ##代码分析 使用 Gson 解析服务器返回的 Json 数据（具体使用详见-&gt; 解析 Json 数据） 在这个 Demo 中我需要解析一个 当天天气的温度和当天天气的图片的URL 出来，并解析为 List ，传递给 ListView 的 Adapter 新建一个类 WeatherBean 12345public class WeatherBean{ public String weatherUrl; public String weatherTem;} 写一个方法用于解析 Json 数据中返回的 当天天气的温度和当天天气的图片的URL 123456789101112131415161718public List&lt;WeatherBean&gt; parseJsonWithGsonTest(String jsonData) { List&lt;WeatherBean&gt; weatherBeanList = new ArrayList&lt;&gt;(); Gson gson = new Gson(); WeatherInfo weatherInfo = gson.fromJson(jsonData, WeatherInfo.class); try { for (int i = 0;i&lt;3;i++) { WeatherBean weatherBean = new WeatherBean(); weatherBean.weatherUrl = weatherInfo.getResults().get(0).getWeather_data().get(i+1).getDayPictureUrl(); weatherBean.weatherTem = weatherInfo.getResults().get(0).getWeather_data().get(i+1).getTemperature(); weatherBeanList.add(weatherBean); } }catch (Exception e) {e.printStackTrace();} return weatherBeanList; } 在 MainActivity 中建立一个类，并 new 一个对象调用 MyAsyncTask 进行异步加载 new MyAsyncTask().execute(response);//response 是通过访问服务器返回的json数据传入服务器返回的json数据，接着用parseJsonWithGsonTest 方法去解析得到天气图的url和tem，返回url和tem到onPostExecute中设置给 ListView 的 adapter 1234567891011121314151617class MyAsyncTask extends AsyncTask&lt;String,Void,List&lt;WeatherBean&gt;&gt; { @Override protected List&lt;WeatherBean&gt; doInBackground(String... params) { Log.d(TAG,&quot;传入的url是 &quot;+params[0]); //传入的是服务器返回的json数据，接着用parseJsonWithGsonTest 方法去解析得到天气图的url和tem，返回 url和tem到onPostExecute中 return new ParseJson().parseJsonWithGsonTest(params[0]); } @Override protected void onPostExecute(List&lt;WeatherBean&gt; weatherBeans) { super.onPostExecute(weatherBeans); WeatherListAdapter adapter = new WeatherListAdapter(MainActivity.this,weatherBeans); weatherInfoListView.setAdapter(adapter); } } 写 ListView 的 Adapter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class WeatherListAdapter extends BaseAdapter { private List&lt;WeatherBean&gt; weatherBeanList; private LayoutInflater layoutInflater; public WeatherListAdapter (Context context,List&lt;WeatherBean&gt; data) { weatherBeanList = data; layoutInflater = LayoutInflater.from(context); } @Override public int getCount() { return weatherBeanList.size(); } @Override public Object getItem(int position) { return weatherBeanList.get(position); } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder viewHolder = null; if (convertView==null) { viewHolder = new ViewHolder(); convertView = layoutInflater.inflate(R.layout.weatherinfo,null); viewHolder.imageView = (ImageView)convertView.findViewById(R.id.weatherIamge); viewHolder.textView = (TextView) convertView.findViewById(R.id.weatherInfo); convertView.setTag(viewHolder); } else { viewHolder = (ViewHolder) convertView.getTag(); } viewHolder.imageView.setImageResource(R.mipmap.ic_launcher); String url = weatherBeanList.get(position).weatherUrl; Log.d(&quot;WeatherListAdapter&quot;,&quot;weatherUrl is &quot;+url); viewHolder.imageView.setTag(url); new PictureLoader().showImageByAsyncTask(viewHolder.imageView,url);//调用异步加载图片 viewHolder.textView.setText(weatherBeanList.get(position).weatherTem); return convertView; } class ViewHolder { public ImageView imageView; public TextView textView; }} 通过 AsyncTask 异步加载图片，通过传入的 url 获取 bitmap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class PictureLoader{ public void showImageByAsyncTask(ImageView imageView,String url) { //MyAsyncTask myAsyncTask = new MyAsyncTask(imageView,url); //myAsyncTask.execute(url); new ShowPicAsyncTask(imageView, url).execute(url); } public Bitmap getBitmapFromUrl(String stringUrl) { Bitmap bitmap = null; InputStream inputStream = null; try { URL url = new URL(stringUrl); HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(); inputStream = new BufferedInputStream(httpURLConnection.getInputStream()); bitmap = BitmapFactory.decodeStream(inputStream); httpURLConnection.disconnect(); return bitmap; } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } return null; } //异步加载天气列表里的天气图 private class ShowPicAsyncTask extends AsyncTask&lt;String,Void,Bitmap&gt; { private ImageView mImageView; private String mUrl; public ShowPicAsyncTask(ImageView imageView,String url) { mImageView = imageView; mUrl = url; } @Override protected Bitmap doInBackground(String... params) { getBitmapFromUrl(params[0]); return getBitmapFromUrl(params[0]); } @Override protected void onPostExecute(Bitmap bitmap) { super.onPostExecute(bitmap); if (mImageView.getTag().equals(mUrl)) { mImageView.setImageBitmap(bitmap); } } }} 源码在 Github 上 因为是从我写的一个重构过的天气 Demo 中摘出来的，写得比较乱","link":"/2015/10/09/2015_10_09_asyncTask/"},{"title":"Android 网络请求","text":"##HttpClient (Apache)6.0中已经移除了这个方法，Google建议使用HttpUrlConnection 见Android 6.0 Changes ###GET 方法 新建一个HttpGet对象 1HttpGet httpGet = new HttpGet(&quot;https://baidu.com&quot;); 获取HtttpClient实例 1HttpClient httpClient = new DefaultHttpClient(); 获取HttpResponse实例 并传入HttpGet对象 1HttpResponse response = httpClient.execute(httpGet); 判断是否请求成功 123456if(response.getStatusLine().getStatusCode()==200){//do somethingHttpEntity httpEntity = response.getEntity();String result = EntityUtils.toString(httpEntity);String result = EntityUtils.toString(response.getEntity(),&quot;UTF-8&quot;);//带中文的话} POST 方法 新建一个HttpGet对象 1HttpGet httpPost = new HttpPost(&quot;https://baidu.com&quot;); 获取HtttpClient实例 1HttpClient httpClient = new DefaultHttpClient(); 设置POST参数(1) 123456List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();params.add(new BasicNameValuePair(&quot;username&quot;, &quot;username&quot;));params.add(new BasicNameValuePair(&quot;password&quot;, &quot;password&quot;));//添加内容到请求中UrlEncodedFormEntity entity = new UrlEncodedFromEntity(params,&quot;UTF-8&quot;);httpPost.setEntity(entity); 设置POST参数(2) 1234567NameValuePair namePair = new BasicNameValuePair(&quot;username&quot;,&quot;username&quot;);NameValuePair pswPair = new BasicNameValuePair(&quot;password&quot;,&quot;password&quot;);List&lt;NameValuePair&gt; pairList = new ArrayList&lt;NameValuePair&gt;();pariList.add(namePair);//添加内容到请求中HttpEntity httpEntity = new UrlEncodedFormEntity(pairlist);httpPost.setEntity(httpEntity); 获取HttpResponse实例 并传入HttpGet对象 1HttpResponse response = httpClient.execute(httpPost); 判断是否请求成功 123456if(response.getStatusLine().getStatusCode()==200){//do somethingHttpEntity httpEntity = response.getEntity();String result = EntityUtils.toString(httpEntity);//String result = EntityUtils.toString(response.getEntity(),”UTF-8”);//带中文的话} ##HttpUrlConnection GET 方法 先new一个Url 对象，并传入网址1Url url = new Url(&quot;https://baidu.com&quot;); 打开一个HttpUrlConnection连接1HttpUrlConnection httpUrlConnection = (HttpUrlConnection) url.openConnection(); 设置get或者post方法1httpUrlConnection.setRequestMethod(“GET”); 定制一些信息 比如超时时间，title等 调用getInputStream 获取服务器返回的输入流12345678InputStream in = httpUrlConnection.getInputStream();//对获取到的输入流进行读取BufferedReader reader = new BufferedReader(new InputStreamReader(in));StringBuilder response = new StringBuilder();String line;while ((line = reader.readLine()) != null) { response.append(line);} 关闭连接1httpUrlConnection.disconnect(); POST 方法 前面都一样123httpUrlConnection.setRequestMethod(&quot;POST&quot;);DataOutputStream dataOutputStream = new DataOutputStream(httpUrlConnection.getOutputStream);dataOutputStream.writeBytes(&quot;username=XXX&amp;password=YYY&quot;);","link":"/2015/11/19/2015_11_19_android_http_request/"},{"title":"使用CollapsingToolbarLayout","text":"记录一下 CollapsingToolbarLayout 的使用 ##布局文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appBarLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsingtoolbarlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:contentScrim=&quot;@color/colorPrimaryDark&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/bg&quot; android:scaleType=&quot;centerCrop&quot; app:layout_collapseMode=&quot;parallax&quot;/&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/musictoorbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_margin=&quot;20dp&quot; android:gravity=&quot;center&quot; android:text=&quot;测试&quot;/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; ##为了使 Toolbar 有滑动属性，需要注意 在CoordinatorLayout中放置两个布局，分别是Appbar布局AppBarLayout和可滑动布局NestedScrollView（ListView和ScrollView）并不能使用这个特性 CoordinatorLayout必须作为整个布局的父布局容器 给需要滑动的组件设置 app:layout_scrollFlags 属性，给可以滑动的组件设置 app:layout_behavior 属性 其中app:layout_scrollFlags 的属性有：1.scroll: 所有需要滚出屏幕的布局都需要设置这个属性2.enterAlways:使得滚出屏幕的布局在屏幕在向下滑动时可见3.enterAlwaysCollapsed:当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。4.exitUntilCollapsed:滚动出屏幕最后折叠在顶部 在滑动的子View中设置app:layout_collapseMode属性有两个属性 1.app:layout_collapseMode=&quot;parallax&quot; 设置该属性，在内容滚动时，该View也会同时滚动，实现视觉差，通常和layout_collapseParallaxMultiplier搭配使用2.app:layout_collapseMode=&quot;pin&quot; 设置该属性，当CollapsingToolbarLayout被收缩的时候，该View还会被固定在屏幕上。 PS. 在CollapsingToolbarLayout中设置app:contentScrim=&quot;color&quot;可以改变收缩以后Toolbar的颜色，不设置的话会显示为图片的背景 ImageView中使用android:scaleType=&quot;centerCrop&quot; 使得照片按照原始比例缩放 在&lt;include layout=&quot;@layout/toolbar&quot;/&gt;中加入 app:layout_scrollFlags=&quot;scroll|enterAlways&quot;并不生效，即 12&lt;include layout=&quot;@layout/toolbar&quot; app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt; 似乎是个bug？需要在toolbar中添加该属性 参考文章 Android M新控件之AppBarLayout，NavigationView，CoordinatorLayout，CollapsingToolbarLayout的使用 Material Design之CollapsingToolbarLayout使用","link":"/2015/10/29/2015_10_29_use_CollapsingToolbarLayout/"},{"title":"状态栏 Status Bar","text":"所谓 沉浸式状态栏 和 变色状态栏 之分按照文档，沉浸式指的是在一些阅读应用或者视频播放应用中进行全屏，隐藏 StatusBar 和 NavigationBar 并在手指触摸手机顶部或者底部时可以唤出这两者的行为 而变色状态栏是指将状态栏改变颜色的行为，这其中可以有透明和有颜色，而很多人把这个状态栏颜色和ToolBar/ActionBar 颜色一致称为 沉浸式 = = 醉了，可能是因为一些国内定制的ROM或者iOS上的表现是这样吧~所以这样的方式被使用的多？这个锅要产品经理来背是吧（逃为达到某些效果，我们使用support-v7 库中的 Toolbar ，并且建议使用 Toolbar 代替 原来的 Actionbar只需要在 Gradle 中添加这个依赖: compile 'com.android.support:design:23.3.0' ##Kitkat在Kitkat 之前，状态栏是黑色不可改变的在4.4上，要设置StatusBar 透明可以用 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); } 在Toolbar 中设置 android:fitsSystemWindows=&quot;true&quot;属性可以将Toolbar延伸到状态栏上，否则的话会将 Toolbar 直接顶到状态栏上 还有一种解决方案是设置 Toolbar 的 paddingTop=25dp（statusbar 的高度为25dp） 但这在5.0以上会变成半透明(看起来很像Meterial Design) ，其实并不是 如下图 设置状态栏透明并设置延伸至状态栏或者设置paddingTop=“25dp” 在4.4上的显示效果设置状态栏透明但不设置延伸至状态栏设置状态栏透明 在 5.0 以上的手机显示效果 如上所示，在4.4上是全透明，但是在5.0以上看起来像是Materal Design 但其实是半透明，##Lollipop Material Design先设置styles里Theme的&lt;item&gt;的colorPrimary、colorPrimaryDark和android:colorAccent等这里给出一张来自Google的图，简单易懂Material Design 建议状态栏的颜色比Toolbar的颜色深一些 在5.0以上要做到和4.4时候一样所谓的 “沉浸式” 或者是实现iOS那样的效果，其实就是将状态栏的颜色设置为 Toolbar 的颜色一般来说根据 Material Design 我们将Toolbar设置为 colorPrimary，将状态栏颜色设置为colorPrimaryDark，如果将这二者的颜色设置为相同，则达到了所谓的沉浸式例如 &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/background&lt;/item&gt; &lt;item name=&quot;android:divider&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;/style&gt; 效果如下： 但真正符合 Material Design 的应该是这样的 颜色随便写的，大家改改吧 这里推荐一个网站 material palette 最后给出一幅真正沉浸式的图吧 图片来自Google Developer","link":"/2016/04/14/2016_04_14_statusbar/"},{"title":"Retrofit with okhttp","text":"封装接口首先，我们将将请求api封装成一个接口（interface）， Retrofit 通过这个定义的interface生成一个具体的实现。在interface中进行接口api的定义，比如 1234 public interface RepoService { @GET(&quot;/users/{user}/repos&quot;) Call&lt;ResponseBody&gt; listRepo(@Path(&quot;user&quot;) String user);} 其中 注解@GET 代表这个请求使用 GET方法 构造Retrofit接着，我们构造Retrofit 12RepoService repoService = HttpUtil_Github.getInstance().create(RepoService.class);Call&lt;ResponseBody&gt; call = repoService.listRepo(user); 当调用 listRepo(String user)这个方法时，传入的参数会填入到 注解中 {user} 中 HttpUtil_Github.getInstance这个方法去获取 Retrofit 的一个单例123456789101112131415161718192021222324252627private Retrofit retrofit;private static volatile HttpUtil_Github instance = null;public HttpUtil_Github() { retrofit = new Retrofit.Builder() .baseUrl(NetUtil.GITHUB) .addConverterFactory(GsonConverterFactory.create()) .build();}//单例public static HttpUtil_Github getInstance(){ HttpUtil_Github mInstance = instance; if (mInstance == null){ synchronized (HttpUtil_Github.class){ mInstance = instance; if (mInstance == null){ mInstance = new HttpUtil_Github(); instance = mInstance; } } } return mInstance;}public &lt;T&gt; T create(Class&lt;T&gt; service) { return retrofit.create(service);} ##发起请求 然后通过异步发起GET请求 12345678910111213141516call.enqueue(new Callback&lt;ResponseBody&gt;() { @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { try { Log.d(TAG,&quot;&quot;+call.request().url()); Log.d(TAG,response.body().string()); } catch (IOException e) { e.printStackTrace(); } } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { }}); 在创建 Retrofit 对象时，传入我们的服务器的地址 baseUrl，完整的请求路径就是通过这个baseUrl和我们注解中的地址已经传入的参数结合起来的。 这里讲一下url的配置分为几种情况 baseUrl使用根域名形式 和 path使用绝对路径形式 123baseUrl: https://api.github.compath: /users/{user}/reposurl: https://api.github.com/users/tingya/repos baseUrl使用目录形式 和 path使用相对路径形式 123baseUrl: https://api.github.com/path: users/{user}/reposurl: https://api.github.com/users/tingya/repos 或者 123baseUrl: https://api.github.com/users/path:{user}/reposurl:https://api.github.com/users/tingya/repos baseUrl使用目录形式 和 path使用绝对路径形式 123baseUrl: https://api.github.com/users/path: /{user}/reposurl: https://api.github.com/tingya/repos baseUrl使用文件形式 和 path使用相对路径形式 123baseUrl:https://api.github.com/userspath:{user}/reposurl: https://api.github.com/tingya/repos 这种情况下会报错 error: baseUrl must end in /: https://api.github.com/users path使用完全路径 1234baseUrl: https://api.github.com/users/path https://api.github.com/users/{user}/reposurl: https://api.github.com/users/tingya/repos 当你使用完全路径时，Retrofit就会忽略掉你实例化它时通过baseUrl()方法传给它的host(接口前缀地址)；因为在实际项目中可能会有几个不同ip的host或者端口不同的host，通过这个方法可以避免实例化多个Retrofit对象 上面是最简单的GET请求的demo下面来说说其他的请求方式以及参数的配置 GET方法baseUrl 是 https://api.demo.com @Path这个注解用来替换相对路径中的值 12@GET(&quot;/users/{user}/repos&quot;)Call&lt;ResponseBody&gt; getMessage(@Path(&quot;user&quot;) String user); 通过Call&lt;ResponseBody&gt; call = repoService.getMessage(&quot;name&quot;);最终的url等价于https://api.demo.com/user/name/repos @Query 和 @QueryMap这个注解是用来给GET方法传参的，只能用于GET方法 12@GET(&quot;/users/name/repos&quot;)Call&lt;ResponseBody&gt; getMessage(@Query(&quot;age&quot;) int age); 通过Call&lt;ResponseBody&gt; call = repoService.getMessage(20);最终的url等价于https://api.demo.com/user/name/repos?age=20当有N个参数时，我们总不能说去写N个@Query吧，如果遇到有些情况下只需要部分参数的时候，我们就得再去写一个interface，使用不同数量的参数，这样不利于我们代码的解耦这个时候，我们应该使用 @QueryMap 这个注解 12@GET(&quot;/users/name/repos&quot;)Call&lt;ResponseBody&gt; getMessage(@QueryMap Map&lt;String,Object&gt; map) 通过 1234Map&lt;String,Object&gt; map = new HashMap();map.put(&quot;age&quot;,20);map.put(&quot;sex&quot;,&quot;famale&quot;);Call&lt;ResponseBody&gt; call = repoService.getMessage(map); 最终的url等价于https://api.demo.com/user/name/repos?age=20&amp;sex=famale POST方法@Field通过post方法提交表单 12@Post(&quot;/user/name/repos&quot;)Call&lt;ResponseBody&gt; getMessage(@Field(&quot;age&quot;) int age ); 通过Call&lt;ResponseBody&gt; call = repoService.getMessage(20)会往http请求的body中添加表单age=20 @FieldMap当需要通过POST方法提交多个key=value时候，可以通过@FieldMap这个注解提交多个参数 12@POST(&quot;&quot;)Call&lt;ResponseBody&gt; getMessage(@FieldMap Map&lt;String,Object&gt; map) 1234Map&lt;String,Object&gt; map = new HashMap();map.put(&quot;age&quot;,20);map.put(&quot;sex&quot;,&quot;famale&quot;);Call&lt;ResponseBody&gt; call = repoService.getMessage(map); 传json数据比如需要传下面这样的json格式的数据 1234{ name:xxx, age:20} 写一个 JavaBean，存放数据比如 12345678public class UserInfo { private String name; private int age; public String getName() { return name;} public void setName(String name) { this.name = name;} public int getAge() { return age;} public void setAge(int age) { this.age = age;}} 定义接口： 12@POST(&quot;/user/name/repos&quot;)Call&lt;ResponseBody&gt; getMessage(@Body UserInfo userInfo); 通过下面的方法去调用接口 1234UserInfo userInfo = new UserInfo();userInfo.setAge(20);userInfo.setName(&quot;user&quot;);Call&lt;ResponseBody&gt; call = service.getMessage(userInfo); 传文件定义接口 12345@Multipart //这个注解为http请求报文头添加 Content-Type: multipart/form-data; boundary=5b7b2ddf-bef2-4a32-ac21-e4662ea82771//对应请求头 第一行@POST(&quot;http://api.stay4it.com/v1/public/core/?service=user.updateAvatar&quot;)Call&lt;ResponseBody&gt; upload(@Part(&quot;access_token&quot;) RequestBody token, //通过`@Part`这个注解，会帮我们在请求头中生成`Content-Disposition: form-data; name=&quot;access_token&quot;`这样的请求格式@Part MultipartBody.Part picture); 123456789101112131415//设置 Content-TypeRequestBody requestFile = RequestBody.create(MediaType.parse(&quot;image/png&quot;), file);//设置 requestFile 的 Content-Disposition form-data; name=&quot;pic&quot;; filename=&quot;icon_equipment.png&quot;//`filename`是指想放在服务器的图片名字 MultipartBody.Part body = MultipartBody.Part.createFormData(&quot;pic&quot;, file.getName(), requestFile);//上面这行中，`createFormData(a,b,c)`中的第一个参数是传`name`，相当于`@Part(&quot;access_token&quot;) RequestBody token`中的`access_token`,所以一般不能使用`@Part(&quot;text&quot;) MultipartBody.Part picture`，因为在构建MultipartBody.Part时，已经包含了`picture`的name在里面，其实这并不能运行😄UploadFileService uploadFileService = HttpUtil_Gank.getInstance().create(UploadFileService.class);Call&lt;ResponseBody&gt; call = uploadFileService.upload( RequestBody.create(MediaType.parse(&quot;multipart/form-data&quot;), &quot;token value jai485789hqn485yhhwb &quot;),//携带的文字信息 body); 下面是上面的请求组成的上传文件的http Post请求头其中boundary指的是分隔符，用来分割不同的请求部分 可以很容易看出，这个请求体是多个相同的部分组成的： 每一个部分都是以–-加分隔符开始的，然后是该部分内容的描述信息(Content-Disposition)，然后一个回车，然后是描述信息的具体内容； 如果传送的内容是一个文件的话，那么还会包含文件名信息(Content-Disposition: form-data; name=&quot;pic&quot;; filename=&quot;icon_equipment.png&quot;)，以及文件内容的类型(Content-Type)。下面的第三个小部分其实是一个文件体的结构，最后会以–分割符–结尾，表示请求体结束。 —- Android Retrofit 实现文字（参数）和多张图片一起上传 12345678910111213141516171819202122232425262728293031 D/OkHttp: --&gt; POST http://api.stay4it.com/v1/public/core/?service=user.updateAvatar http/1.1 D/OkHttp: Content-Type: multipart/form-data; boundary=ed6fdfed-e436-4096-a70a-3a7b9657c933 D/OkHttp: Content-Length: 1100 D/OkHttp: Host: api.stay4it.com D/OkHttp: Connection: Keep-Alive D/OkHttp: Accept-Encoding: gzip D/OkHttp: User-Agent: okhttp/3.4.1 D/OkHttp: --ed6fdfed-e436-4096-a70a-3a7b9657c933 D/OkHttp: Content-Disposition: form-data; name=&quot;access_token&quot; D/OkHttp: Content-Transfer-Encoding: binary D/OkHttp: Content-Type: multipart/form-data; charset=utf-8 D/OkHttp: Content-Length: 33 D/OkHttp: token value jai485789hqn485yhhwb D/OkHttp: --ed6fdfed-e436-4096-a70a-3a7b9657c933 D/OkHttp: Content-Disposition: form-data; name=&quot;pic&quot;; filename=&quot;icon_equipment.png&quot; D/OkHttp: Content-Type: image/png D/OkHttp: Content-Length: 658 D/OkHttp: �PNG D/OkHttp: \u001a D/OkHttp: ������IHDR������F������F\b\u0003������F�\u0012��������PLTE������|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|��|�������������䰺������������������⥰؄��~�����,) )������\u001atRNS����\u0005\u0012\u001cb����V�_LG���/,�\u001b��J�����\u0001�IDATXì�˒�0\u0010��N\b\u0010@P�֜�����\u001fpԲjR�\u0013�̷`y\u0016�!�M���R\u0002�L�U���T��hY�H�\u0010�8\u0005+���SP\b8�&quot;�\u001ef\u0002\u001f�\u0019}\u0012j�Cr�H�&quot;'�*\u0019z��,�r �+b�\u0002���]Y`�\u0005��\u0004\u0006\u0013�S7�\by�s�Q�����&amp;d�\u0018Iڙ5F�[�\b\u000f�/��\u0007\u00110}=*'�Xe��hx��RxJ\u0015\u0011E�\u0016\u0011Q o1Q �M\u0006�\u0006�3�:�`��*cv\u0017p�|�ke�\u001aX\u001a�T]�8\u0019\u0018[�eo^��3���y�\u0012�uݸf��&gt;w�D�1��9&gt;&gt;h)I23�����r�\u001c�\u0019I�g\u0018�\u0019�b�(���@\u0010@%�\u0001 �4&quot;\u0004��)�&amp;�\u0006��\u0001�Uw~�p�u�����\u0015�\u0007G�\u000f-\u0003ZMD\u0014�� �&quot;JG\u0002c�\u000e���\u0002Ș �dL����\u0018C���DO\u001f������ B&amp;���h&quot;� �$΋r�,�ꈑk\\���k _J�\u0015Y���*�\u0007�U�Q\u0006ܭ���������IEND�B`� D/OkHttp: --ed6fdfed-e436-4096-a70a-3a7b9657c933-- D/OkHttp: --&gt; END POST (1100-byte body) D/OkHttp: &lt;-- 200 OK http://api.stay4it.com/v1/public/core/?service=user.updateAvatar (63ms) D/OkHttp: Server: nginx/1.4.6 (Ubuntu) D/OkHttp: Date: Tue, 18 Oct 2016 02:05:47 GMT D/OkHttp: Content-Type: application/json D/OkHttp: X-Frame-Options: SAMEORIGIN D/OkHttp: Transfer-Encoding: chunked D/OkHttp: Proxy-Connection: Keep-alive10-18 10:05:45.387 28938-1993/me.ppting.gank D/OkHttp: {&quot;ret&quot;:200,&quot;msg&quot;:&quot;有心课堂,传递给你的不仅仅是技术✈️&quot;,&quot;data&quot;:[{&quot;url&quot;:&quot;uploads/icon_equipment.png&quot;,&quot;filename&quot;:&quot;icon_equipment.png&quot;}]}10-18 10:05:45.387 28938-1993/me.ppting.gank D/OkHttp: &lt;-- END HTTP (150-byte body) 如果是传多个文件，则不能像上面上传一个文件使用传MultipartBody.Part对象的方法，而是使用@PartMap这个注解，同理，传多个文件其实就是在请求头中添加多个由分隔符隔开的部分，每隔部分都需要有 12Content-Disposition：form-data;name=&quot;pic&quot;;filename=&quot;filename&quot;Content-Type: image/png 等信息 可以将接口中的第二个参数@Part改为@PartMap Map&lt;String, RequestBody&gt; params将name 和 filename 存到 params中的第一个参数中定义接口 123@Multipart //这个注解为http请求报文头添加 Content-Type: multipart/form-data; boundary=5b7b2ddf-bef2-4a32-ac21-e4662ea82771@POST(&quot;http://api.stay4it.com/v1/public/core/?service=user.updateAvatar&quot;)Call&lt;ResponseBody&gt; uploadMore(@PartMap Map&lt;String, RequestBody&gt; map); 通过下面的代码添加请求文件并调用接口 1234567Map&lt;String, RequestBody&gt; map = new HashMap&lt;&gt;();for (File file : fileList) { map.put(file.getName()+&quot;\\&quot;;filename=\\&quot;&quot;+file.getName(),RequestBody.create(MediaType.parse(&quot;image/png&quot;),file));}UploadMoreFileService uploadMoreFileService = HttpUtil_Gank.getInstance().create(UploadMoreFileService.class);Call&lt;ResponseBody&gt; call = uploadMoreFileService.uploadMore(map); 上面的map中的第一个参数是为了在Content-Disposition: form-data; name=&quot;pic&quot;; filename=&quot;icon_equipment.png&quot;中拼接 name=&quot;name&quot;;和filename=&quot;filename&quot;，当多文件上传时，多个文件的name对应的value应该设为不同的值，所以这里我们取了文件的名字作为name的value。写到这里我也有点疑问，那为什么不能模仿只传一个文件的时候那样使用MultipartBody.Part呢，于是我试了一下定义接口 123@Multipart@POST(&quot;http://api.stay4it.com/v1/public/core/?service=user.updateAvatar&quot;)Call&lt;ResponseBody&gt; uploadMore(@PartMap Map&lt;String,MultipartBody.Part&gt; map); 然后 12345678910111213UploadMoreFileService uploadMoreFileService = HttpUtil_Gank.getInstance().create(UploadMoreFileService.class);RequestBody requestFile1 = RequestBody.create(MediaType.parse(&quot;image/png&quot;),firstFile);RequestBody requestFile2 = RequestBody.create(MediaType.parse(&quot;image/png&quot;),secondFile);MultipartBody.Part part1 = MultipartBody.Part.createFormData(&quot;pic&quot;, firstFile.getName(), requestFile1);MultipartBody.Part part2 = MultipartBody.Part.createFormData(&quot;pic&quot;, secondFile.getName(), requestFile2);Map&lt;String, MultipartBody.Part&gt; map = new HashMap&lt;&gt;();map.put(&quot;&quot;,part1);map.put(&quot;&quot;,part2);Call&lt;ResponseBody&gt; call = uploadMoreFileService.uploadMore(map); 但是发现会报错@PartMap values cannot be MultipartBody.Part. Use @Part List&lt;Part&gt; or a different value type instead. (parameter #1) 添加拦截器123456789101112Request original = chain.request();HttpUrl originalHttpUrl = original.url();HttpUrl url = originalHttpUrl.newBuilder() .addQueryParameter(&quot;apikey&quot;, &quot;your-actual-api-key&quot;) .build();Request.Builder requestBuilder = original.newBuilder() .url(url);Request request = requestBuilder.build();return chain.proceed(request); 自定义 Converter建一个继承Converter.Factory的Factory类123456789101112131415161718192021222324252627282930313233343536373839public class StringConverterFactory extends Converter.Factory{ public static StringConverterFactory create() { return new StringConverterFactory(); } //{@link Body @Body}, {@link Part @Part}, and {@link PartMap @PartMap} //以上面这几个注解的request可以在这里拦截到并进行处理 而其他的则是用下面的方法 @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { Log.d(&quot;StringConverterFactory&quot;,&quot; type &quot;+type.toString()); return super.requestBodyConverter(type, parameterAnnotations, methodAnnotations, retrofit); } @Override public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) { Log.d(&quot;StringConverterFactory&quot;,&quot;stringConverter&quot;); return super.stringConverter(type, annotations, retrofit); } @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { //如果不是我们想要处理的类型，则返回null，不进行处理 if (type != String.class){ return null; } return new StringResponseBodyConverter();//这里进行处理 }}public class StringResponseBodyConverter implements Converter&lt;ResponseBody,String&gt;{//将 ResponseBody 转为 String@Override public String convert(ResponseBody value) throws IOException { Log.d(&quot;StringResponseBody &quot;,&quot;StringResponseBody&quot;); return value.string(); }} Converter是用来将ResponseBody进行转化的我们需要的类CallAdapter是用来转化返回类型的，比如将Call转Observable 分享一个小tip在QQ群里讨论Retrofit的时候，别人分享的一个小技巧当项目中的大多数接口需要token但有些不需要的时候，可以在@Headers中定义Authorization，并给其一个参数，例如true or false 然后在Interceptor中进行判断并进行处理例如 123@Headers({&quot;\\&quot;Cache-Control\\&quot;:max-age=0&quot;,&quot;Authorization:true&quot;})@GET(&quot;4/start-image/{width}*{height}&quot;)Observable&lt;StartImageInfo&gt; getSplashImage(@Path(&quot;width&quot;) int width, @Path(&quot;height&quot;) int height); 然后在自定义的Interceptor中去取得Authorization的值request.headers().get(&quot;Authorization&quot;)，然后进行处理 参考文章 Retrofit使用指南 Android Retrofit 实现文字（参数）和多张图片一起上传深入浅出 Retrofit，这么牛逼的框架你们还不来看看Android Retrofit 2.0 使用-补充篇Android 你必须了解的网络框架Retrofit2.0Retrofit 2.0 超能实践（三），轻松实现多文件/图片上传","link":"/2016/10/18/2016_10_18_retrofit_with_okhttp/"},{"title":"Android 组件化开发","text":"Android 组件化开发在项目的开发中，业务模块越来越多，代码量越来越多，编译构建的时间也越来越长，尝试将项目进行组件化开发。 所谓组件化，就是将各个业务模块解耦，在开发的时候将每个业务模块当做单独的 application 开发，在开发完毕后打包成 aar 或者以 module 的形式依赖到主 application 中。 首先，在项目根目录下的gradle.properties文件里设置一个全局变量 isDebug 为 true ，即debug模式，每个 module 为单个 application， 为 false，即非debug 模式，将app主模块编译为 app，并将其他 module 依赖进 app AndroidManifest在每个module中的main文件夹下建立两个文件夹，一个是debug，一个是release，用来存放AndroidManifest文件 在 debug 模式下，每个module都是单独的app，所以在AndroidManifest中需要添加一个activity作为启动activity 123456&lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在 release 模式下，每个module都是主app的一个依赖，可以不需要启动activity如果需要从主app中打开这些activity，可以使用隐式调用或者使用路由表去启动(放在后面再说) build.gradle 在主app中，不论在 debug 或者 release 模式下都作为application存在，即 apply plugin: ‘com.android.application’ 在各个module中，在 debug 模式下，作为application，在 release 模式下，作为library 12345if (isDebug.toBoolean()){ apply plugin: 'com.android.application'} else { apply plugin: 'com.android.library'} AndroidManifest合并的问题 在各个module中，利用sourceSets(在android标签下)中设置每个模式中的AndroidManifest文件 123456789sourceSets { main { if (isDebug.toBoolean()) { manifest.srcFile 'src/main/debug/AndroidManifest.xml' } else { manifest.srcFile 'src/main/release/AndroidManifest.xml' } }} Application我们知道，一个应用在启动后，系统会为其创建一个applicaiton对象，这个application对象的生命周期就等于整个应用的生命周期，一般我们会在里头定义一个全局的context。但是，如果在组件化开发中，在debug模式下，每个module是作为application存在的，但当我们打包时，即release模式下，每个module是作为library存在的，这时如果使用该module里的getApplicationContext()就会报错，因为release模式下只有一个application 解决方案： 我们在AndroidManifest合并的问题中，在sourceSets里指定AndroidManifest的路径，我们也可以指定在release模式下排除掉某些文件 123456789101112sourceSets { main { if (isDebug.toBoolean()) { manifest.srcFile 'src/main/debug/AndroidManifest.xml' } else { manifest.srcFile 'src/main/release/AndroidManifest.xml' java { exclude 'debug/**' } } }} 所以我们可以在debug文件夹里的AndroidManifest文件可以指定该Application，而在release文件夹下的AndroidManifest中不指定Application但是这种方法也有局限，因为这样的话，我们的module里就没法使用全局的context对象了。 为了解决上面这个问题，我们将 application 定义在最底层的 module 中(取名为 commonSdk)，并在最上层的 app 中的 AndroidManifest 中去使用这个 application ，这样所有的 module 就都可以使用这个 application context 对象了。 资源文件在开发过程中，我们将module作为一个application使用，所以只会使用该module下res下的资源文件，但当在release模式下，会将整个工程作为一个application，因此所有的资源文件都会被合并到一起，如果module里的有资源文件同名，则会被覆盖，因此有可能造成错误 为了解决这个问题，我们可以在所有的资源文件的名字上加个前缀，用module区分开来，则不会产生上述问题，在gradle中，可以用 resourcePrefix “前缀_” 强制在资源文件名字上加上该前缀，否则会编译不通过，但这个方法不会限定drawable里的资源文件，因此在drawable中的资源文件命名需要在开发过程中加以规范 依赖版本依赖在Android开发中，我们会使用很多的依赖库，在非组件化的项目中，我们只需要一股脑将依赖全部写在app的build.gradle文件中，这样我们的项目就可以用这些依赖了。 但是在组件化中，如果我们也按照这种方式，那就有可能造成重复的依赖，如果我们的firstmodule和secondmodule中都需要http请求，则都去依赖某个http请求库，如果是使用compile 'libiray_name:version'这种方式去依赖，gradle会自动帮我们选出最新的版本去依赖，如果两个module中使用的是不同版本的依赖，并且某个新版本中删除了一些api，如果依赖了旧版本的module使用了这些在新版本中被删除的api，那就会报错。 另外，如果我们的module中是使用compile project(':project')这样的依赖，gradle不会帮我们去重，最后打包后代码里就会有重复的类。 那如何去解决这个问题呢？ 在Application一节中，我们使用了一个commonsdk的module，用来给上游的module提供application，在这个module中，我们也可以在这个commonsdk的module中添加上游的module所需要的依赖，比如http请求库(Retrofit)，Gson等等，这样在上游的各个module就都能使用这些依赖。而现在我们只需要在commonsdk这个module中去管理我们的依赖，比如添加、删除、升级依赖。这样我们的主app就不需要去重复依赖一些库了，主app只需要依赖commonsdk这个module，而这个module已经提供了需要的依赖。 版本如何去管理这些依赖的版本呢，可以在主工程目录下定义变量，进行统一管理在build.gradle中定义一个标签ext ext{ compileSdkVersion = 25 buildToolsVersion = &quot;25.0.2&quot; minSdkVersion = 15 targetSdkVersion = 25 supportLibraryVersion = &quot;25.3.1&quot; espressoCoreVersion = &quot;2.2.2&quot; junitVersion = &quot;4.12&quot; retrofitVersion = &quot;2.2.0&quot; } 然后将各个module的build.gradle里的变量都通过rootProject.ext.xxx取值 如果是dependencies的话，则用$rootProject.version取值 例如 dependencies { compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile(&quot;com.android.support.test.espresso:espresso-core:$rootProject.espressoCoreVersion&quot;, { exclude group: 'com.android.support', module: 'support-annotations' }) compile &quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot; testCompile &quot;junit:junit:$rootProject.junitVersion&quot; compile &quot;com.squareup.retrofit2:retrofit:$rootProject.retrofitVersion&quot; } debug 模式下依赖按照我们上述的想法去做以后，或许还存在一个问题，就是在debug模式时，我们的各个module是作为application存在的，这个时候如果我们想安装整个项目app，按照我们的这种模式是无法打开我们的各个业务module的，那难道这个问题就没法解决了吗？当然不是。 我们可以修改为release模式，这样就可以将各个module作为library进行依赖，也就可以打开业务模块了看到这里你们可能会说 你再逗我吗 = = 如果我们想在debug模式下也能安装app的话，并且能够打开各个业务module，那可以在app的dependencies中依赖各个module的aar文件，这个aar文件可以在各个module的/build/outputs/aar下找到，可以写脚本或者手动将各个module生成的aar复制到app的libs文件夹下，并进行引用。 1234567android{ repositories { flatDir { dirs 'libs' } }} 然后在dependencies进行依赖 dependencies { if(isDebug.toBoolean()){ compile project(':router') compile project(':commonsdk') compile(name:'firstmodule-release', ext:'aar') compile(name:'secondmodule-release', ext:'aar') }else { compile project(':firstmodule') compile project(':secondmodule') } } 这样我们就可以在debug模式下也将整个工程运行起来了，当然，这样其实就没有意义了，因为我们组件化的目的就是为了能够将各个业务module作为application运行，而不是运行整个app，以加快我们的编译速度等，而这样的话就失去了不需要全部编译的意义了。 多 Product Flavors 模式下的依赖本地 AAR 的依赖在组件化的开发中，有时候遇到某个 lib 需要依赖某个本地 aar 文件则在 dependencies 添加对本地的 aar 依赖，并将 aar 依赖文件放入 libs 目录下 1compile(name:'aar_file_name', ext:'aar') 如果此时有多个 Flavors ，则在 compile 前添加 Flavor 名字，如 123flavors1Compile(name: 'aar_file_name', ext: 'aar')flavors2Compile(name: 'aar_file_name', ext: 'aar')flavors3Compile(name: 'aar_file_name', ext: 'aar') 但如果这个库以同样的方式被依赖的话，会因为找不到这个文件而报错 1Error:Failed to resolve: :arr_file_name: Open File 这时可以在项目的 build.gradle 中配置 12345678910allprojects { repositories { flatDir { // 由于Library module中引用了 lib 库的 aar，在多 module 的情况下， // 其他的module编译会报错，所以需要在所有工程的repositories // 下把Library module中的libs目录添加到依赖关系中 dirs project(':lib_name').file('libs') } }} 跳转 router在不同的module中，要实现跨module之间的跳转， 可以使用intent并设置data里的host和scheme，用隐式调用进行跳转。例如，在AndroidManifest中设置 12345678910&lt;activity android:exported=&quot;false&quot; //设置其他 application 不能唤起我们的 application android:name=&quot;me.ppting.secondmoudle.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;me.ppting.jump&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:host=&quot;ppting.me&quot; android:scheme=&quot;second&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 要进行跳转时，用下面的代码进行跳转 1234Intent intent = new Intent();intent.setAction(&quot;me.ppting.jump&quot;);intent.setData(Uri.parse(&quot;second://ppting.me&quot;));startActivity(intent); 最后放一张最终的架构图","link":"/2017/12/24/2017_12_24_component_for_android/"},{"title":"Android TextView 两端对齐","text":"在项目中遇到项目要求在描述中进行两端对齐，而我们的 TextView 是不支持两端对齐的要做到两端对齐，其实还是有些小 trick 的 如上图所示，我们可以在每个字符之间插入一个空格字符，然后动态地计算为了达到某个宽度(即最大宽度)，每个空格字符需要多大的宽度，然后使用 ScaleXSpan 将空格字符横向放大/缩小，这样就解决了我们两端对齐的方法，只需要使用一个 TextView 就够了。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 将文字转为两端对齐 * @param maxSize 最大的文字数量 * @param text 文字 * @param textSize 文字大小，单位为 sp 或者 dp * 举例，假设需要将『三个字』进行两端对齐，最大长度为4个中文字 * 则在『三个字』的每个字符之间插入一个全角空格，并计算其应该放大/缩小的倍数，然后用 ScaleXSpan 对 x 轴方向进行放大/缩放 * @return */public static Spannable formatText(int maxSize,String text,int textSize){ if (TextUtils.isEmpty(text)){ return new SpannableString(&quot;&quot;); } //先获取 maxSize 个字符串的长度 int textLength = text.length(); if (maxSize &lt; textLength || textLength == 1){ return new SpannableString(text); } //计算单个中文字在该设备上的长度，单位是 px float oneCharLength = DisplayMetricsUtil.getTextWidth(&quot;正&quot;,textSize); float maxTextLength = oneCharLength * maxSize; //计算该文字和应有长度的差 float diffLength = maxTextLength - DisplayMetricsUtil.getTextWidth(text,textSize); //计算每个间隙的宽度 float singleGapLength = diffLength / (textLength -1); //计算每个间隙应该放大/缩小的倍数 float scale = singleGapLength / oneCharLength; SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder(); char[] chars = text.toCharArray(); for (int i = 0; i &lt; textLength; i++) { spannableStringBuilder.append(chars[i]); if (i != textLength -1){ SpannableString space = new SpannableString(&quot; &quot;);//全角空格 space.setSpan(new ScaleXSpan(scale), 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); spannableStringBuilder.append(space); } } return spannableStringBuilder;} 计算文字的宽度可以使用 Paint 中的 measureText() 方法 123456789101112/** * 根据字体大小获取字符串长度 * @param text 例如 正正正 * @param textSize 18 (单位是 sp 或 dp) * @return */public static float getTextWidth(String text, int textSize) { TextPaint paint = new TextPaint(); float scaledDensity = App.getContext().getResources().getDisplayMetrics().scaledDensity; paint.setTextSize(scaledDensity * textSize); return paint.measureText(text);} 使用时只需要调用 formatText 方法对文字进行处理即可 1textView.setText(formatText(4,&quot;三个字&quot;,14)); 最后做出来的效果大概如下","link":"/2018/04/14/2018_04_14_justify-in-android/"},{"title":"使用 Lint 进行代码检查","text":"使用 Lint 进行代码检查背景为了进一步规范协同合作中的代码规范，避免写低级 Bug 和对代码进行规约，在调研了多种方案后，决定使用该种方案对代码进行自动化检查和规约 使用Github 开源地址：https://github.com/PPTing/AwesomeLint 先在配置文件(local.properties)中配置 nexusUrl 的值为本地仓库的地址 复制 git hook 脚本 2.1 在根目录下执行执行Windows: 2.1.1 修改 pre-commit-windows 文件中的第一行代码中的D:/Git为自己本机电脑的 Git 安装目录，即第一行代码为声明 sh.exe 的目录 2.1.2 执行 gradle installGitHooks Mac OS/Linux: ./gradlew installGitHooks 或者在 Android Studio 中右边面板上找到 root-Tasks-other-installGitHooks 并双击执行 2.2 赋予执行脚本可执行权限 chmod +x .git/hooks/pre-commit 环境准备使用git提交增量检查时需要配置ANDROID_HOME环境变量(需要以ANDROID_HOME命名并加入到path中，因为在Lint框架中执行Lint检查时需要获取Android环境变量) 1Windows环境：在电脑-&gt;属性-&gt;环境变量中编辑即可 1234Mac OS/Linux环境：编辑 ~/.bashrc即可vi ~./bashrcexport ANDROID_HOME=$HOME/{Android SDK 路径}export PATH=$PATH:$ANDROID_HOME/tools 实时提示 在 Android Studio 中进行实时提示 进行配置方法一 将自定义 Lint 规则的 aar 包放入项目中，例如 ${root}/libs 目录① 在项目的根目录下的 build.gradle 文件内的 repositories block 中为所有的 module 添加 aar 的路径(主要是便于管理，不需要所有 module 的 build.gradle 文件都写一遍 aar 路径) eg 1234567allprojects{ repositories{ flatDir{ dirs &quot;../${root}/libs&quot; } }} 在每个 module 中的 dependencies 中加入 implementation (name:'AAR的名字', ext:'aar') 即可 方法二 将 lintRules 发布到仓库中，再通过远程依赖在每个 module 中进行依赖即 implementation 'me.ppting.plugin:lintPreview:1.0.0.beta' 效果 目前只自定义了几个规则，例如 类名和方法名的命名需要符合驼峰命名法 效果如下 在 IDE 中会根据错误级别进行相应的提示，在 Darcula 主题下默认会以黄色的前景色进行提示，将鼠标移至该代码块则会有浮窗提示问题 去除提示(SuppressLint)假如某个 Lint 规则提示代码有误，但实际上是因为自定义规则的检测有误导致误报，或者代码并没有错误，可以使用 @SuppressLint 对该代码段进行注解，注解的参数填写 Lint 规则的 id，一般会在浮窗中展示该规则 id。 如果实在不知道该规则 id ，可以使用 @SuppressLint(&quot;All&quot;) 忽略所有的规则，但这样就会导致该方法内新增的代码也无法进行 Lint 规则检测，请谨慎使用 这样该方法就会忽略该规则的检测 自定义规则编写规则在 lintRules module 中编写规则 创建一个继承 Detector 的类 类中创建一个 ISSUE 表示该类用来检测的问题 在 Register 类中对该 issue 进行注册 具体参考现有的代码 测试 执行 lintAAR中的copyAAR` 的 task 即可编译出 aar 文件并复制到 app module 中， Sync Project With Gradle Files (点击 Gradle 的同步按钮) 即可在 app module 中测试各个规则是否生效 发布测试完毕，将 aar 文件复制到其他应用到它的地方即可，并同步即可生效 PS. 如果不生效，尝试重启 Android Studio COMMIT HOOKS 为了强制进行一些编码规范等的执行，会在 git hooks 在进行 commit 后做检查，如果检测不通过，则会触发 git reset 进行回滚此次提交，并将错误提示日志打印到 lint-check-result.log 文件中 大概原理i. 在项目中应用 gradle plugin，在每次 git commit 后，在 .git/hooks 中的 pre-commit hook 会自动执行，会到项目根目录下执行 ./gradlew lintCheck -PisLintCheck ii. lintCheck 会通过 git diff 获取暂存区中的代码修改，并记录其行数和文件名 iii. 将所有的改动的文件进行 lint 操作，并记录其 issue，如果某个 issue 对应的代码行正好是改动的代码行，则将记录数(记为 K)加一 iiii. 当结束 lintCheck 后，如果 K &gt; 0 ，则抛出异常，使本次提交失败 PS. 如果该 Issue 是 Warning 级别的，Android Studio 不会进行提示，如果该 Issue 是 Error 级别的，Android Studio 会有错误提示弹窗 应用 在项目根目录下的 build.gradle 中应用插件 1apply plugin:&quot;me.ppting.plugin.lint&quot; 设置 lintCheck 配置 在 根目录下的 build.gradle 中添加 lintCheck 配置 eg. 12345678lintConfig { //配置Lint检查文件的类型 lintCheckFileType = &quot;.java,.xml,.kt&quot; //是否将检查文件的所有扫描结果都输出 lintReportAll = true //是否进行 lint 检查，默认为 true isOpenLint = false} 复制 pre-commit 脚本到本地的 .git/hooks 目录下 在根目录下执行执行 Mac/Linux: ./gradlew installGitHooksWindows: gradle installGitHooks 或者在 Android Studio 中右边面板上找到 root-Tasks-other-installGitHooks 并双击执行 PS. 如果无法执行 pre-commit 脚本，可能是权限问题，给该脚本加上可执行权限 chmod +x .git/hooks/pre-commit PSS. 强制关闭 hook 操作 如果要强制关闭在 commit 之后的 hook 操作，可以使用 deleteGitHooks task 将 .git/hooks/pre-commit 文件删除 或者在 commit 时候加上 --no-verify 参数 遇到的一些坑和解决方案坑 1： 由于 lint 的 api 依赖于 kotlin-compiler ，而这会造成 Android Studio 的 Kotlin-Plugin 冲突，而导致无法编译 错误提示： 123456789101112131415FAILURE: Build failed with an exception.* What went wrong:org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments.setAllowNoSourceFiles(Z)V* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgDeprecated Gradle features were used in this build, making it incompatible with Gradle 6.0.Use '--warning-mode all' to show the individual deprecation warnings.See https://docs.gradle.org/5.4.1/userguide/command_line_interface.html#sec:command_line_warningsBUILD FAILED in 20s 解决方法： 在 buildSrc/build.gradle 文件中控制 lint api 的依赖 123configurations { all*.exclude group: 'com.android.tools.external.com-intellij',module:&quot;kotlin-compiler&quot;} 这样可以编译，但会导致 lintCheck task 失败于是我们使用一个变量 isLintCheck 来控制 lint api 是否要 exclude 掉 kotlin-compiler 的依赖 如下 12345678910/*** lintCheck 需要有 kotlin-compiler* run 不需要 kotlin-compiler*/configurations { boolean isLintCheck = project.hasProperty(&quot;isLintCheck&quot;) if (!isLintCheck) { all*.exclude group: 'com.android.tools.external.com-intellij',module:&quot;kotlin-compiler&quot; }} 所以要求我们在执行 lintCheck 任务时加上参数 -PisLintCheck 坑 2： 将 plugin 发布到仓库中作为插件使用 当尝试将 plugin 发布到仓库中，并在项目中使用 classpath 进行依赖该插件，会导致无法编译 错误提示： 1org.jetbrains.kotlin.resolve.diagnostics.DiagnosticSuppressor$Companion.getEP_NAME()Lcom/intellij/openapi/extensions/ExtensionPointName; 解决方案： 只能将插件项目通过 buildSrc module 的方式引入到需要使用 lint 的项目中 坑 3： walle 报错 由于升级了 Gradle 的版本，项目中也使用了美团的 walle 作为多渠道打包的方案，在编译阶段会报错 错误提示： 1API 'variantOutput.getPackageApplication()' is obsolete and has been replaced with 'variant.getPackageApplicationProvider()'. It will be removed at the end of 2019. 解决方案： walle 已经修复了该问题，详情请查阅 fixAPI ‘variant.getAssemble()’ is obsolete and has been replaced with…但 walle 并未将修复的版本发布(摊手)，可以自行下载源码编译到自己的仓库中引用 如何生产进行实时 lintRules 的 aar1发布 aar，直接运行 `lintRules-uploadArchives` 的 task 即可发布到仓库中 备注① ${root} 即项目的根地址文件夹名，请按需修改 感谢本文是在巨人的肩膀上进行探索并实践的，感谢 ①lsc1993 的AwesomeLint ②GitCode8 的 代码洁癖症的我，学习Lint学到心态爆炸本实践也是在该基础上进行改进并应用到项目中的，代码也是 fork 自该项目。在其基础上进行添加了对 Kotlin 的支持，并在应用到项目中时踩了很多坑也将其填完了。借此也将填坑经验分享出来，以供借鉴 诚惶诚恐，若有错误，不吝赐教","link":"/2019/10/25/2019_10_26_lint_check_code/"},{"title":"从一次渠道包的渠道上报失败查看 ApplicationContext 的赋值过程","text":"背景之前在项目的开发中，同事遇到了一个问题 在某个版本后交给市场部门同事的 apk 文件，市场的同事反馈，线上的用户新装后的上报的渠道全是官方渠道 PS. 项目中使用美团的 Walle 进行多渠道打包 问题排查组里的另一个同事开始排查问题，先是排查\b了交给市场同事的签渠道的工具是不是出了问题。于是先自己用该工具对 apk 进行渠道签入进行检查，发现确实不行。于是手动写入渠道，Debug 发现通过 WalleChannelReader.getChannel(this.getApplicationContext())方法获取到的值一直为空 后来，组内的同事来找我讨论这个问题，同事猜测是否跟之前引入了某个依赖库有关系，而按照我的理解，美团的渠道获取是通过获取到 .apk 文件然后从该文件中的某个分区里获取写入的渠道的，所以应该跟这个问题不会有关系。 我开始看项目中的代码，看似没有问题 12345678#XXXXApplication.java private String getChannel() { String channel = WalleChannelReader.getChannel(getApplicationContext(), &quot;xxxx&quot;); if (TextUtils.isEmpty(channel)) { channel = &quot;xxxx&quot;; } return channel;} 实在没辙了，只好通过 git commit 对比在出现问题前的代码，看是否在做某个需求时不小心改动了此处的代码。 果不其然，发现是另一个同事在做另一个需求的时候，不小心将 getChannel() 的调用放到了 Application#attachBaseContext() 方法中。 而通过查看walle 的源码，发现 WalleChannelReader.getChannel(Context context) 中需要通过 applicationContext 获取到 .apk 文件的地址(path) 才能获取到写在分区内的渠道。 walle 源码 123456789101112131415//这里的 context 即 WalleChannelReader.getChannel(Context context) 中传入的 context//所以这里的 context.getApplicationInfo() 为 null@Nullableprivate static String getApkPath(@NonNull final Context context) { String apkPath = null; try { final ApplicationInfo applicationInfo = context.getApplicationInfo(); if (applicationInfo == null) { return null; } apkPath = applicationInfo.sourceDir; } catch (Throwable e) { } return apkPath;} 于是，bug 解决了，将上报渠道的代码重新恢复到 onCreate() 后即可 但，仅仅是修复了 bug ，但问题的背后，还有很多不了解的地方。 思考🤔于是我开始思考 为何在 attachBaseContext(base: Context?) 方法中获取不到 applicationContext 首先，看一下 application 的生命周期，他是如何被创建出来的，这就要从 App 启动流程说起，但这是个比较复杂的过程，但对于这个问题，我们查看源码时只关注跟 context 相关的代码，忽略其他代码，避免在其中浪费太多时间和消耗无谓的精力 首先看一下 getApplicationContext() 方法的实现，可以看到 ContextWrapper.java 1234@Overridepublic Context getApplicationContext() { return mBase.getApplicationContext();} 继续跟踪，看一下 mBase.getApplicationContext() 返回的是什么 在 Context.java 中可见，这是一个抽象(abstract)类，其 Context getApplicaitonContext() 是个抽象(abstract)方法 1234567891011121314151617181920212223242526/** * Return the context of the single, global Application object of the * current process. This generally should only be used if you need a * Context whose lifecycle is separate from the current context, that is * tied to the lifetime of the process rather than the current component. * * &lt;p&gt;Consider for example how this interacts with * {@link #registerReceiver(BroadcastReceiver, IntentFilter)}: * &lt;ul&gt; * &lt;li&gt; &lt;p&gt;If used from an Activity context, the receiver is being registered * within that activity. This means that you are expected to unregister * before the activity is done being destroyed; in fact if you do not do * so, the framework will clean up your leaked registration as it removes * the activity and log an error. Thus, if you use the Activity context * to register a receiver that is static (global to the process, not * associated with an Activity instance) then that registration will be * removed on you at whatever point the activity you used is destroyed. * &lt;li&gt; &lt;p&gt;If used from the Context returned here, the receiver is being * registered with the global state associated with your application. Thus * it will never be unregistered for you. This is necessary if the receiver * is associated with static data, not a particular component. However * using the ApplicationContext elsewhere can easily lead to serious leaks * if you forget to unregister, unbind, etc. * &lt;/ul&gt; */public abstract Context getApplicationContext(); 简单解释一下这段注释 返回当前进程的全局唯一的 Application 单例对象 通常来说，仅当需要一个生命周期和当前上下文分开的 Context 时才使用此方法，该 Context 的生命周期和进程的生命周期相关，而和当前的组件无关 思考一下例如如何与 registerReceiver(BroadcastReceiver, IntentFilter) 交互 如果使用一个 Activity Context ，接收器会在 Activity 内被注册，这意味着你需要在 Activity 销毁之前取消注册，否则 framework 会在 activity 移除时清理掉你泄漏的注册并记录下错误。因此，如果你使用 Activity Context 注册一个静态的接收器（进程内全局的，与该 Activity 实例无关） 那么无论你使用的 Activity 什么时候被销毁，这个注册都会被移除 如果使用这里返回的 Context ，则会向你的应用程序相关的全局状态注册接收器，因此他永远不会为你注销。接收器与静态数据而不是特定的组件相关联，这是有必要的。 但是如果你忘记注销，取消绑定等，则在其他地方使用 Application Context 可能容易导致严重的泄漏 那我们就接着看这个方法的实现，正是在 ContextWrapper.java 中，也就是说，ContextWrapper 继承自 Context，并实现了该方法 那我们看一下这个 mBase 是什么 1234567891011Context mBase;public ContextWrapper(Context base){ mBase = base;}protected void attachBaseContext(Context base){ if(mBase == null){ throw new IllegalStateException(&quot;Base context already set&quot;); } mBase = base;} 先不管 mBase 是在什么时候被赋值的，先去看 mBase 的 getApplicationContext() 方法到底做了些什么。由断点处的信息可见，mBase 即 ContextImpl 的实例，我们也知道 Context 只有一个实现类，即 ContextImpl，找到 ContextImpl.java 类。找到 getApplicaitonContext() 方法的实现如下 12345@Overridepublic Context getApplicationContext() { return (mPackageInfo != null) ? mPackageInfo.getApplication() : mMainThread.getApplication();} 这样一来，我们就知道 getApplicaitonContext() 方法返回的要么是mPackageInfo.getApplication() 要么是 mMainThread.getApplication() 那么在 attachBaseContext() 方法时候调用 getApplicaitonContext() 方法到底是返回哪个呢，这取决于 mPackageInfo 是否为空。 那继续看 mPackageInfo 是在什么时候被赋值的。 1234567891011private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread, @NonNull LoadedApk packageInfo, @Nullable String splitName, @Nullable IBinder activityToken, @Nullable UserHandle user, int flags, @Nullable ClassLoader classLoader, @Nullable String overrideOpPackageName) { //忽略对我们来说暂时不重要的其他代码 ... mPackageInfo = packageInfo; //忽略对我们来说暂时不重要的其他代码 ... } 即 mPackageInfo 是在 ContextImpl 的构造方法中赋值的，那也就是说非特殊情况下，mPackageInfo 是不会为 null 的。 那我们接着看 mPackageInfo.getApplication() 的返回值。 123456#LoadedApk.javaprivate Application mApplication;Application getApplication() { return mApplication;} 是 LoadedApk 实例中的一个私有变量，继续看是什么时候赋值的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@UnsupportedAppUsage public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;makeApplication&quot;); Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) { appClass = &quot;android.app.Application&quot;; } try { java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;initializeJavaContextClassLoader&quot;); initializeJavaContextClassLoader(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); //① app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); } catch (Exception e) { if (!mActivityThread.mInstrumentation.onException(app, e)) { Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); throw new RuntimeException( &quot;Unable to instantiate application &quot; + appClass + &quot;: &quot; + e.toString(), e); } } mActivityThread.mAllApplications.add(app); //② mApplication = app; //忽略暂时不关心的代码 ... return app; } 我们重点看一下 12①app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext); 跟踪一下 newApplication() 这个方法 12345678public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException { Application app = getFactory(context.getPackageName()) .instantiateApplication(cl, className); app.attach(context); return app;} 可见，在这里调用了 Application 的 attach(Context context) 方法 而 Application 这个类中的 attach 方法中调用了 attachBaseContext(Context context) 方法，而这个，就是我们在自定义的 XXApplication 中 Override 的 attachBaseContext(Context context) ，而根据上面的分析，我们知道此时还未给 ②mApplication 赋值，所以我们在 attachBaseContext(Context context) 方法中调用 getApplicaitonContext() 就为 null 到此，真相大白","link":"/2020/02/01/2020_02_01_application_lifecycle/"},{"title":"关于 Android 的文件存储目录","text":"众所周知，在 Android 中，文件的存储有多个路径可供存储，也提供了多个 Api 使用，那这些 Api 到底是用来是哪个目录，又有什么区别呢。 内部存储和外部存储首先，要先知道 Android 存储中分为内部存储(Internal storage)和外部存储(External storage) 下面用 com.application.id 作为我们的 applicationId 来举例 内部存储 内部存储指的是 App 私有的目录，即 /data/data/com.application.id/ 有些手机的目录是 /data/user/0/com.application.id/实际上是同一个目录，从下图可见，/data/user/0 目录是一个软连接，其实际指向的目录即 /data/data 存储在这个目录下的文件是 App 私有的，其他 App 无法读写(root 用户除外)，目录会随着 App 的卸载而被删除 外部存储 外部存储包含私有外部存储和公共目录存储 私有外部存储私有外部存储是指 /storage/emulated/0/Android/data/com.application.id 我们会在根目录里看到 /sdcard、/mnt/sdcard、/storage/emulated/self/primary 下的文件都跟上述的 /storage/emulated/0 中的文件一模一样，这不禁会让人感到疑惑，实际上，通过调研发现这些目录也都是软连接，可以看到其对应实际目录 /sdcard -&gt; /storage/self/primary /storage/self/primary -&gt; /mnt/user/0/primary /mnt/user/0/primary -&gt; /storage/emulated/0 所以其实到最后，其目录指向的都是我们的 /storage/emulated/0 目录 在私有外部存储中，App 可以读写自己的目录(/storage/emulated/0/Android/data/com.application.id)下的文件，如果 Api 大于 19，不需要申请写权限。如果需要读写其他 App 的私有外部存储目录，则需要声明读写权限，若高于 23，还需要动态进行权限申请。 私有外部存储的目录也会随着 App 的卸载而被删除 写权限 android.permission.WRITE_EXTERNAL_STORAGE 那么为什么会有这样的设计呢？这个 0 又代表什么我的猜测是 Android 系统中可以有多用户，这个 0 代表了当前用户，如果有第二个用户，应该就会有 1 的出现，使用软连接的方式，会保证在使用 api 获取到相对应的路径时，指向正确的用户下的文件目录，避免多个用户之间的文件系统混乱当然，这只是我的猜测，未曾验证 公共目录存储是指 sdcard 中根目录中的公共目录，即 /storage/emulated/0，例如图片文件夹(/storage/emulated/0/DCIM)，音乐文件(/storage/emulated/0/Music) 这部分的目录是共享的，所以如果 App 往这个目录下读写文件，需要申请读写权限，并且在 App 卸载后不会被删除。 那我们接着看 Api 的使用获取内部存储目录 无需申请权限 Context.getFilesDir() 获取内部存储中 files 目录/data/data/com.application.id/files Context.getCacheDir() 获取内部存储中 cache 目录/data/data/com.application.id/cache Context.getDataDir()//Api &gt;= 24 获取内部存储的存储目录的绝对路径/data/data/com.application.id 获取外部私有存储目录 无需申请权限 Context.getExternalFilesDir(String type) 获取外部私有存储中的 files 目录或其子文件夹/storage/emulated/0/Android/data/com.application.id/filesor /storage/emulated/0/Android/data/com.application.id/files/type Context.getExternalCacheDir() 获取外部私有存储中的 cache 目录/storage/emulated/0/Android/data/com.application.id/cache 获取公有目录 读写需要权限写入权限 android.Manifest.permission#WRITE_EXTERNAL_STORAGE读取权限 android.Manifest.permission#READ_EXTERNAL_STORAGE 对应的 API Environment.getExternalStorageDirectory() 获取公有目录/storage/emulated/0 12345678910111213/** * type * #DIRECTORY_MUSIC * #DIRECTORY_PODCASTS * #DIRECTORY_RINGTONES * #DIRECTORY_ALARMS * #DIRECTORY_NOTIFICATIONS * #DIRECTORY_PICTURES * #DIRECTORY_MOVIES * #DIRECTORY_DOWNLOADS * #DIRECTORY_DCIM * #DIRECTORY_DOCUMENTS */ Environment.getExternalStoragePublicDirectory(String type) 获取公有目录下对应的类型文件夹/storage/emulated/0/DCIM 等 Android 10 分区存储机制然而，在 Android 10(Api 29) 上，我们发现通过 Environment 获取路径的 api 已经被标记为 Deprecated 的了 这…可咋整呢 其实，这对于 Android 用户来说，是一件好事来着。随着 Android 的发展，Google 对用户的隐私越来越看重了，慢慢地收紧了开发者对用户设备 sdcard 的读写权限 从 Android 10 开始，对于 Target Api 为 29 的应用，根据官方文档所描述，其访问权限范围限定为外部存储，即分区存储(Scoped Storage) 简单来说，应用只能通过访问Context.getFilesDir() 等 api 访问自己的私有目录(/data/data/packagename/)，以及通过Context.getExternalFilesDir(&quot;&quot;) 等 api 访问外部存储中自己应用的目录(/Android/data/packagename/)，无需申请权限，这个行为同之前一样，没有变动。 在 Target api &lt; 29 时，只要应用获取到了 WRITE_EXTERNAL_STORAGE 权限，就可以对整个 sdcard 目录进行读取，包括其他应用的 外部私有存储目录(/Android/data/otherAppPackageName/) 但是，在 Target Api &gt;=29 后，在 Android 10 设备上全新安装的应用，即便应用获得了WRITE_EXTERNAL_STORAGE权限后，应用也无法直接通过 Java File Api (例如 Environment.getExternalStorageDirectory()) 对 sdcard 中的非自己应用创建的文件进行读写操作。 这里的全新安装加了着重提示，应用是从 Target Api = 28 覆盖安装升级到 Target Api 29 的话，即便是安装在 Android 10 的手机上，若获得了WRITE_EXTERNAL_STORAGE权限，通过 Java File Api 仍然能够对 sdcard 中的任意文件进行读写操作 那…问题来了，在 Target Api &gt;= 29 上 应用自身需要将多媒体文件进行存储读取，该怎么做呢。 需要访问用户其他 APP 存储的文件(例如照片，视频)，又该如何适配呢 在 Android 的规范中，如果用户需要保存多媒体文件到手机中，应保存到共享目录(Share storage)中，以便其他应用访问，例如音乐应用中用户下载的音乐，拍照应用用户拍摄的照片，视频等 下面的表格总结了以上的内容，而至于如何通过 MediaStore Api 和 Storage Access Framework 进行增删查改，我们下文再续 下文来啦： Android MediaStore Api 使用 Android 存储访问框架 Storage Access Framework 如有错误，望各位斧正 Google 官方文档：Android 10 中的隐私权变更将文件保存到外部存储管理分区外部存储访问Data and file storage overview使用存储访问框架打开文件Overview of shared storage 本文参考文章： 感谢各位大大的分享 Android Q 存储机制大变化Android 存储使用参考Android 10 分区存储介绍及百度APP适配实践","link":"/2020/04/12/2020_04_12_about_android_file_path/"},{"title":"Android 存储访问框架 Storage Access Framework","text":"在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取/保存/修改手机中的文件等 SAF 包括三个部分 DocumentsProvider 内容提供程序，提供内容存储服务的应用可以实现该类，例如 Google Driver，Dropbox，OneDriver 等云存储服务甚至是本地存储服务，实现后用户可以在 Picker 中找到该程序所提供的内容 Client 客户端程序，即发起存储访问请求的客户端 Picker 一个系统界面，用户可以在该页面上操作符合条件的文件 这里有一张 Google 文档上的图，展示了如何通过 SAF 访问存储数据 通过 SAF 读写文件并不需要申请 WRITE_EXTERNAL_STORAGE 和 READ_EXTERNAL_STORAGE 权限 代码示例了解了 SAF 大致的工作原理后，我们还是回归到实践中，这里演示一下在应用开发中，如何通过 SAF 去访问用户手机上的内容 其实最主要的就是通过 Intent 唤起 Picker，交给用户去操作，然后在 onActivityResult 中获取到相对应的数据再由客户端进行处理 创建文件 创建文件需要让用户先通过 Picker 创建一个文件，再将该写入的路径提供给 Client 以供写入Intent.ACTION_CREATE_DOCUMENT 那如何让用户打开 Picker 呢，则需要 Client 通过 Intent 唤起 Picker 页面，由用户选择保存的位置和文件名后，点击确认后返回应用内。由客户端获取到 Uri 后对该文件进行写入等 123456789//重点在于这里的 Intent Actionval intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply { addCategory(Intent.CATEGORY_OPENABLE) //告知要保存的文件的 MIME 类型 type = &quot;image/png&quot; //提供保存的文件名，可选 putExtra(Intent.EXTRA_TITLE,&quot;myPicture.png&quot;) }startActivityForResult(intent, REQUEST_CODE_FOR_WRITE_IMAGE) 读取文件 读取文件需要用户选择文件后提供给 ClientIntent.ACTION_OPEN_DOCUMENT 比方说，我需要用户选择一张图片作为头像 则需要通过 Intent 唤起 Picker 12345678910111213companion object{ private const val REQUEST_CODE_FOR_IMAGE = 1}val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply{ //对结果进行过滤，只显示可打开的文件 addCategory(Intent.CATEGORY_OPENABLE) //过滤非 image 类型的文件 type = &quot;image/*&quot;}startActivityForResult(intent,REQUEST_CODE_FOR_IMAGE) 再在 Activity 的 onActivityResult() 回调中获取用户选择的文件的 Uri(即 data.data) 12345678910override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (resultCode == Activity.RESULT_OK){ when(requestCode){ REQUEST_CODE_FOR_IMAGE -&gt;{ data?.data?.let { showImage(it) } } } }} 获取到该 Uri 后则可以将该 Uri 转成 Bitmap 展示在 ImageView 中 编辑文件 编辑文件，同样的道理，你只需要通过 Intent 唤起 Picker，让用户选取文件后进行读写即可 删除文件 同样的，删除文件也需要获取到该文件的 uri 后才能进行操作通过 Picker 获取 Uri 的代码可以参考上文的获取文件 1DocumentsContract.deleteDocument(contentResolver, uri) 获取文件夹权限123val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE)startActivityForResult(intent,REQUEST_CODE_FOR_DIR) 通过唤起 Picker ，让用户选择目录授予 Client 该文件夹的完整访问权限，包括当前存储在该文件夹下的文件以及日后存储在该文件夹下的文件 同理，在 onActivityResult 中可以获取到该文件夹的 Uri 并进行读写操作。 在用户点击「允许访问 xx 」时，会弹出一个授权提示，如下图 如果用户授权之后，在应用管理中，我们也可以看到该 APP 多了一个「取消访问权限」的按钮 一旦用户点击「取消访问限制」，上图中「总计」下面所罗列出来的存储位置的权限都会被取消，并且 App 不会像点击应用管理中的 「清除缓存」那样被杀死，而是还会继续在运行，所以对于应用来说，要处理好对于文件夹 Uri 的权限处理 Uri 权限权限时间根据官方文档所述，我们通过上述的方式获取到的 Uri ，事实上系统会对该 Uri 对我们的 Client 进行授权，直到用户重启设备(正常情况下是这样) 因为事实上还可能有上述取消访问权限的情况 例如说，如果我们将获取到的 Uri 进行保存(存为字符串形式)，后续再通过 Uri.parse(String urlString) 方法构建出来的对象，也是可以对文件进行访问的(在用户授权后至重启之间) 如果需要在设备重启后还拥有对该 Uri 的权限，则需要获取系统提供的 Uri 持久授权，这样用户则可以在设备重启后继续在该 App Client 中持续访问该文件 1234//对 Uri 权限进行持久化val takeFlags: Int = intent.flags and (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)contentResolver.takePersistableUriPermission(uri, takeFlags) Caution: Even after calling takePersistableUriPermission(), your app doesn’t retain access to the URI if the associated document is moved or deleted. In those cases, you need to ask permission again to regain access to the URI.还有最后一个步骤。应用最近访问的 URI 可能不再有效，原因是另一个应用可能删除或修改了文档。因此，您应始终调用 getContentResolver().takePersistableUriPermission()，以检查有无最新数据。 官方文档上还有上述这一段描述，但是我的理解中，如果一个文件被移动或者删除了，那它所对应的 Uri 即便通过 takePersistableUriPermission 方法再次授权了，也是没有多大作用的呀？？这个方法本身不会有返回值告知开发者该 Uri 是否还能继续用，通过我的实验，在获取到 Uri 后，通过文件管理器等将文件进行删除，调用 takePersistableUriPermission 方法也不会 throw Exception，所以官方文档上的这个 move or deleted 我抱有疑问，望赐教 运行时权限处理如果用户在应用管理中取消了访问权限，在 App 中通过 contentResolver.takePersistableUriPermission方法对该 Uri 进行权限申请则会 throw 下面的 Exception 1java.lang.SecurityException: No persistable permission grants found for UID 10200 and Uri [user 0] 所以我们可以通过 try catch 判断是否拥有对该目录的访问权限？ 其实大可不必，通过 contentResolver.getPersistedUriPermissions 方法可以获取到该应用当前所拥有的权限列表，判断要使用的权限是否在列表当中即可 另外，授予了的 Uri 权限也可以通过 contentResolver.releasePersistableUriPermission 方法主动释放 总结SAF 其实就是通过用户在 Picker 获取 DocumentProvider 提供的内容，转为 Uri 对象提供给 Client 对其进行操作，而不是 Client 直接通过 File Api 操作 External Storage ，通过将权限由开发者申请转变为了让用户自行通过系统改的 Picker 选择，从而避免了申请 WRITE_EXTERNAL_STORAGE 和 READ_EXTERNAL_STORAGE 权限 参考文章：官方文档:中文版:使用存储访问框架打开文件英文版:Access documents and other files from shared storage 附录对于 Uri 来说，可以通过 ContentResolver 的 Api 对文件进行处理 例如上文中提到的将 Uri 处理为 Bitmap 的方法后续有空再来研究一下这些 api 以及 FileStream 的使用 下文代码大多转载于上述参考文章中的 Google 官方文档 12345678910111213141516//将图片 Uri 转为 Bitmapprivate fun showImage(uri: Uri){ GlobalScope.launch(Dispatchers.Main){ imageView.setImageBitmap(getBitmapFromUri(this@SAFActivity,uri)) }} suspend fun getBitmapFromUri(context: Context,uri: Uri): Bitmap{ return withContext(Dispatchers.IO){ val parcelFileDescriptor = context.contentResolver.openFileDescriptor(uri,&quot;r&quot;) val fileDescriptor = parcelFileDescriptor?.fileDescriptor val image = BitmapFactory.decodeFileDescriptor(fileDescriptor) parcelFileDescriptor?.close() return@withContext image }} 1234567891011121314151617181920//编辑文本文件 Uri 的内容private fun alterDocument(uri: Uri) { try { //&quot;w&quot; 指写(write)权限 //如果仅需要读(read)权限，传入 &quot;r&quot; 即可 contentResolver.openFileDescriptor(uri, &quot;w&quot;)?.use { // use{} lets the document provider know you're done by automatically closing the stream FileOutputStream(it.fileDescriptor).use { it.write( (&quot;Overwritten by MyCloud at ${System.currentTimeMillis()}\\n&quot;).toByteArray() ) } } } catch (e: FileNotFoundException) { e.printStackTrace() } catch (e: IOException) { e.printStackTrace() }} 123456789101112131415161718//读取文本 Uri 中的内容private fun getTextFromUri(uri: Uri): String{ val text = StringBuilder() contentResolver.openFileDescriptor(uri,&quot;r&quot;)?.use { FileInputStream(it.fileDescriptor).use{ BufferedReader(InputStreamReader(it)).use { bufferedReader-&gt; var line: String? = bufferedReader.readLine() while (null != line){ text.append(line) line = bufferedReader.readLine() } } } } return text.toString()}","link":"/2020/04/19/2020_04_19_about_Storage_Access_Framework/"},{"title":"那些和 so 库有关的问题","text":"旧文新发，看了自己的笔记应用，这是 18 年写的了，感觉应该还挺有用，分享一下吧 ABI 不同 Android 手机使用不同的 CPU，因此支持不同的指令集。CPU 与指令集的每种组合都有其自己的应用二进制界面（或 ABI）。 ABI 可以非常精确地定义应用的机器代码在运行时如何与系统交互。 您必须为应用要使用的每个 CPU 架构指定 ABI。 Android 上支持的 ABI 存放位置在 Android Studio 中，应该将 so 文件按照 ABI 分类并放置在 jniLibs 文件夹下 12345├── jniLibs│ ├── armeabi-v7a│ │ └── libjcore110.so│ └── x86│ └── libjcore110.so 查看 Android 设备支持的 ABI 类型一般来说，设备 ABI 都是固定的，这是系统在编译时决定的，在 /system/build.prop 指定了设备的 ABI 类型 primary ABI（主ABI）：对应当前系统中使用的机器码类型secondary ABI（副ABI）：表示当前系统支持的其他ABI类型 比如 Nexus 5 的 build.prop 文件中是这样的 12345ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabiro.product.cpu.abilist=armeabi-v7a,armeabiro.product.cpu.abilist32=armeabi-v7a,armeabiro.product.cpu.abilist64= 可以使用 adb 命令查看 12adb shellgetprop | grep abilist 可以查看当前设备支持的 ABI 类型。例如 Nexus 5 所支持的 ABI 类型 123[ro.product.cpu.abilist]: [armeabi-v7a,armeabi][ro.product.cpu.abilist32]: [armeabi-v7a,armeabi][ro.product.cpu.abilist64]: [] 或者在 Java 代码中，使用下面的代码获取 123Build.CPU_ABI//String 类型 primary ABIBuild.CPU_ABI2//String 类型 secondary ABIBuild.SUPPORTED_ABIS//String[] 类型 支持的 ABI 列表 可以看到该设备(Nexus 5)的主 ABI 是 armeabi-v7a，副 ABI 是 armeabi apk 安装过程apk 在安装的时候，Package Manager 会扫描 apk 文件，寻找符合条件的 so 库。现根据当前设备的 primary-abi 值，寻找对应的 so 文件，当不存在 primary 的 so 库时，会寻找 secondary 的 so 库。 即 lib/{primary-abi}/libName.so或者 lib/{secondary-abi}/libName.so 即当安装应用时，系统会根据当前设备的 CPU 架构寻找最优的 ABI 适配，如果找到合适的 so 文件，则会将整个 abi 文件夹下的 so 文件复制到 /data/data/{package.name}/lib 目录下。 注意：apk安装过程对so选择是基于整个ABI文件夹的，而非以单个so文件为粒度，也就是说把lib/armeabi 、lib/armeabi-v7a、lib/x86等等文件夹的其中一个文件夹内所有.so复制到应用的data目录下。 经验在我的一个 app 中，由于使用了某个第三方的 SDK ，这个第三方 SDK 只提供了 armeabi-v7a 的 so 库，并且我在这个项目中还引用了 React Native ，React Native 中包含了 x86 和 armeabi-v7a 的 so 库。所以当我在 Pad 上安装完后，打开应用后就奔溃了，奔溃日志如下： 1com.facebook.soloader.SoLoader$WrongAbiError: APK was built for a different platform 使用 Native Libs Monitor 这个软件查看该 app 安装的 so 库时发现，该 app 使用的全是 armeabi-v7a 的 so 文件，所以导致了Crash。 解决方案 方案一： 1补齐 x86 下的 so 文件 方案二： 1将第三方 SDK 提供的 so 文件复制一份到 x86 文件夹下，并在使用到这个 SDK 的功能时进行判断当前设备的 ABI ，如果是 x86 则提示用户该功能不可用。 配置ndkFilter在 build.gradle 中设置 ndkFilter 12345defaultConfig{ ndk { abiFilters &quot;armeabi-v7a&quot;,&quot;x86&quot; }} 这样的配置会使得打包后的 apk 文件中只保留 armeabi-v7a 和 x86 的文件夹。 splits可以通过 splits 生成指定的apk文件 12345678splits { abi { enable true reset() include 'x86', 'armeabi', 'armeabi-v7a', 'mips' //选择需要为 apk 编译的 ndk abi universalApk false //是否打包一个包含所有 abi 的 apk 包 }} 参考文章谈谈 Android 的 so","link":"/2020/04/12/2020_04_12_about_android_so_lib/"},{"title":"Android MediaStore Api 使用","text":"本文是对 关于 Android 的文件存储目录的补充 在 Android Q 后，获得 External Storage 的权限后 使用 Environment.getExternalStorageDirectory 和 File Api 对外置存储中的文件进行操作 这种方式已经不被允许了，需要开发者进行适配，后续开发者需要通过 Storage Access Framework 或者 MediaStore 的 Api 来对 External Storage 中的文件进行操作 关于权限 READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 通过 MediaStore Api 访问应用自身存放到公共目录下的文件不需要申请权限，而如果要访问其他应用保存到公共目录下的文件则需要申请权限 关于 MimeType从 com.android.media.MediaFormat 源码中我们可以找到 Android 定义好的一些 MineType 例如： 创建/保存文件构造一个 ContentValues 对象，通过 ContentResolver.insert 插入到对应的目录中，该方法会返回一个 Uri，通过对该 Uri 进行文件流写入即可 示例： 12345678910private fun saveImage(bitmap: Bitmap){ val values = ContentValues() val insertUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values) insertUri?.let { contentResolver.openOutputStream(it).use {outputStream-&gt; bitmap.compress(Bitmap.CompressFormat.PNG,100,outputStream) } }} 注意： ContentValues 其实是内部使用了一个 ArrayMap 的数据结构用来存放数据，所以我们可以根据我们需要保存的文件信息，给 ContentValues 设置对应的值例如： 12345val values = ContentValues().apply { put(MediaStore.Images.Media.MIME_TYPE,&quot;image/png&quot;) put(MediaStore.Images.Media.DISPLAY_NAME,&quot;${System.currentTimeMillis()}.png&quot;) put(MediaStore.Images.Media.RELATIVE_PATH,&quot;Pictures/DemoPicture&quot;) } 具体举几个例子，可见下面的表格 key value mime_type 设置文件的 MimeType _display_name 指定保存的文件名，如果不设置，则系统会取当前的时间戳作为文件名 relative_path 指定保存的文件目录，例如上文我们将这个图片保存到了 Pictures/DemoPicture 文件夹下，如果不设置这个值，则会被默认保存到对应的媒体类型的文件夹下，例如，图片文件(mimeType = image/*)会被保存到 Pictures(Environment#DIRECTORY_PICTURES) 中，需要注意的是，不能将文件放置到不对应的顶级文件夹下，比如将一个 mimeType 为 audio/mpeg 放大 Pictures 这样的行为是不被允许的，也就是如果设置 MIME_TYPE = audia/* 并将 RELATIVE_PATH 设置为 Environment#DIRECTORY_PICTURES 这样是会 Throw IllegalArgumentException 的 例如： 123456val values = ContentValues().apply { put(MediaStore.Images.Media.MIME_TYPE,&quot;image/png&quot;) //这里将 Movies 设置为了 Primary directory put(MediaStore.Images.Media.RELATIVE_PATH,&quot;${Environment.DIRECTORY_MOVIES}/DemoPicture&quot;) } val insertUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values) 结果是： 12345Caused by: java.lang.IllegalArgumentException: Primary directory Video not allowed for content://media/external/images/media; allowed directories are [DCIM, Pictures] at android.database.DatabaseUtils.readExceptionFromParcel(DatabaseUtils.java:170) at android.database.DatabaseUtils.readExceptionFromParcel(DatabaseUtils.java:140) at android.content.ContentProviderProxy.insert(ContentProviderNative.java:481) at android.content.ContentResolver.insert(ContentResolver.java:1828) Android 外部存储中的标准存储文件目录如下： 12345678910111213 sdcardaudio/* ├── Alarms ------ ├── Audiobooks image/* ├── DCIM file/* ├── Documents NA ├── Download video/* ├── Movies audio/* ├── Music audio/* ├── Notifications image/* ├── Pictures │ └── Screenshots audio/* ├── Podcasts audio/* └── Ringtones 前面一列为 MimeType ，后一列为其对应的 Primary Directory—— 表示未知 需要注意的是，对于 Android 中的媒体类型，如果是需要提供给其他应用使用的，在卸载后仍需保留的媒体文件，按照规范，应当放到对应的公共目录媒体文件夹下 MimeType 对应文件夹 图片(image/*) DCIM,Pictures 音频(audio/*) Alarms, Music, Notifications, Podcasts, Ringtones 视频(video/*) Movies 文档(file/*) Documents,Download 当然，这些也都可以通过 MediaStore 放到 Downloads 文件夹下 ContentValues 的 key 值可以通过 MediaStore.XXX.Media.YYY 获取到 XXX: 对应的媒体类型 YYY: 对应的字段常量 RELATIVE_PATH 的 String 值不需要以 / 开头 insert(uri: Uri,value: ContentValues) 的第一个参数可以通过 MediaStore 中的常量获取，具体如下 获取 insert 方法中的第一个入参的方式1234567891011* ImagesMediaStore.Images.Media.EXTERNAL_CONTENT_URI* AudioMediaStore.Audio.Media.EXTERNAL_CONTENT_URI* VideoMediaStore.Video.Media.EXTERNAL_CONTENT_URI* DownloadMediaStore.Downloads.EXTERNAL_CONTENT_URI* Documents//Documents 稍微有些特殊，需要通过 Files 获取MediaStore.Files.getContentUri(&quot;external&quot;) 疑问 1有个疑问是前文图标中标记为 ------ 未知的地方，根据官方文档，Audiobooks 是可以存放 audio/* 类型的文件的，但通过以下代码插入一个 audio/* 类型的文件却抛出异常了 12345678val values = ContentValues().apply { put(MediaStore.Audio.Media.MIME_TYPE,&quot;audio/*&quot;) put(MediaStore.Audio.Media.RELATIVE_PATH,&quot;${Environment.DIRECTORY_AUDIOBOOKS}&quot;) } val insertUri = contentResolver.insert(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,values)//Exception 信息Primary directory Audiobooks not allowed for content://media/external/audio/media; allowed directories are [Alarms, Music, Notifications, Podcasts, Ringtones] 其实就是 Android 会帮我们将这些媒体数据存放到一个数据库中，这些我们设置的数据都是数据库表中的字段，除了上面表格中罗列的一些常用的信息，还有很多数据可以设置，详细可以参考 android.media.MediaStore.MediaColumns 类，在这个类中我们发现了一个 owner_package_name 的字段，这个字段的作用，我们后面再说 删除自己应用创建的文件同 SAF ，获取到 Uri 后即可通过contentResolver.delete(uri,null,null) 删除即可 查询自己应用的文件 通过 Cursor query(@RequiresPermission.Read @NonNull Uri uri,@Nullable String[] projection, @Nullable String selection,@Nullable String[] selectionArgs, @Nullable String sortOrder) 方法 参数解释: 参数 类型 释义 uri Uri 提供检索内容的 Uri，其 scheme 是content:// projection String[] 返回的列，如果传递 null 则所有列都返回(效率低下) selection String 过滤条件，即 SQL 中的 WHERE 语句(但不需要写 where 本身)，如果传 null 则返回所有的数据 selectionArgs String[] 如果你在 selection 的参数加了 ? 则会被本字段中的数据按顺序替换掉 sortOrder String 用来对数据进行排序，即 SQL 语句中的 ORDER BY(单不需要写ORDER BY 本身)，如果传 null 则按照默认顺序排序(可能是无序的) 举个🌰 12345678910111213141516171819202122private fun getImages(): List&lt;Uri&gt;{ val external = MediaStore.Images.Media.EXTERNAL_CONTENT_URI val filesUris = mutableListOf&lt;Uri&gt;() contentResolver.query( //从图片媒体信息中进行查询 external, //只返回 |_ID|WIDTH|HEIGHT| 图片的 id和宽高的列信息 arrayOf(MediaStore.Images.Media._ID,MediaStore.Images.Media.WIDTH,MediaStore.Images.Media.HEIGHT) , //过滤掉 id 不满足大于 230 的图片 &quot;${MediaStore.Images.Media._ID} &gt; ? &quot;, arrayOf(&quot;230&quot;), //返回的数据按照 id 降序排序 &quot;${MediaStore.Images.Media._ID} DESC&quot;) ?.use { while (it.moveToNext()){ val index = it.getColumnIndex(MediaStore.Images.Media._ID) filesUris.add(ContentUris.withAppendedId(external,it.getLong(index))) } } return filesUris} 访问其他 App 的文件不知道大家有没有看到上面的标题写的都是「自己应用」的文件，这是因为我们的 App 至今还未申请 READ_EXTERNAL_STORAGE 和 WRITE_EXTERNAL_STORAGE 权限，通过 MediaStore Api 对自己应用创建的文件，是不需要权限的。这时因为在创建的时候系统会将我们的应用的 packageName 写入 owner_package_name 字段从而在后续的使用中判断这个文件是哪个应用创建的。 那如果应用需要访问或者修改其他应用的文件怎么办呢。 如果只是要读取，则申请 READ_EXTERNAL_STORAGE 权限后即可通过 MediaStore Api 进行读取 例如我们上述的查询自己应用的文件中的查询语句，如果申请了读取外置存储的权限后，返回的数据就会包含了其他 App 提供给 Media 的图片了 如下图： 没有读取权限时： 获得读取权限后： 多出来几张其他 App 产生的图片 如果需要编辑修改甚至删除其他应用的文件，则需要申请 WRITE_EXTERNAL_STORAGE 权限。 如果当应用没有 WRITE_EXTERNAL_STORAGE 权限时，去修改其他 App 的文件时，则会 throw java.lang.SecurityException: xxxx has no access to content://media/external/images/media/243 的异常 当应用拥有了 WRITE_EXTERNAL_STORAGE 权限后，当修改其他 App 的文件时，会 throw 另一个 Exception android.app.RecoverableSecurityException: xxxxxx has no access to content://media/external/images/media/243 如果我们将这个 RecoverableSecurityException 给 Catch 住，并向用户申请修改该图片的权限，用户操作后，我们就可以在 onActivityResult 回调中拿到结果进行操作了 12345678910111213141516171819202122232425262728293031323334try { val editImageUri = Uri.parse(&quot;content://media/external/images/media/${editOtherAppMediaId.text}&quot;) editImage(editImageUri)}catch (rse : RecoverableSecurityException){ rse.printStackTrace() requestForOtherAppFiles(REQUEST_CODE_FOR_EDIT_IMAGE,rse)}private fun requestForOtherAppFiles(requestCode: Int, rse: RecoverableSecurityException){ if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { // In your code, handle IntentSender.SendIntentException. startIntentSenderForResult( rse.userAction.actionIntent.intentSender , requestCode, null, 0, 0, 0, null) }}override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (resultCode == Activity.RESULT_OK){ when(requestCode){ REQUEST_CODE_FOR_EDIT_IMAGE -&gt;{ editImage(editImageUri) } REQUEST_CODE_FOR_DELETE_IMAGE -&gt;{ contentResolver.delete(deleteImageUri,null,null) } } }} 如下图，用户会收到这样的提示框。 PS. 当用户授权后，我们对该文件进行修改后，后续对这个文件的修改就不再会抛出 RecoverableSecurityException 了","link":"/2020/04/19/2020_04_19_how_to_use_Android_MediaStore_Api/"},{"title":"Java 字符串编码","text":"本文解释 Java 中的字符串编码 名词解释 名词 单位 解释 位 bit 计算机中最小的单位 用0/1标识 字节 byte 可表示常用英文字符8位二进制称为一字节，一字节可以存储2^8(=256)种状态 在 Java 中， char 占两个字节(2 byte)，即 16 bits UnicodeUnicode 是一个字符集，包含了全世界的几乎所有字符，现有的字符大约有百万多个，详见 https://home.unicode.org/ 编码码点(code point)代表 Unicode 字符集中的一个值，代表一个符号 代码单元(code unit)代表具体编码形式中的最小单位 在 Java 中，使用 UTF-16 作为内存中\b字符存储格式，即 16位，两个字节，只能存储 2^16 - 1 = 65535 个字符。 UTF-16 编码的规则很简单：基本平面的字符占用2个字节，辅助平面的字节占4个字节 则其 代码单元(code unit) 就是一个字节，在 Java 中，一个码点(code point)可能由两个代码单元(code unit)或者四个代码单元(code unit)组成 例如中字的码点为 U+4E2D，UTF-16 的编码为 \\u4e2d，占用两个代码单元(code unit)，一共占用两个字节(1个 char) 但是，在 Unicode 字符集已经远远超过 65535 个字符了，难道 Java 中不能表示 Unicode 中超过 65535 的字符了吗，当然不是 在 Java 中，char 为两个字节，即16位；在代码中可以使用 \\uxxxx 表示某个字符，但是只能表示 0x0000~0xFFFF 之间的字符，如果需要表示超过 0xFFFF以后的字符，则需要用两个 char 来表示，例如 💢 U+1F4A2 则使用 \\uD83D\\uDCA2 表示 很显然，这个 U+1F4A2 已经超过了基本面的范围0x0000-0xFFFF 这个\\uD83D\\uDCA2是如何计算出来的呢 在 UTF-16 编码中，基本面的字符使用两个字节表示，如上的中，辅助平面的字符使用四个字节表示。 也就是说在 UTF-16 中，一个字符要么为两个字节(位于[U+0000,U+FFFF]间)，要么为四个字节(位于[U+010000,U+10FFFF]间) 那么问题来了，当遇到两个字节时，是把它当做单独的字符，还是与后面的两个字节一起当成一个四字节的字符呢？ 在 UTF-16 中，辅助平面的字符使用 20个 bit 进行表示，分为两部分，高10位和低10位 0000000000 0000000000 UTF-16编码将超过 U+FFFF 的字符，会将其拆成两个字符表示，分别为H(高位 high) 和 L (低位 low)并将其映射到 U+D800-U+DBFF 和 U+DC00-U+DFFF 之间（基本平面中[U+D800,U+DFFF] 为空，不对应任何字符） 即一个四个字节的辅助平面字符会使用两个基本平面的字符来表示 因此，当遇到一个字符的码点超过 U+FFFF 时候，例如 💢 U+1F4A2 已经超过了 U+FFFF，则在 UTF-16 中使用四个字节表示，则需要进行计算出低位和高位的数值 先计算高位。减去超过的部分，得到数值 AA = 0x1F4A2 - 0x10000 = 0xF4A2 , 即 1 11101 00101 00010 将 A 补齐到20位二进制，得到 00001 11101 00101 00010将前十位映射到 U+D800-U+DBFF之间，后十位映射到 U+DC00-U+DFFF 之间 0xD800 的二进制为 110110 00000 000000xDC00 的二进制为 110111 00000 00000 高位：将前十位和 0xD800 相加，得到 1101100000111101 即 0xD83D低位：将后十位和 0xDC00 相加，得到 1101110010100010 即 0xDCA2 则得到 💢 U+1F4A2 的 UTF-16 的编码为 \\uDB3D\\uDCA2 具体的辅助平面字符的转换算法如下 1234H = (C - 0x10000) / 0x400 + 0xD800L = (C - 0x10000) % 0x400 + 0xDC00PS. 0x400 即 二进制的 1 00000 00000 至此，将一个 Unicode 字符转为 UTF16 的编码的方法已经探究完了，现在反过来看一下在遇到 UTF16 编码时，如何将其转为 Unicode 字符 还是以💢 U+1F4A2为例，其 UTF-16 编码为 \\uDB3D\\uDCA2，可见第一个字符 0xDB3D 位于 U+D800-U+DBFF之间 那么可以确定 \\uDB3D\\uDCA2 是一个占四个字节的字符 接下来再进行翻译 将前一个字符减去 0xDB00 ，后一个字符减去 0xDC00 即0xDB3D - 0xDB00 = 0x003D, 即 001111010xDCA2 - 0xDC00 = 0x00A2, 即 10100010 将高位H 和 低位L补齐到10位，即 00001111010010100010 再拼接一起，得到 00001 11101 00101 00010，再加上 0x10000(二进制为10000000000000000)，等于 123400001 11101 00101 0001000010 00000 00000 00000-----------------------00011 11101 00101 00010 得到 00011111010010100010(即0x1F4A2) 即💢 U+1F4A2 Java 中 String.length 返回的字符串对应的 char 的长度而不是人类认知中字符的长度 例如 123&quot;💢&quot;.length() == 2&quot;中文&quot;.length() == 2&quot;中&quot;.length() == 1 0001000010 1110110111 在 Java 中使用码点(Code Point) 来代表 Unicode 字符集中的每个字符，取值 0x000000(Character.MIN_CODE_POINT)-0x10FFFF(Character.MAX_CODE_POINT) 本文参考 彻底弄懂Unicode编码 感谢分享","link":"/2021/04/01/2021_04_01_java_string_encode/"},{"title":"Android 中的图片内存","text":"提出问题先提出一个问题，将两张分辨率相同(48px * 48px)，但文件大小不同的 png 图片，放在 drawable-xhdpi 文件夹下，在不同分辨率的手机上，所加载出来的 Bitmap 的占用内存大小分别是多少？ PS. 使用 Bitmap.getByteCount() 所获取的值作为占用内存的大小 通过以下代码获取 Bitmap 所占用的内存大小 12345678override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val bigBitmap = BitmapFactory.decodeResource(resources,R.drawable.big_png) val smallBitmap = BitmapFactory.decodeResource(resources,R.drawable.small_png) Log.d(TAG,&quot;small png bitmap size is ${smallBitmap.byteCount}&quot;) Log.d(TAG,&quot;bid png bitmap size is ${bigBitmap.byteCount}&quot;)} PS. 表格中的 dpi 的通过 resources.displayMetrics.densityDpi 方法获取 图片1 (分辨率 48px * 48px，文件大小 1.24kb) 图片2 (分辨率 48px * 48px，文件大小 1.27kb) 手机 分辨率 dpi 图片1 的 byteCount 图片2 的 byteCount Nexus S 480 * 800 hdpi/240dpi 5184 5184 Nexus 4 768 * 1280 xhdpi/320dpi 9216 9216 Pixel 1 1080 * 1920 420dpi 15876 15876 小米6 1080 * 1920 480dpi 20736 20736 Nexus 5 1080 * 1920 xxhdpi/480dpi 20736 20736 Pixel 3a 1080 * 2220 440dpi 17424 17424 Pixel XL 1440 * 2560 560dpi 28244 28244 通过以上的数据对比，可见图片1和图片2的即使文件大小不同，但运行时所占的内存都是相同的，因此我们猜测：图片运行时的内存大小和文件大小无关，只与图片的分辨率有关 接下来，我们再将两张图片放到 drawable-xxhdpi 文件夹下，再通过同样的方式进行计算，得出以下表格 手机 分辨率 dpi 图片1 的 byteCount 图片2 的 byteCount Nexus S 480 * 800 hdpi/240dpi 2304 2304 Nexus 4 768 * 1280 xhdpi/320dpi 4096 4096 Pixel 1 1080 * 1920 420dpi 7056 7056 小米6 1080 * 1920 480dpi 9216 9216 Nexus 5 1080 * 1920 xxhdpi/480dpi 9216 9216 Pixel 3a 1080 * 2220 440dpi 7744 7744 Pixel XL 1440 * 2560 560dpi 12544 12544 这回我们同样发现图片1和图片2所占的内存都是相同的，更加肯定了我们在第一个表格后的猜测 但是，通过表格②中的「Pixel 1、小米6 和 Nexus 5」的纵向对比，三个手机的分辨率均为1080 * 1920，但三个手机的 dpi 分别为 420dpi，480dpi 和 480dpi，占用的内存为 7056、9216 和 9216，因此我们猜测，图片所占内存的大小变化也跟手机的 dpi 有关，跟手机的分辨率无关 源码分析既然有以上的猜测，我们不如从源码中探索缘由 PS. 以下代码基于 Android 30 版本 在分析 decodeResource 方法之前，我们先来看一些基础概念 基本概念android.util.DisplayMetrics#density: Float 显示的逻辑密度，这是 dip 单位的比例系数.一个 dip 大概是 160dpi 屏幕上的的一个像素(例如分辨率240x320.尺寸为 1.5”x2”的屏幕)，按这个标准提供显示的基准。因此在 160dpi 的屏幕上，这个值为1，在120dpi 的屏幕上，这个值为 0.75，在480dpi 的屏幕上，这个值为3.依次类推 1计算方式：density = densityDpi/160 android.util.DisplayMetrics#densityDpi: Int 缩写为 dpidots-per-inch 屏幕密度，表示每英寸屏幕上的像素点个数 1计算方式为 dpi = 斜边长/英寸 在 Android 设备中，将 densityDpi 将设备分成多个显示级别，如下表 ldpi mdpi hdpi xhdpi xxhdpi dpi 0-120 120-160 160-320 320-480 480-640 比例 1dp 0.75px 1px 2px 3px 4px 由于 mdpi 中 1dp 刚好等于 1px 所以将 mdpi 作为基准屏幕密度 一般来说设备都会在出厂时设置一个默认的 dpi ，设置其范围内的最大值 dip/dp 全称为 Density Independent Pixel密度独立像素 1计算方式为 dip/dp = px / (dpi / 160) TypeValue12345TypedValue typedValue = new TypedValue();Resources resources = getResources();int id = resources.getIdentifier(&quot;ic_launcher&quot;,&quot;mipmap&quot;,getPackageName());resources.openRawResource(id,typedValue);int density = typedValue.density; android.util.TypedValue#density: Int如果是从 resource 中加载的图片等，这个值将会存储相对应的像素密度 例如： 从 ldpi 加载的 density == 120 从 mdpi 加载的 density == 160 decodeResourcedecodeResource(Resources res, int id)123public static Bitmap decodeResource(Resources res, int id) { return decodeResource(res, id, null);} decodeResource(Resources res, int id, Options opts)1234567891011121314151617181920212223242526272829public static Bitmap decodeResource(Resources res, int id, Options opts) { validate(opts); Bitmap bm = null; InputStream is = null; try { final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); } catch (Exception e) { /* do nothing. If the exception happened on open, bm will be null. If it happened on close, bm is still valid. */ } finally { try { if (is != null) is.close(); } catch (IOException e) { // Ignore } } if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) { throw new IllegalArgumentException(&quot;Problem decoding into existing bitmap&quot;); } return bm;} -&gt; 最后走到 android.graphics.BitmapFactory#decodeResourceStream 方法 1234567891011121314151617181920212223242526272829303132public static Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts) { validate(opts); //如果 opts 为空，则 new 一个 Options 对象，默认为空 if (opts == null) { opts = new Options(); } //设置 opts 的 inDensity 参数 if (opts.inDensity == 0 &amp;&amp; value != null) { //只有当 opts.inDensity 为0 且 TypedValue 不为空时才进行赋值 //获取 TypedValue 的 density 值() final int density = value.density; if (density == TypedValue.DENSITY_DEFAULT) { //如果 density 为默认值(0)，则设置 inDenisity 为 DisplayMetrics.DENSITY_DEFAULT(160) opts.inDensity = DisplayMetrics.DENSITY_DEFAULT; } else if (density != TypedValue.DENSITY_NONE) { //如果 density 不为 DENSITY_NONE(0xffff) //只有放在 nodpi 中的图片的 density 会被设置为 DENSITY_NONE opts.inDensity = density; } } if (opts.inTargetDensity == 0 &amp;&amp; res != null) { //如果 opts 的 isTargetDenisity 为0且 res 不为空，则将设备的 densityDpi 赋值给 inTargetDensity opts.inTargetDensity = res.getDisplayMetrics().densityDpi; } return decodeStream(is, pad, opts);} 最后走到 decodeStream() 中的 native 方法中对图片进行解码 在 native 代码中，会根据前面的方法中的 BitmapFactory.Options 中设置的参数 inDensity 和 inTargetDensity 参数，对图片进行缩放 简单来说：inDensity 代表资源文件所在的文件夹 dpiinTargetDenisity 代表 bitmap 会被绘制的地方的像素密度 从 BitmapFactory.cpp 中可以看到 12345678if (env-&gt;GetBooleanField(options, gOptions_scaledFieldID)) { const int density = env-&gt;GetIntField(options, gOptions_densityFieldID); const int targetDensity = env-&gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-&gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 &amp;&amp; targetDensity != 0 &amp;&amp; density != screenDensity) { scale = (float) targetDensity / density; } } 当 isDenisity 、inTargetDensity 不为0，且 isDenisity != inScreenDensity 时候，会将图片进行缩放 缩放比例为 (float)inTargetDensity/isDenisity 内存大小计算至此，我们可以回到文章开头的两个表格，来看一下图片所占用的内存是如何计算出来的 在计算之前，我们还要再看一个参数 Bitmap.Config 在 BitmapFactory.Options 中，inPreferredConfig 段默认为 ARGB_8888该参数代表图片解码时使用的颜色模式 Bitmap.Config 字节数 备注 ALPHA_8 1 每个像素占8bit,存储图片的透明值 RGB_565 2 每个像素占16bit，RGB 通道分别占用5，6，5bit，存储图片的 RGB 值 ARGB_4444(已废弃) 2 每个像素占16bit,即每个通道用4bit表示 ARGB_8888 4 每个像素占32bit,即每个通道用8bit表示 RGBA_F16 8 各个枚举中的数字之和代表其位数，例如 ARGB_8888 则占用 8+8+8+8 = 32bit = 4byte 现在我们可以计算出一张图片在解码后所占用的内存了 内存 = (图片像素宽 * scale ) * (图片像素高 * scale ) * 每个像素点内存占用 其中 scale = (float)inTargetDensity/inDenisity 我们来对上述的表格进行验证对于表格1中由于我们将资源文件放在了 xhdpi 文件夹中，所以 inDenisity = 320 Nexus S 设备scale = (float)240/320 = 0.75图片的内存 = (48 * 0.75 ) * (48 * 0.75 ) * 4 = 5184 Pixel 1scale = (float)420/320 = 1.3125图片的内存 = (48 * 1.3125 ) * (48 * 1.3125 ) * 4 = 15876 小米6scale = (float)480/320 = 1.5图片的内存 = (48 * 1.5 ) * (48 * 1.5 ) * 4 = 20736 同理可以验证表格2 中的数据 内存优化由以上的 Bitmap 内存占用可知，要优化 bitmap 的内存大小可以从以下几个方面出发 将正确的资源图片放到正确的目录下🐶 通过表格2和表格1的对比，如果本应放在 xxhdpi 下的图片如果放到了 xhdpi 下，会导致 bitmap 占用的内存变大 对资源图片进行取样，根据所展示的 view 的宽高修改图片解码时采样率，以降低图片的分辨率 eg. 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * ImageView 设置资源图 * 会根据宽高对资源文件的采样率进行压缩，减少内存占用 * @param resId 资源文件 id * @param width 展示图片的 View 的宽度 * @param height 展示图片的 View 的高度 */fun ImageView.setImage(resId: Int,width: Int,height: Int){ val bitmap = BitmapFactory.Options().run { inJustDecodeBounds = true BitmapFactory.decodeResource(resources,resId,this) inSampleSize = calculateInSampleSize(this,width,height) inJustDecodeBounds = false BitmapFactory.decodeResource(resources,resId,this) } Log.d(&quot;ImageViewExt&quot;,&quot;bitmap size is ${bitmap.byteCount}&quot;) this.setImageBitmap(bitmap)}/** * 根据宽高计算采样率 */fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int { // Raw height and width of image val (height: Int, width: Int) = options.run { outHeight to outWidth } var inSampleSize = 1 if (height &gt; reqHeight || width &gt; reqWidth) { val halfHeight: Int = height / 2 val halfWidth: Int = width / 2 // Calculate the largest inSampleSize value that is a power of 2 and keeps both // height and width larger than the requested height and width. while (halfHeight / inSampleSize &gt;= reqHeight &amp;&amp; halfWidth / inSampleSize &gt;= reqWidth) { inSampleSize *= 2 } } return inSampleSize}","link":"/2021/05/07/2021_05_07_bitmap_in_android/"},{"title":"Handler 消息机制","text":"在 Android 中，使用 Handler 主要用于不同线程间的通信 本文基于 Target 30 的 Android 源码进行分析 先来看几个类 概念Handler : 消息处理类，用来发送和处理 Message Looper : 循环器，将消息发送给 Handler 进行处理 MessageQueue : 消息队列 Message : 消息 简介Handler 消息机制 UML 类图 消息机制类比图 1. Example先来看个例子 12345678910111213141516171819202122232425262728293031323334class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val button = Button(context) setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT)) button.setOnClickListener { thread { Log.d(&quot;MainActivity&quot;,&quot;thread is ${Thread.currentThread().name}&quot;) Looper.prepare() val looper = Looper.myLooper()!! val handler = MyHandler(looper) val message = Message().apply { what = 1 obj = &quot;message&quot; } handler.sendMessage(message) Looper.loop() } } } class MyHandler(looper: Looper) : Handler(looper){ /** * Subclasses must implement this to receive messages. */ override fun handleMessage(msg: Message) { super.handleMessage(msg) //① Log.d(&quot;MyHandler&quot;,&quot;thread is ${Thread.currentThread().name} msg.what is ${msg.what}&quot;) } }} 日志如下： 12MainActivity: thread is Thread-3MyHandler: thread is Thread-3 msg.what is 1 每点击一次按钮，会创建一个新的线程，并在该线程中通过 handler 将消息分发给 MyHandler#handleMessage 进行处理，在这个例子中，MyHandler#handleMessage 和 thread{} 是同一个线程，并没有跨线程通信，所以对于线程间的通信来说，这个例子并没有什么意义，只是大概告知一下 Handler 的使用，但事实上，在 Android 的主线程(即 UI 线程、Main Thread) 就是通过这种方式对消息进行分发的 详见 ActivityThread#main() 1234567891011121314151617181920212223242526public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); //......忽略一些细节 Looper.prepareMainLooper(); //......忽略一些细节 ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 在进行跨线程通信中，例如在子线程中做完耗时任务后，通知主线程更新UI 我们会在子线程中获取到主线程的 Looper (Looper.getMainLooper()) 后，使用一个持有该 Looper 的 Handler 发送一个消息，而后在该 Handler 的 handlerMessage 方法中接收该消息进行更新UI 等操作 eg. 将上述例子中的 Handler 的 Looper 替换，则在 1234567891011thread { Log.d(&quot;MainActivity&quot;,&quot;thread is ${Thread.currentThread().name}&quot;) val handler = MyHandler(Looper.getMainLooper()) val message = Message().apply { what = 1 obj = &quot;message&quot; } handler.sendMessage(message)} 日志如下： 可见已经切换到主线程中接收到信息了 12MainActivity: thread is Thread[main,5,main]MyHandler: thread is main msg.what is 1 通过以上的例子，我们来分析 Android 中的消息机制到底是如何运作的 2. Looper2.1 prepare() 将当前线程初始化为循环线程 123456private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed));} 可见，第一次调用 prepare() 方法时会在当前线程中 new 一个 Looper 对象，并保存在该线程的 mThreadLocal 中 若在同个线程中多次调用 prepare 方法，则会走到 if 的 case 中抛出异常 因此保证在同一个线程中只有一个 Looper 对象存在 2.2 myLooper() 获取当前线程 looper 的方法 123public static @Nullable Looper myLooper() { returnsThreadLocal.get();} 即返回在 prepare() 方法中保存的 Looper 对象 2.3 loop()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public static void loop() { final Looper me = myLooper(); if (me == null) { //Looper 还没有初始化，则抛出异常 throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;); } if (me.mInLoop) { Slog.w(TAG, &quot;Loop again would have the queued messages be executed&quot; + &quot; before this one completed.&quot;); } me.mInLoop = true; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); boolean slowDeliveryDetected = false; for (;;) { //开始进入死循环 //获取消息队列中的第一条消息，可能回阻塞 Message msg = queue.next(); // might block if (msg == null) { //如果当前没有需要处理的消息，则返回，继续下一个循环 // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } // Make sure the observer won't change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) { slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; } final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) { token = observer.messageDispatchStarting(); } long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try { //消息不为空，分发给消息对应的 target(即 Handler)去处理 msg.target.dispatchMessage(msg); if (observer != null) { observer.messageDispatched(token, msg); } dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } catch (Exception exception) { if (observer != null) { observer.dispatchingThrewException(token, msg, exception); } throw exception; } finally { ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (logSlowDelivery) { if (slowDeliveryDetected) { if ((dispatchStart - msg.when) &lt;= 10) { Slog.w(TAG, &quot;Drained&quot;); slowDeliveryDetected = false; } } else { if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) { // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; } } } if (logSlowDispatch) { showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); } if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } //该消息处理完了，将其回收复用 msg.recycleUnchecked(); } } 可见 loop() 方法中是一个 for(;;) 的死循环 大概分成： 从当前 looper 对应的 messageQueue 中通过 ,mQueue.next() 方法获取下一个 Message[该方法可能会阻塞，详见 5.2 MessageQueue#next()] 分发给 Message 对应的 target (即 Handler)[ target 赋值见 4.3.1 android.os.Handler#enqueueMessage] 交由 Handler 的 dispatchMessage [见 4.4 android.os.Handler#dispatchMessage] 去处理 最后再将 Message 进行回收利用[见 3.3 Message#recycleUnchecked()] 接着不断的重复这个过程 由于 loop() 方法中进行的是死循环，所以在 loop() 方法后的代码是不会被调用到的 loop() 方法中，获取下一条消息的方法 messageQueue.next() 是阻塞的，所以当 messageQueue 中没有新的消息了，loop() 会阻塞住[见 MessageQueue#next()]，所以不会造成 CPU 的高消耗 3. MessageMessage 是整个消息分享机制中的「信使」，将信息从 A 带给 B Message 类中包含以下一些字段 成员变量 类型 解释 what Int 开发者自定义的一个 code 字段，用来标识是什么类型的消息后续进行处理 arg1 Int arg1 和 arg2 都是用来存储数据的备选方案，如果需要存储的数据不多而不想使用 data 的话，则可以考虑使用该字段 arg2 Int 同上 data Bundle 用于在 Message 中存储自定义数据 obj Object 用于发送给接受者的任意对象，注意，如果使用 Messager 在跨进程中的发送数据时，只能发送 framework 中的 Parcelable 对象，且不能为 null，不能发送自定义的 Parcelable 对象，要发送自定义的 Parcelable 对象应该使用 setData 方法 when Long Message 的目标发送处理时间，这个时间是基于系统开机时间计算的SystemClock#uptimeMillis target Handler 用于处理该消息的 Handler callback Runable Runnable 类型 next Message Message 的下一个 Message，可见 Message 是一个单链表的数据结构 sPool Message 用来做 Message 的缓存池 3.1 obtain() 从 Message 缓存池中获取一个 Message 对象 12345678910111213public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message();} sPoolSync 是一个锁对象，用来在对 Message 进行复用回收时候进行线程同步处理，避免多线程访问时的内存数据共享错误 首先通过上面的 Message#next 我们知道 Message 是一个单链表的数据结构 obtain() 方法判断当 sPool 不为空时，即已经有被创建出来的 Message 对象了，则赋值给 m 并将 m.next 赋值给 sPool，即将单链表中的第一个节点取出，并将第二个节点作为 sPool ，即剩下的链表继续作为缓存池，同时将缓存池的数量减一。最后将需要返回的 m 的 next 赋值为 null，清除 flag 等并返回 m 3.2 recycler()12345678910public void recycle() { if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); } return; } recycleUnchecked();} 先检查该 Message 是否还在被使用，如果还在被使用则抛出异常，否则对该 Message 进行回收，详见 3.3 recyclerUnchecked() 3.3 recyclerUnchecked()123456789101112131415161718192021222324void recycleUnchecked() { // Mark the message as in use while it remains in the recycled object pool. // Clear out all other details. flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = UID_NONE; workSourceUid = UID_NONE; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { if (sPoolSize &lt; MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } }} 这个方法就很简单了，将 Message 的成员变量都还原为初始化状态，接着将该 Message 插入到缓存池链表的头部，并更新缓存池的数量 4. Handler4.1 构造方法12345678910111213public Handler(@Nullable Callback callback, boolean async) { //...忽略... mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;} 123456public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;} 两个构造方法的区别在于是否有 Looper 参数 如果没有传入 Looper 参数，则会调用 Looper.myLooper() 方法获取当前线程中的 Looper 赋值给 mLooper ，如果当前线程的 Looper 还未初始化，则抛出异常 4.2 sendMessageDelayed(Message msg , long updateMillis)Handler 中的 post(Runnable r) 、postDelayed(@NonNull Runnable r, long delayMillis) 等等方法最终都会调用 boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) 方法，我们先来看如何将 Runnable 转为 Message 的方法，再接着看 sendMessageAtTime 123456public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) { if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);} 这里有个值得注意点是，传入 sendMessageAtTime 方法中的第二个参数是用的是 SystemClock.uptimeMillis() 即当前距离开机的时间，使用这个时间就不会因为机器的时间戳变化而导致不准确的问题 4.2.1 getPostMessage(Runnable r)12345private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m;} 即从缓存池中获取一个 Message 对象，并将其 callback 设置为传入的 Runnable 对象 至于这个 callback 的作用，详见 4.4 dispatchMessage 4.3 sendMessageAtTime(Message msg, long uptimeMillis)12345678910public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);} sendMessageAtTime 方法会先判断当前 Handler 中的消息队列 mQueue 是否为空，如果为空则抛出异常并打印日志返回 否则调用 enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,long uptimeMillis) 方法将该 Message 消息对象放入消息队列中 4.3.1 enqueueMessage(MessageQueue queue,Message msg,long updateMillis)将 Message 的 target 设置为当前的 Handler 对象，并压入 MessageQueue 队列中 12345678910private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);} MessageQueue 的 enqueueMessage 方法详见 5.1 MessageQueue#enqueueMessage() 4.4 dispatchMessage在 4.3.1 方法中，enqueueMessage 方法将 Message 压入 MessageQueue 后，会被 2.3 Looper#loop() 不停获取队列中的 Message 并交由其 target(即 Handler) 处理 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(@NonNull Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} 首先会判断 msg 的 callback 是否为空，如果不为空，则调用该 callback 的 run 方法 由 3. Message 中我们知道 callback 就是一个 Runnable 对象 如果 callback 为空，则判断 Handler 的成员变量 mCallback 是否为空，如果不为空，则调用其接口方法 boolean andlerMessage(Message msg) ，由实现了该 Handler.Callback 接口的子类自行处理 如果 Handler 中设置了 Handler.Callback，则回调其 handleMessage 方法对消息进行处理，否则则调用 public void handleMessage(@NonNull Message msg) 方法，由子类 Override 该方法对信息进行处理 PS. 如果 Handler.Callback 的 handleMessage() 方法返回了 true，则代表不再需要对该消息进行处理，否则还会调用 handleMessage 方法对该消息进行处理 5. MessageQueue MessageQueue 是一个消息队列 5.1 enqueueMessage()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667boolean enqueueMessage(Message msg, long when) { //如果 Message 没有设置 target 则抛出异常 if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } synchronized (this) { if (msg.isInUse()) { //如果该 message 已经在使用了，抛出异常 throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } //将消息标记为在使用中 msg.markInUse(); //将执行时间赋值给 when msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { //如果 p == null(即当前消息队列没有消息) //或者 when == 0(即该消息需要立即处理) //或者 when &lt; p.when(即该消息比当前队列中的消息的需要执行的时间要早) //则将该消息插入到最前面处理 // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //将消息插入到队列中间 //通常来说，我们不需要唤醒事件队列，除非在队列的头是一个屏障消息(target == null),并且要插入的消息是队列中的第一个异步消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; // //下面是个死循环，直到找到队列中的消息的执行时间(when 字段)小于该插入消息的时间的，插在其前面，如果没有，则插入到队列最后面 for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { //如果 p 是异步消息，说明要插入的消息不是第一个异步消息(因为走到这里来说明要插入的消息是插入到了 p 后面了)所以不需要唤醒 needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true;} 参数 when 是指需要执行的时间戳(用距离机器开机的时间来计算) 先判断 Message 的 target 是否为空，为空则抛出异常 再判断 Message 是否被使用了，如果该 Message 已经被使用了则抛出异常 再判断是否已经退出了，如果已经退出了则将 Message 回收并返回 false 以上检查无异常后，将 Message 标记为在使用 着重看一下后面的一段代码 判断 p 是否为空(即当前的消息队列为空) when == 0(即该消息需要立即执行) when&lt; p.when(即该消息的执行时间早于消息队列的第一条消息的执行时间) 如果满足以上任何一个条件，则将该 Message 插入到队列的头部 否则对 消息队列进行遍历，直到将该消息插入到执行时间都比该消息小的消息后面 可见，MessageQueue 是按照 Message.when 对消息进行排序的，链表中的 Message 按照 when 的大小排序 5.2 next()next() 内部有一个 for(;;) 的死循环，一直从 Message 链表中获取符合条件的 Message 并进行返回如果在某次循环中获取不到 msg ，则会去处理 idle handler ，处理完后将 pendingIdleHandlerCount 置为 0，保证下次循环不处理 idle 了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. //如果消息循环已经退出并且被处理了，则会在这里 return //这种情况可能发生在如果应用尝试在退出后重启 looper final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } //这里会进行休眠，相对应的 nativeWait() 会进行唤醒 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. //尝试检索下一条消息，如果找到了就返回 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { //当前消息队列不为空，且 target 为 null，注意这里的 target 为 null //则从消息队列中找到异步的 Message // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); //msg 不为空且为同步的消息，则继续循环直到找到异步的消息 } //此时 msg 就是第一个需要进行处理的 Message（可能是消息屏障后的第一个消息，也可能是原本消息队列中的头，即 mMessage） if (msg != null) { if (now &lt; msg.when) { //如果当前时间还没到消息需要处理的时间，则设置一个延时时间，这里不会 return Message， //如果还没到消息需要处理的时间，所以 for 循环会一直进入这个 case 导致阻塞在这里 // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { //消息需要处理，则将该消息返回，并将链表的第二个数据移到链表头，并退出循环 // Got a message. mBlocked = false; if (prevMsg != null) { //如果 prevMsg 不为 null，说明 msg 为需要处理的异步消息，被提前取出来处理了 //而 prevMsg 就是该消息的前一个消息，现在将 msg.next 链接到 prevMsg.next 的后面，(其实就相当于删除了中间的 msg) //此时的 mMessage 还是原来的 mMessage，下次进入 next() 方法 mMessage 还是原来的那个 prevMsg.next = msg.next; } else { //将链表的第二个数据移到链表头 mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //如果第一次闲置，则会获取 idleHandlers 的数量 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } //如果 idleHandler 数量小于0，则跳过后面的 idleHandler 的逻辑，继续下一个 next() 循环 if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } //否则 if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } //将外部添加进来的 mIdleHandlers 列表拷贝到 mPendingIdleHandlers 数组中 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. //运行 idle Handler 的逻辑，这里只可能在第一次 for 循环的迭代时被执行 //(因为后面将 pendingIdleHandlerCount 置为 0了，所以导致后续 pendingIdleHandlerCount 一直为 0) for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { //IdleHandler 各自处理逻辑，并返回是否需要被移除 keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { //如果返回需要被移除，则移除该 idleHandler synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. //将待办的闲置 IdleHandler 的数量置为 0 pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; }} 5.3 quit()将 mQuitting 标志位置为 true，后续 MessageQueue 的 next() 方法等地方 使用该字段做判断后进行处理 6. 消息同步屏障 同步屏障，顾名思义，将同步的消息给挡住，优先处理非同步(即异步)的消息 从以上我们 MessageQueue#next() 中，我们知道从 MessageQueue 中获取队列中的消息时，会优先获取异步的消息(msg.isAsynchronous() == true)进行处理 6.1 如何开启同步屏障按理来说，要开启同步屏障，我们只需要在 MessageQueue#postSyncBarrier(long when) 方法中，会在 MessageQueue 消息队列的队头插入一个 message(这个 Message 的 target 为 null) 即可 这个 message 仅仅作为一个标志存在，并不用来分发事件，当 looper 在进行循环🔄时，调用 queue.next() 方法，当遇到 message.target == null ，则会从 MessageQueue 中找到异步的消息并返回 但是由上文可知，在调用 enqueueMessage 方法后，会将 msg 的 target 赋值为当前的 Handler 导致我们的上面想插入一个 target == null 的 Message 的想法不成立 并且 MessageQueue#postSyncBarrier() 方法并不开放给开发者使用，所以要开启同步屏障，我们只能通过反射该方法进行调用 而如果直接使用 Handler.sendMessage() 等方法插入消息，会根据时间顺序插入到队列中，如果要立即生效，则需要将消息插入队列队头，如何将消息插入到队列头部，详见 *** 6.3 如何将消息插入队列头部 *** 6.2 如何插入异步消息 构造异步 Handler从 4.3.1 enqueueMessage 中可以看到，当 mAsynchronous 字段为 true 时候，会将 message 设置为异步消息所以只需要在构造 Handler 的时候，将构造方法中的 async 字段设置为 true 即可，则后续所有的消息都会是异步的消息 构造异步的 Message 在构造 Message 时，通过 setAsynchronous(boolean async) 方法设置该消息为异步消息即可 6.3 如何将消息插入队列头部由上述分析我们知道通过 Handler#enqueMessage() 方法将消息插入 MessageQueue 中，会根据 message.when 由小到大插入到队列中，如果需要将消息插入到队头，那么应该使得 when 为 0，但 when 这个参数也是不支持开发者修改的 但是 Handler 中提供了一个 Handler#postAtFrontOfQueue (最终调用 Handler#sendMessageAtFrontOfQueue) 方法。这个方法在将消息插入队列前，会将 when 设置为0，则会将该消息插入到消息队列的队头 7. 举例1234567891011121314151617181920212223242526272829303132333435private val normalHandler by lazy { Handler(Looper.getMainLooper(),object : Handler.Callback{ override fun handleMessage(msg: Message): Boolean { Log.d(TAG,&quot;普通 Handler 回调 msg is $msg&quot;) return true } })}private val asyncHandler by lazy { Handler.createAsync(Looper.getMainLooper(),object : Handler.Callback{ override fun handleMessage(msg: Message): Boolean { Log.d(TAG,&quot;异步 Handler 回调 msg is $msg&quot;) return true } })}private fun testSendNormalMessage(){ Log.d(TAG,&quot;普通 Handler sendMessage start&quot;) normalHandler.sendMessage(Message().apply { obj = &quot;普通 Handler 调用 sendMessage 发送的消息&quot; }) Log.d(TAG,&quot;普通 Handler sendMessage end&quot;) Log.d(TAG,&quot;异步 Handler sendMessageAtFrontOfQueue start&quot;) asyncHandler.sendMessageAtFrontOfQueue(Message().apply { obj = &quot;异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息&quot; }) Log.d(TAG,&quot;异步 Handler sendMessageAtFrontOfQueue end&quot;) Log.d(TAG,&quot;异步 Handler sendMessage start&quot;) asyncHandler.sendMessage(Message().apply { obj = &quot;异步 Handler 调用 sendMessage 发送的消息&quot; }) Log.d(TAG,&quot;异步 Handler sendMessage end&quot;) Log.d(TAG,&quot;普通 Handler sendMessageAtFrontOfQueue start&quot;) normalHandler.sendMessageAtFrontOfQueue(Message().apply { obj = &quot;普通 Handler 调用 sendMessageAtFrontOfQueue 发送的消息&quot; }) Log.d(TAG,&quot;普通 Handler sendMessageAtFrontOfQueue end&quot;)} 打印日志如下： 123456789101112普通 Handler sendMessage start普通 Handler sendMessage end异步 Handler sendMessageAtFrontOfQueue start异步 Handler sendMessageAtFrontOfQueue end异步 Handler sendMessage start异步 Handler sendMessage end普通 Handler sendMessageAtFrontOfQueue start普通 Handler sendMessageAtFrontOfQueue end普通 Handler 回调 msg is { when=-4d23h57m46s154ms what=0 obj=同步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler }异步 Handler 回调 msg is { when=-4d23h57m46s154ms what=0 obj=异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler }普通 Handler 回调 msg is { when=-13ms what=0 obj=普通 Handler 调用 sendMessage 发送的消息 target=android.os.Handler }异步 Handler 回调 msg is { when=-13ms what=0 obj=异步 Handler 调用 sendMessage 发送的消息 target=android.os.Handler } 此时的 asyncHandler 并不能将其消息插入到消息队列的最前面，而是取决于其插入的顺序，后调用 sendMessageAtFrontOfQueue 的消息后插入到前面去 如果要使得 asyncHandler 插入的消息能优先处理，则需要同步屏障起作用，我们先通过反射开启一下同步屏障，再在使用完毕后关闭同步屏障 123456789101112private var barrierToken = 0fun startReflectPostSyncBarrier(looper: Looper){ val method: Method = MessageQueue::class.java.getDeclaredMethod(&quot;postSyncBarrier&quot;) barrierToken = method.invoke(looper.queue) as Int}fun stopReflectPostSyncBarrier(looper: Looper){ val method = MessageQueue::class.java .getDeclaredMethod(&quot;removeSyncBarrier&quot;, Int::class.javaPrimitiveType) method.invoke(looper.queue, barrierToken)} 在调用 testSendNormalMessage 方法前先调用 startReflectPostSyncBarrier 方法，建立起同步屏障 日志打印如下： 1234567891011普通 Handler sendMessage start普通 Handler sendMessage end异步 Handler sendMessageAtFrontOfQueue start异步 Handler sendMessageAtFrontOfQueue end异步 Handler sendMessage start异步 Handler sendMessage end普通 Handler sendMessageAtFrontOfQueue start普通 Handler sendMessageAtFrontOfQueue end普通 Handler 回调 msg is { when=-5d0h9m7s27ms what=0 obj=普通 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler }异步 Handler 回调 msg is { when=-5d0h9m7s27ms what=0 obj=异步 Handler 调用 sendMessageAtFrontOfQueue 发送的消息 target=android.os.Handler }异步 Handler 回调 msg is { when=-11ms what=0 obj=异步 Handler 调用 sendMessage 发送的消息 target=android.os.Handler } startReflectPostSyncBarrier() 方法建立起了同步屏障，即往消息队列中插入了一条 target = null 的消息，且 msg.when 的值为当前时间由于普通(同步)的 Handler 将插入了一条消息到消息队列最前面，when == 0，所以导致会先处理该普通消息，然后再遇到了 target == null 的消息，则开始遍历异步消息进行处理，如果不调用 android.os.MessageQueue#removeSyncBarrier 方法将 target == null 的消息移除掉，则该 MessageQueue 中的同步消息就一直无法得到处理 总结用以下一幅图来总结 Android 中的消息分发机制 Looper 像是一个发动机，不停地将生产者产生的 Message 从传送带(MessageQueue) 中分发给消费者去处理 本文参考： Android消息机制1-Handler(Java层)","link":"/2021/04/21/2021_04_21_about_handler_in_android/"},{"title":"Java 动态代理","text":"代理模式所谓代理模式，就是指「代理对象」(或者我们形象地称呼为中介)，通过实现接口类具有了接口的能力，并通过和「实际的生产者」产生联系，将「实际生产者」的能力通过自己中转给「客户(调用者)」 客户不直接通过「实际生产者」获取信息，而是跟「代理对象(中介)」打交道获取信息 我们通过房屋租赁作为例子 静态代理举个例子，我们有个 IPriceService.java 的接口，用于获取房屋的报价 1234interface IPriceService{ int getPrice();} 一般在代码里我们还会有一个类去实现这个 IPriceService.java 接口，例如下面的 APriceService.java代表A房东的报价为 100元 123456class APriceService implements IPriceService{ override int getPrice(){ return 100; }} 我们可能还有一个代理类，PriceServiceProxy，对 APriceService 进行代理，相当于一个「中介」，不让「租客」和「房东」接触，「中介」可以对数据(即价格)进行加工处理后再提供给「租客」 123456789101112131415public class PriceServiceProxy implements IPriceService{ private IPriceService realPriceService; public PriceServiceProxy(IPriceService service){ //当然，这里也可以通过外部注入该中介对接的房东 realPriceService = service; } override int getPrice(){ //中介获取到了房东的报价 int aPrice = realPriceService.getPrice(); //再在房东报价的基础上加上中介费，返回给租客 return aPrice + 100; }} 这就是静态代理，从工程上来说，静态代理是添加一个「委托类」在不需要修改真正的实现类的基础上，做到对需求变动进行灵活修改的目的。 例如有一天需求变为「提供给租客的价格是房东的价格的 9折」，如果没有代理类，而是「租客」和「房东」直接打交道，那么我们需要修改所有实现了 IPriceService 接口的类中的 getPrice()方法，有了代理类，我们只需要修改代理类中的 getPrice() 方法，在房东的报价的基础上 * 0.9 即可 123456789101112131415public class PriceServiceProxy implements IPriceService{ private IPriceService realPriceService; public PriceServiceProxy(IPriceService service){ //当然，这里也可以通过外部注入该中介对接的房东 realPriceService = service; } override int getPrice(){ //中介获取到了房东的报价 int aPrice = realPriceService.getPrice(); //再在房东报价的基础打9折，返回给租客 return (int)(aPrice * 0.9f); }} 测试方法: 12345public static void main(String[] args) { IPriceService priceService = new PriceServiceProxy(new APriceService()); System.out.print(&quot;租客获取到的房子报价为&quot;+priceService.getPrice());} 上述的「静态代理」有如下几个特点： 「租客」只关心报价，而不关心是谁提供了报价;即只关心 IPriceService 接口的返回，而不关心实现 IPriceService 接口的实例是谁 将「租客」和「房东」分离，降低了一定的耦合性 但也需要创建很多的代理类，使得代码量增加，一旦接口需要变动，代理类和实际目标类都需要进行修改 动态代理动态代理就是将上述我们的静态代理中的 PriceServiceProxy 类通过代码动态生成，并通过该动态代理对目标对象(房东)进行进一步操作，达到代理的目的 我们可以使用 Java 中的 java.lang.reflect.Proxy#newProxyInstance 生成动态代理对象其方法签名如下： 123public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 第一个参数传入需要代理的接口的 ClassLoader第二个参数传入需要代理的接口类第三个参数传入 InvocationHandler 对象，对需要代理的目标对象进行处理 eg. 1234567891011121314151617181920212223242526private val aPriceService by lazy { APriceService() }//通过代码动态创建了一个「中介对象」priceServiceProxyval priceServiceProxy = Proxy.newProxyInstance( IPriceService::class.java.classLoader, arrayOf(IPriceService::class.java), object : InvocationHandler { override fun invoke(proxy: Any?, method: Method?, args: Array&lt;out Any&gt;?): Any? { Log.d(&quot;ProxyDemoActivity&quot;,&quot;method is ${method?.name}&quot;) if (method?.name?:&quot;&quot; == &quot;getPrice&quot;){ //如果方法是「getPrice」方法，则获取对象返回的数据，然后再加上 100 后在返回 return (method?.invoke(aPriceService,*(args?: arrayOfNulls(0))) as Int) + 100 } return method?.invoke(aPriceService,*(args?: arrayOfNulls(0))) } } ) as IPriceServicefindViewById&lt;Button&gt;(R.id.btnProxyDemo).setOnClickListener { //通过代理对象获取价格 Log.d(&quot;ProxyDemoActivity&quot;,&quot;price is &quot;+priceServiceProxy.getPrice())} 可见，我们通过代码 Proxy.newProxyInstance 生成了一个动态代理对象，对原本的 aPriceService 对象进行代理，从中做一些「偷梁换柱」的方法 那这到底有什么用呢，静态代理不也能做到吗，何必多此一举呢。 下面我们看个例子，假设我们有个需求，需要对 Android Framework 中的 startActivity() 方法做一些拦截处理 然而这个方法的代码是我们无法编辑的，也无法通过静态代理的方式生成一个 ActivityManagerProxy 对象进行代理，这时我们就可以考虑使用动态代理的方式，生成一个动态代理对象，对 activityManager 对象进行代理，在 startActivity 方法前后进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152try { Class&lt;?&gt; activityManagerNativeClass = null; Field defaultFiled = null; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { activityManagerNativeClass = Class.forName(&quot;android.app.ActivityManager&quot;); defaultFiled = activityManagerNativeClass.getDeclaredField(&quot;IActivityManagerSingleton&quot;); } else { activityManagerNativeClass = Class.forName(&quot;android.app.ActivityManagerNative&quot;); defaultFiled = activityManagerNativeClass.getDeclaredField(&quot;gDefault&quot;); } defaultFiled.setAccessible(true); Object defaultValue = defaultFiled.get(null); //反射SingleTon Class&lt;?&gt; SingletonClass = Class.forName(&quot;android.util.Singleton&quot;); Field mInstance = SingletonClass.getDeclaredField(&quot;mInstance&quot;); mInstance.setAccessible(true); //到这里已经拿到ActivityManager对象 Object iActivityManagerObject = mInstance.get(defaultValue); //开始动态代理，用代理对象替换掉真实的ActivityManager，瞒天过海 Class&lt;?&gt; IActivityManagerIntercept = Class.forName(&quot;android.app.IActivityManager&quot;); AmsInvocationHandler handler = new AmsInvocationHandler(iActivityManagerObject); Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[]{IActivityManagerIntercept}, handler); //现在替换掉这个对象 mInstance.set(defaultValue, proxy);} catch (Exception e) { Log.e(&quot;vivid&quot;,&quot;hook 异常&quot;); e.printStackTrace();}class AmsInvocationHandler implements InvocationHandler { private Object iActivityManagerObject; private AmsInvocationHandler(Object iActivityManagerObject) { this.iActivityManagerObject = iActivityManagerObject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (&quot;startActivity&quot;.contains(method.getName())) { //我要在这里搞点事情 } return method.invoke(iActivityManagerObject, args); }} 上述代码则是通过反射获取到 ActivityManager 对象，然后通过动态代理构建其一个代理类，并在 invoke 方法中对 startActivity 方法进行判断处理，达到我们的目的 Retrofit 中的动态代理 下文基于 &quot;com.squareup.retrofit2:retrofit:2.7.1&quot; 分析 我们知道在 Retrofit 中，api 方法的定义是定义在一个 interface 中的，例如 1234interface IPodCastBusiness { @GET fun getRss(@Url url: String): Flowable&lt;RssResponse&gt;} 而在使用该方法进行网络请求时，是使用以下的方法进行请求的 12345678Retrofit.Builder() .baseUrl(&quot;xxxx&quot;) .client(OkHttpClient()) .addConverterFactory(SimpleXmlConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build() .create(IPodCastBusiness::class.java) .getRss(rssLink) 我们重点看一下这个 create 方法，看 Retrofit 是如何将一个 IPodCastBusiness 的接口转化为一个实例的 1234567891011121314151617181920212223242526 public &lt;T&gt; T create(final Class&lt;T&gt; service) { //第一步校验 service 是否是一个接口，不是我们现在的重点，跳过不表 validateServiceInterface(service); //这里又见到了我们的老朋友了，在这里，通过 Proxy.newProxyInstance() 方法 //将我们传入的 service 接口构建了一个动态代理对象并返回 //外部则可以使用这个动态代理的实例进行下一步操作了 //至于调用了接口中定义的 HTTP Request 方法是如何转化成返回类型的，则需要看 invoke 方法中的内容 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation. //如果这个方法是 Object 里的方法，则正常调用，不处理 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } });} 到这里，我们就知道了在 Retrofit 中是如何将一个 Interface 转化成一个实例对象了的其远离就是通过 Proxy.newProxyInstance() 方法生成其代理对象返回","link":"/2021/11/21/2021_11_21_java_proxy/"},{"title":"RxJava2 原理解析","text":"RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.RxJava 是 Reactive Extensions 的 Java VM 实现：一个使用可观察序列组合异步和基于事件的程序的库。 RxJava 通过观察者订阅被观察者进行事件的分发，并提供了很多被观察者(即事件发送者)的创建方法和事件转换的操作符函数(map、flatmap、filter 等等) 下面以最简单的一个 SingleJust 的发射和订阅为例，来看一下 RxJava 中到底是如何进行订阅的 12345678910111213SingleJust.just(0) .map(new Function&lt;Integer, String&gt;() { @Override public String apply(@NonNull Integer integer) throws Exception { return integer.toString(); } }) .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(String s) throws Exception { } }); 首先看一下 SingleJust.just(1) 12345678910111213141516171819@CheckReturnValue@SchedulerSupport(SchedulerSupport.NONE)@NonNullpublic static &lt;T&gt; Single&lt;T&gt; just(final T item) { //检查校验参数不能为 null ObjectHelper.requireNonNull(item, &quot;item is null&quot;); //这是个 hook 方法，一般默认返回传入的对象本身 //如果设置了 hook 对象(Function)，则会对其进行一些操作后再返回 return RxJavaPlugins.onAssembly(new SingleJust&lt;T&gt;(item));}//RxJavaPlugins.onAssemblypublic static &lt;T&gt; Single&lt;T&gt; onAssembly(@NonNull Single&lt;T&gt; source) { Function&lt;? super Single, ? extends Single&gt; f = onSingleAssembly; if (f != null) { return apply(f, source); } return source;} 重点看一下 SingleJust.java 类 很简单的一个类，继承 Single 类，构造方法中传入一个 value，并实现 subscribeActual() 方法在 subscribeActual() 方法中调用传入的 observer 的 onSubscribe() 方法和 onSuccess() 方法 123456789101112131415public final class SingleJust&lt;T&gt; extends Single&lt;T&gt; { final T value; public SingleJust(T value) { this.value = value; } @Override protected void subscribeActual(SingleObserver&lt;? super T&gt; observer) { observer.onSubscribe(Disposables.disposed()); observer.onSuccess(value); }} 而 subscribeActual() 方法中调用了 observer（观察者）的 onSubscribe() 和 onSuccess() 方法至于 subscribeActual() 什么时候被调用的，我们一会再看 再接着看 Single.map() 方法 123456789@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.NONE)public final &lt;R&gt; Single&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) { //检查入参 ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;); //返回一个 SingleMap 对象 return RxJavaPlugins.onAssembly(new SingleMap&lt;T, R&gt;(this, mapper));} 具体看下 SingleMap 的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class SingleMap&lt;T, R&gt; extends Single&lt;R&gt; { final SingleSource&lt;? extends T&gt; source; final Function&lt;? super T, ? extends R&gt; mapper; public SingleMap(SingleSource&lt;? extends T&gt; source, Function&lt;? super T, ? extends R&gt; mapper) { this.source = source; this.mapper = mapper; } @Override protected void subscribeActual(final SingleObserver&lt;? super R&gt; t) { source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper)); } static final class MapSingleObserver&lt;T, R&gt; implements SingleObserver&lt;T&gt; { final SingleObserver&lt;? super R&gt; t; final Function&lt;? super T, ? extends R&gt; mapper; MapSingleObserver(SingleObserver&lt;? super R&gt; t, Function&lt;? super T, ? extends R&gt; mapper) { this.t = t; this.mapper = mapper; } @Override public void onSubscribe(Disposable d) { t.onSubscribe(d); } @Override public void onSuccess(T value) { R v; try { v = ObjectHelper.requireNonNull(mapper.apply(value), &quot;The mapper function returned a null value.&quot;); } catch (Throwable e) { Exceptions.throwIfFatal(e); onError(e); return; } t.onSuccess(v); } @Override public void onError(Throwable e) { t.onError(e); } }} 可见 SingleMap 的构造方法中传入的第一个参数 SingleSource source，即调用该方法的 SingleSouce 对象第二个参数是个 Function mapper，即转换方法 同样的，subscribeActual(final SingleObserver&lt;? super R&gt; t) 方法里调用了 source:SingleSource 的 subscribe 方法，传入了一个 MapSingleObserver 对象 MapSingleObserver 相当于一个代理类，对 subscribeActual() 方法中的 t 进行代理，当 mapSingleObserver 的方法被调用时，就会调用其构造方法中传入的 t 进行调用，在 onSuccess() 中先使用 mapper 对数据进行处理后，得到 result，再调用 t.onSuccess(result) 进行回调 再回过头来看 subscribe() 方法 12345678910111213141516171819202122232425262728293031323334public final Disposable subscribe(final Consumer&lt;? super T&gt; onSuccess, final Consumer&lt;? super Throwable&gt; onError) { //对参数进行检查 ObjectHelper.requireNonNull(onSuccess, &quot;onSuccess is null&quot;); ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;); //对传入的观察者进行包装为一个 ConsumerSingleObserver ConsumerSingleObserver&lt;T&gt; observer = new ConsumerSingleObserver&lt;T&gt;(onSuccess, onError); //再调用 subscribe 方法订阅 subscribe(observer); return observer;}public final void subscribe(SingleObserver&lt;? super T&gt; observer) { //依旧是进行参数检查 ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;); //同上理，进行 hook 配置 observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;); try { //重点在于这里，调用了 subscribeActual 方法 //subscribeActual 是个抽象方法，需要各个子类进行实现 //于是这里就会调用到了我们上面所看到的 SingleJust 类中的 subscribeActual 方法，完成了整个 RxJava 的流程 subscribeActual(observer); } catch (NullPointerException ex) { throw ex; } catch (Throwable ex) { Exceptions.throwIfFatal(ex); NullPointerException npe = new NullPointerException(&quot;subscribeActual failed&quot;); npe.initCause(ex); throw npe; }} 由上述我们可以知道，在 RxJava 中，就是由最下游的 subscribe() 方法中的参数 observer ，最终调用事件发出者的 subscribeActual() 方法 上述的代码的流程我们可以用下面的伪代码来进行理解 123456789101112//最后被执行SingleObserver.subscribeActual(){ //第二个被执行 SingleMap.subscribeActual(){ //最先执行 SingleJust.subscribeActual(){ //create onSubscribe() onSuccess() } }} 整理一下，RxJava 的事件流起始在于调用了 subscribe() 方法，然后一层一层地调用上游的 subscribeActual(SingleObserver&lt;? super T&gt; observer) 方法，同时也把把自己传给上游 对于操作符来说，其 subscribeActual() 方法会调用其上游的 subscribe() -&gt; subscribeActual() 方法，直到最上游的生产者 对于生产者来说，其 subscribeActual() 方法则是在生产数据，调用下游观察者(即从 subscribeActual() 方法中传入的参数) 的回调方法 所以实际上就是后面的 observer 在倒序地调用上游的 subscribeActual() 方法，然后不断调用下游的 onSuccess/onSubscribe/onError 等等方法 操作符持有调用它的上游的引用，并在被订阅的时候(subscribeActual()) 将下游进行代理后，去订阅其上游 同理，Observable/Flowable 等 RxJava 的事件流也是同样的流程 画个流程图 RxJava 的线程切换 subscribeOn() 指定事件产生的线程 observeOn() 指定事件消费的线程 RxJava 中的线程调度是通过 subscribeOn(Scheduler scheduler) 和 observeOn(Scheduler scheduler) 两个方法完成的subscribeOn() 方法调度的是上游到第一个 observeOn() 之间的的线程observeOn() 调度的是该 observeOn() 到下一个 observeOn() 之间的的线程 所以在 RxJava 中可以进行任意的线程调度，但是，subscribeOn() 方法则有所区别，如果有多个 subscribeOn() 方法，只有最靠近上游的 subscribeOn() 起作用，而其他的 subscribeOn() 方法不起作用，但是这其中也有一个例外，当使用 doOnSubscribe() 方法时，这个方法发生在 subscribe() 调用后而且在事件发送前，这个方法是可以指定线程的，默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 subscribeOn() 和 observeOn() 方法需要传入一个 Schedule 对象 ScheduleSchedule 是一个抽象类，其子类有我们经常使用的 Schedulers.io()、Schedulers.newThread() 以及 AndroidSchedulers.mainThread() 等等 举个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Observable.just(1) //---------1 start ------------// .flatMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() { @Override public ObservableSource&lt;Integer&gt; apply(Integer integer) throws Exception { Log.d(&quot;MainActivity&quot;,&quot;1&quot;); Log.d(&quot;MainActivity&quot;,&quot;flatMap&quot;); Log.d(&quot;MainActivity&quot;,Thread.currentThread().toString()); return Observable.just(integer); } }) //---------1 end ------------// .subscribeOn(Schedulers.newThread())//调度从上游到第一个 observerOn() 方法之间的线程，即 1 和 2 //---------2 start ------------// .map(new Function&lt;Integer, String&gt;() { @Override public String apply(Integer integer) throws Exception { Log.d(&quot;MainActivity&quot;,&quot;2&quot;); Log.d(&quot;MainActivity&quot;,&quot;map&quot;); Log.d(&quot;MainActivity&quot;,Thread.currentThread().toString()); return String.valueOf(integer); } }) //---------2 end ------------// //---------3 start ------------// .doOnSubscribe(new Consumer&lt;Disposable&gt;() { @Override public void accept(Disposable disposable) throws Exception { Log.d(&quot;MainActivity&quot;,&quot;3&quot;); Log.d(&quot;MainActivity&quot;,&quot;doOnSubscribe&quot;); Log.d(&quot;MainActivity&quot;,Thread.currentThread().toString()); } }) //---------3 end ------------// .observeOn(Schedulers.computation())//调度下面的线程，即4 和5 //---------4 start ------------// .map(new Function&lt;String, String&gt;() { @Override public String apply(String s) throws Exception { Log.d(&quot;MainActivity&quot;,&quot;4&quot;); Log.d(&quot;MainActivity&quot;,&quot;map&quot;); Log.d(&quot;MainActivity&quot;,Thread.currentThread().toString()); return s + &quot; map &quot;; } }) //---------4 end ------------// //只能决定 doOnSubscribe 中的线程，即3 //.subscribeOn(Schedulers.newThread()) //---------5 start ------------// .subscribe(new Consumer&lt;String&gt;() { @Override public void accept(String s) throws Exception { Log.d(&quot;MainActivity&quot;,&quot;5&quot;); Log.d(&quot;MainActivity&quot;,&quot;subscribe&quot;); Log.d(&quot;MainActivity&quot;,Thread.currentThread().toString()); Log.d(&quot;MainActivity&quot;,&quot;result is &quot;+s); } }); //---------5 end ------------// 打印出来的日志为 12345678910111213141516D/MainActivity: 3D/MainActivity: doOnSubscribeD/MainActivity: Thread[main,5,main]D/MainActivity: 1D/MainActivity: flatMapD/MainActivity: Thread[RxNewThreadScheduler-1,5,main]D/MainActivity: 2D/MainActivity: mapD/MainActivity: Thread[RxNewThreadScheduler-1,5,main]D/MainActivity: 4D/MainActivity: mapD/MainActivity: Thread[RxComputationThreadPool-1,5,main]D/MainActivity: 5D/MainActivity: subscribeD/MainActivity: Thread[RxComputationThreadPool-1,5,main]D/MainActivity: result is 1 map 可以看出 doOnSubscribe 是最先被执行的 第一个 subscribeOn(Schedulers.io()) 调度的是最上游的 1 和 2 中的线程第二个 subscribeOn(Schedulers.newThread()) 不起作用，只能调度 3 中的线程第三个 observeOn(Schedulers.computation()) 调度的是其后面的代码的线程，即 4 和 5 subscribeOn()我们通过源码一步一步看，subscribeOn 到底是如何调度线程的 同上，也是先校验 scheduler 不为空然后将 scheduler 包装为一个 ObservableSubscribeOn 并返回 1234567io.reactivex.Observable#subscribeOn@CheckReturnValue@SchedulerSupport(SchedulerSupport.CUSTOM)public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) { ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));} 12345678910111213141516io.reactivex.internal.operators.observable.ObservableSubscribeOn#ObservableSubscribeOnpublic ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) { super(source); this.scheduler = scheduler;}@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; observer) { final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer); //调用下游的 onSubscribe() 方法， observer.onSubscribe(parent); //⑥ parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));} 12345678910111213final class SubscribeTask implements Runnable { private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) { this.parent = parent; } //⑦ @Override public void run() { source.subscribe(parent); }} ObservableSubscribeOn 类的构造方法第一个参数是 ObservableSource source 即上面传入的 this(就是调用 subscribeOn 的对象)第二个参数是 Scheduler scheduler，即要调度到的线程 再看 subscribeActual(final Observer&lt;? super T&gt; observer) 方法从上文我们可以知道，当下游的观察者订阅时，会调用上游的 subscribeActual() 方法，在我们这里，ObservableSubscribeOn#subscribeActual() 的职责就是切换到指定的线程，并在指定的线程中调用上游的 subscribe() 方法，达到切换上游线程的目的 在这个方法中，会将下游的 observer 进行包装为 SubscribeOnOnserver 对象 parent，这个对象中持有着下游 observer 重点看一下 scheduler.scheduleDirect(new SubsribeTask(parent)) SubscribeTask 是一个实现了 Runnable 接口的类，那肯定会在某个时机调用其 run() 方法，可以看到在 run() 方法中调用了 source.subscribe(parent)，由于 SubscribeTask 是 ObservableSubscribeOn 的内部类，所以这里的 source 就是 ObservableSubscribeOn 构造方法中传入的第一个参数，即调用subscribeOn() 的上游对象，这里的 parent 则是上面的 SubscribeOnOnserver 包装对象 那么重点又转移到了 SubscribeTask 中的 run() 方法是如何被调用的了 我们继续看 io.reactivex.Scheduler#scheduleDirect(java.lang.Runnable) 方法 12345678910111213public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { //创建一个 Worker final Worker w = createWorker(); //对传入的 run 对象（即前面的 SubscribeTask 对象）做钩子处理 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); //将 decoratedRun 和 w 包装成一个 DisposeTask (即一个可以被取消的 Runnable) DisposeTask task = new DisposeTask(decoratedRun, w); //worker 调用 schedule 方法进行操作 //① 具体的实现见下方 w.schedule(task, delay, unit); return task;} 可以看到这个 createWorker() 方法，是 Scheduler 类的抽象方法，我们以 Schedulers.newThread() 的具体实例 NewThreadScheduler 为例，来看一下这段代码到底是如何切换线程的 12345678910public final class NewThreadScheduler extends Scheduler { ...忽略一些代码... @NonNull @Override public Worker createWorker() { return new NewThreadWorker(threadFactory); }} 继续看 NewThreadWorker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class NewThreadWorker extends Scheduler.Worker implements Disposable { private final ScheduledExecutorService executor; ...... public NewThreadWorker(ThreadFactory threadFactory) { //具体代码见 ② executor = SchedulerPoolFactory.create(threadFactory); } //从上文可以知道，①处的代码会调用到这里 @NonNull @Override public Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) { if (disposed) { return EmptyDisposable.INSTANCE; } return scheduleActual(action, delayTime, unit, null); } //③ @NonNull public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) { Runnable decoratedRun = RxJavaPlugins.onSchedule(run); ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); if (parent != null) { if (!parent.add(sr)) { return sr; } } Future&lt;?&gt; f; try { if (delayTime &lt;= 0) { f = executor.submit((Callable&lt;Object&gt;)sr); } else { f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); } sr.setFuture(f); } catch (RejectedExecutionException ex) { if (parent != null) { parent.remove(sr); } RxJavaPlugins.onError(ex); } return sr; } ② 创建一个只有一个核心线程的线程池并返回 12345public static ScheduledExecutorService create(ThreadFactory factory) { final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); tryPutIntoPool(PURGE_ENABLED, exec); return exec;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static final class DisposeTask implements Disposable, Runnable, SchedulerRunnableIntrospection { @NonNull final Runnable decoratedRun; @NonNull final Worker w; @Nullable Thread runner; DisposeTask(@NonNull Runnable decoratedRun, @NonNull Worker w) { this.decoratedRun = decoratedRun; this.w = w; } //④ @Override public void run() { runner = Thread.currentThread(); try { //⑤ decoratedRun.run(); } finally { dispose(); runner = null; } } @Override public void dispose() { if (runner == Thread.currentThread() &amp;&amp; w instanceof NewThreadWorker) { ((NewThreadWorker)w).shutdown(); } else { w.dispose(); } } @Override public boolean isDisposed() { return w.isDisposed(); } @Override public Runnable getWrappedRunnable() { return this.decoratedRun; } } 由上述的代码我们可以看到① 处的 worker 调用 schedule() 方法，传入包装类 DisposeTask 的对象(持有 worker 和 subscribeTask)，一步步调用到 ③ 处，③这里就是将传入的 run 对象(即 DisposeTask )，根据延迟时间，交给 ② 处的线程池去执行，最终执行到 ④ 处 DisposeTask 的 run() 方法，run() 方法中会的调用 ⑤处 的 decoratedRun.run()，而这个 decoratedRun 对象就是我们在 ⑥处 传入的 SubscribeTask 对象，至此就调用到了它的 run 方法，也就是 ⑦处 的代码，完成了在 Schedules.newThread() 所指定的线程中调用 source.subscribe(parent) 的方法，使得上游的 subscribe() -&gt; 即 subscribeActual() 的代码都运行在了 Schedules.newThread() 所指定的线程中 为何 subscribeOn() 方法只有第一个才生效 为了避免歧义，这里先不讨论 doOnSubscribe() 的情况 由上文我们可以知道，subscribeOn 的核心内容就是将 source.subscribe(parent) 方法放到指定的线程中去执行，其中 source 为上游，parent 为下游的监听者，所以上游的 subscribe() 方法，即 subscribeActual() 都会被执行在指定的线程中。 而当最上游的事件产生者接收到订阅后，就会开始发射事件，即调用 onNext、onError、onComplete 等方法，这些方法如果没有经过 observeOn 指定线程，则依然执行在subscribeOn 的线程中，否则执行在 observeOn 指定的线程中。 所以「subscribeOn() 方法只有第一个才生效」这种说法是有点令人误解的，每一个 subscribeOn 方法都会使得其上游的 subscribe() -&gt; subscribeActual() 方法执行在指定的线程中 observeOn()同上理，我们从源码开始着手 1234567@CheckReturnValue@SchedulerSupport(SchedulerSupport.CUSTOM)public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));} 12345678910111213141516171819202122232425public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; { final Scheduler scheduler; final boolean delayError; final int bufferSize; public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) { super(source); this.scheduler = scheduler; this.delayError = delayError; this.bufferSize = bufferSize; } //① @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) { if (scheduler instanceof TrampolineScheduler) { source.subscribe(observer); } else { Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); } } ......} 可以看到，当上游调用 observeOn() ，包装成一个 ObservableObserveOn 对象，并传入 source(即上游) 和所需要调度线程的 scheduler 由上文我们可以知道，当下游调用 subscribe() 方法后，会调用到 ①处的 subscribeActual() 方法，在这里创建一个 worker 对象，从上文我们知道这个 worker 是一个用来进行切换线程的抽象类将 worker 和 下游的 observer 进行代理为一个 ObserveOnObserver 对象，并让 source(即上游) 订阅这个被代理了的「下游 observer」 当上游调用下游的 onNext()、onError()、onComplete() 等方法时候，会调用到 ObserveOnObserver 这个代理对象中的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt; implements Observer&lt;T&gt;, Runnable { ......//省略一些代码 final Observer&lt;? super T&gt; downstream; final Scheduler.Worker worker; Disposable upstream; ......//省略一些代码 ObserveOnObserver(Observer&lt;? super T&gt; actual, Scheduler.Worker worker, boolean delayError, int bufferSize) { this.downstream = actual; this.worker = worker; this.delayError = delayError; this.bufferSize = bufferSize; } @Override public void onSubscribe(Disposable d) { ......//省略一些代码 } @Override public void onNext(T t) { ......//省略一些代码 schedule(); } @Override public void onError(Throwable t) { ......//省略一些代码 schedule(); } @Override public void onComplete() { ......//省略一些代码 schedule(); } ......//省略一些代码 void schedule() { if (getAndIncrement() == 0) { worker.schedule(this); } } ......//省略一些代码 //② @Override public void run() { if (outputFused) { drainFused(); } else { drainNormal(); } } ......//省略一些代码 } 从代码中我们看到，在 ObserveOnObserver 的 onNext()、onError()、onComplete() 方法中调用了 schedule() 方法，而 schedule() 方法中调用了 worker.schedule(this) 同理我们知道会在该 worker 的线程中执行 ②处的 run 方法，在 run() 方法中的 drainNormal() 和 drainFused() 会调用传入的「下游 observer」相对应的 onNext()、onError()、onComplete()等方法，也就达到了切换下游 observer 的代码的执行线程，从这里就完成了 observeOn() 的线程切换 总结从上述的 subscribeOn() 和 observeOn() 的流程的分析，我们可以得出以下的结论 subscribeOn() 切换的是 source.subscribe() 这行代码的执行线程，所以他只能影响到的是从其开始，自下而上的 subscribe() 方法执行的线程，但从表象上看如果有多个的话，生效的只有最上游的 subscribeOn()，且作用域是从最上游(事件生产者)到第一个 subscribeOn() 之间，订阅(subscribe)是自下而上的，但事件流真正的传递(onNext、onError、onComplete)是自上而下的 observeOn() 切换的是 onNext、onError、onComplete 等方法的执行线程，这些方法中再调用下游的代码进行自上而下的事件传递，所以多个 observeOn() 的话，作用域的就是其下游到下一个 obserbeOn() 之间的代码 由于开发者写的代码都是在 onNext、onError、onComplete 中，所以从表象上看，我们所写的各个操作符中的代码都是执行在 observeOn 指定的线程中 doOn 操作符doOnNext、doOnError、doOnComplete以上三个 doOn 操作符所在的线程由 subscribeOn 和 observeOn 决定 看下 doOnNext() 的源码 12345678910public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext) { return doOnEach(onNext, Functions.emptyConsumer(), Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);}private Observable&lt;T&gt; doOnEach(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Action onAfterTerminate) { ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;); ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;); ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;); ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;); return RxJavaPlugins.onAssembly(new ObservableDoOnEach&lt;T&gt;(this, onNext, onError, onComplete, onAfterTerminate));} 可以知道，doOnError()、doOnComplete() 方法同样是会调用 doOnEach() 方法中，通过 ObservableDoOnEach 类进行代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public final class ObservableDoOnEach&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; { final Consumer&lt;? super T&gt; onNext; final Consumer&lt;? super Throwable&gt; onError; final Action onComplete; final Action onAfterTerminate; /** * 构造方法 * 传入对应的 onNext、onError、onComplete、onAfterTerminate 方法 * @param source 上文中传入的 this，即上游的 Observable */ public ObservableDoOnEach(ObservableSource&lt;T&gt; source, Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Action onAfterTerminate) { super(source); this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onAfterTerminate = onAfterTerminate; } /** * 当调用 subscribe() 方法后会调用这个方法 * @param t 下游或者下游的代理包装类 */ @Override public void subscribeActual(Observer&lt;? super T&gt; t) { //调用上游的 subscribe 方法(-&gt; subscribeActual ) 传递给上游 source.subscribe(new DoOnEachObserver&lt;T&gt;(t, onNext, onError, onComplete, onAfterTerminate)); } static final class DoOnEachObserver&lt;T&gt; implements Observer&lt;T&gt;, Disposable { final Observer&lt;? super T&gt; downstream; final Consumer&lt;? super T&gt; onNext; final Consumer&lt;? super Throwable&gt; onError; final Action onComplete; final Action onAfterTerminate; Disposable upstream; boolean done; /** * 构造方法 * @param actual 下游 Observer * @param onNext 传入的 doOnNext 中的对象 */ DoOnEachObserver( Observer&lt;? super T&gt; actual, Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Action onAfterTerminate) { this.downstream = actual; this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onAfterTerminate = onAfterTerminate; } //...省略部分代码 /** * 当上游调用下游的 onNext 方法时，会调用到这个方法 */ @Override public void onNext(T t) { if (done) { return; } try { //调用 onNext 的 accept 方法 onNext.accept(t); } catch (Throwable e) { Exceptions.throwIfFatal(e); upstream.dispose(); onError(e); return; } //再调用下游的 onNext 方法 downstream.onNext(t); } //...省略部分代码 }} 可见，doOnXxxx() 方法会在 onXxxx() 调用之前调用，且其执行的线程和其他操作符一样由 subscribeOn() 和 observeOn() 决定 doOnSubscribe()在一个 RxJava 的调用链中，doOnSubscribe() 方法表示在被 subscribe 时执行 默认情况下，doOnSubscribe() 方法执行在 subscribe() 方法调用的线程中，但如果 doOnSubscribe() 方法后有subscribeOn()指定了线程，则执行在指定的线程中 123456789101112131415161718Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception { Log.d(TAG, &quot;create thread is &quot; + Thread.currentThread()); emitter.onNext(1); emitter.onComplete(); }}).subscribeOn(Schedulers.newThread()).doOnSubscribe(new Consumer&lt;Disposable&gt;() { @Override public void accept(Disposable disposable) throws Exception { Log.d(TAG, &quot;thread is &quot; + Thread.currentThread()); }}).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(); 打印的日志如下thread is Thread[RxCachedThreadScheduler-1,5,main]create thread is Thread[RxNewThreadScheduler-2,5,main] 说明 create 的代码执行在 Schedulers.newThread() 线程中，而 doOnSubscribe 的代码执行在 Schedulers.io() 线程中，接着看源码来分析 123456789101112131415161718192021222324252627282930public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; { final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) { this.source = source; } @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) { CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try { source.subscribe(parent); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); parent.onError(ex); } }}public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe) { return doOnLifecycle(onSubscribe, Functions.EMPTY_ACTION);}public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose) { ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;); ObjectHelper.requireNonNull(onDispose, &quot;onDispose is null&quot;); return RxJavaPlugins.onAssembly(new ObservableDoOnLifecycle&lt;T&gt;(this, onSubscribe, onDispose));} 同上理，不废话，直接看 ObservableDoOnLifecycle 12345678910111213141516public final class ObservableDoOnLifecycle&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; { private final Consumer&lt;? super Disposable&gt; onSubscribe; private final Action onDispose; public ObservableDoOnLifecycle(Observable&lt;T&gt; upstream, Consumer&lt;? super Disposable&gt; onSubscribe, Action onDispose) { super(upstream); this.onSubscribe = onSubscribe; this.onDispose = onDispose; } @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) { source.subscribe(new DisposableLambdaObserver&lt;T&gt;(observer, onSubscribe, onDispose)); }} 12345678910111213141516171819public final class DisposableLambdaObserver&lt;T&gt; implements Observer&lt;T&gt;, Disposable { final Observer&lt;? super T&gt; downstream; final Consumer&lt;? super Disposable&gt; onSubscribe; //...... public DisposableLambdaObserver(Observer&lt;? super T&gt; actual, Consumer&lt;? super Disposable&gt; onSubscribe, Action onDispose) { this.downstream = actual; this.onSubscribe = onSubscribe; this.onDispose = onDispose; } @Override public void onSubscribe(Disposable d) { //...... onSubscribe.accept(d); }} 可以看到，在 onSubscribe() 方法中会调用 onSubscribe.accept() 方法，即 doOnSubscribe() 中的接口方法。 而从 Create 方法中可以看到 .onSubscribe() 方法的调用是在 subscribeActual() 中调用的，而从上文我们知道 subscribeActual() 所执行的线程是由 subscribeOn() 指定的，所以 .onSubscribe() 方法的线程也就执行在了 subscribeOn 指定的线程中了，所以 doOnSubscribe() 方法的线程会受到 subscribeOn() 方法影响","link":"/2021/11/24/2021_11_24_rxjava/"},{"title":"Java 并发编程之 ReentrantLock","text":"ReentrantLock，可重入锁，基于 AQS 的机制，实现了公平锁和非公平锁，给开发者提供了一个更为灵活的锁实现，既然是个锁，ReentrantLock 也实现了 Lock 接口 先看一下 ReentrantLock 的源码的结构 由上可见其实 ReentrantLock 无非是实现了 Lock 接口，在 Lock 接口的方法中通过 sync 对象调用相对应的方法并返回值，所以我们重点来看一下这个 sync 对象。 在 ReentrantLock 中，Snyc 也是一个抽象了，且是 AQS 的子类，并有两个实现类，FairSync 和 NonFairSync，从名字可以看出来，一个是公平锁，另一个是非公平锁。 先看 Sycn 这个抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ //抽象方法，由子类自行实现如何 lock abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ /** * 非公平的尝试获取锁 * 一般来说，tryAcquire 由子类自行实现的，但 ReentrantLock 中的 * tryLock 方法中都需要调用该非公平的尝试锁方法 * 返回值表示是否获取锁状态成功 */ final boolean nonfairTryAcquire(int acquires) { //获取当前线程 final Thread current = Thread.currentThread(); //获取当前的锁状态 int c = getState(); if (c == 0) { //如果 c == 0，即锁为「空闲」状态，尝试通过 cas 的方式修改所状态 if (compareAndSetState(0, acquires)) { //cas 成功，则修改占用了锁的线程的值为当前线程，并返回获取锁状态成功 setExclusiveOwnerThread(current); return true; } } //else 说明 c != 0，说明锁已经被某个线程占用了 //则判断被占用的线程是否为当前线程 else if (current == getExclusiveOwnerThread()) { //如果锁被占用的线程是当前线程 //如果 nextc &lt; 0 说明超过 Int 的最大值溢出了，则抛出异常 //否则将 state 的值修改为原来的值 + acquires 的值 //这里不需要用 cas 的方式修改 state 的值是因为 if 中 已经判断了当前线程，所以不存在竞争 //最后返回 true 表示获取锁成功（即获取重入锁成功） int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; } //走到这里说明当前锁状态被别的线程占领了，则返回 false return false; } /** * 尝试释放锁状态 * 返回值表示是否完全释放了锁状态 */ protected final boolean tryRelease(int releases) { //根据当前 state 和 releases 的值相减得到新的 state 值 c int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) //如果当前线程非占用了锁的线程，并且来释放锁，则抛出异常 throw new IllegalMonitorStateException(); //初始化 free 变量为 false，只有在当前线程完全将锁释放了之后才会置为 true(因为有可重入的状态) boolean free = false; if (c == 0) { free = true; //更改占用锁的线程为 null setExclusiveOwnerThread(null); } //更新 state 的值 setState(c); //返回 free return free; } protected final boolean isHeldExclusively() { // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); } final ConditionObject newCondition() { return new ConditionObject(); } // Methods relayed from outer class final Thread getOwner() { return getState() == 0 ? null : getExclusiveOwnerThread(); } final int getHoldCount() { return isHeldExclusively() ? getState() : 0; } final boolean isLocked() { return getState() != 0; } /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state }} 接着看 Sync 的两个子类 FairSync 和 NonFairSync 先来看非公平的 NonFairSync，非公平同步方式的 lock 方法，会先直接去修改 state ，如果修改成功则获取到锁，将当前线程的引用保存起来，否则则调用 acquire() 方法去获取锁，而从 AQS 中我们知道 acquire() 方法中先会调用 tryAcquire() 方法先尝试获取锁 从这里也可以看到，在非公平同步方式中，无论是哪个线程先调用了 lock() 方法都会先直接调用 cas 的方法修改 state 从而获取锁，获取不到再去排队，这也就是「非公平」的体现，后来的线程可以插队抢锁 123456789101112131415161718static final class NonfairSync extends Sync { private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); }} 再看 FairSync lock 方法即调用了 AQS#acquire() 方法，如果能获取到锁则修改状态，如果获取不到锁则排队等待 同理 acquire() 方法中也会调用 tryAcquire 方法，而 FairSync#tryAcquire() 的实现和 NonFairSync#tryAcquire 调用的 nonfairTryAcquire() 方法几乎是一样的，仅仅在当 当前 state == 0 的时候多加了一个判断 !hasQueuedPredecessors() hasQueuedPredecessors() 这个方法的返回 true 表示等待队列不为空，且当前线程前面还有在排队的线程，否则返回 false 所以 !hasQueuedPredecessors() 也就表示当前线程前面没有线程在排队，才会走后续的 cas 修改锁状态等操作，这也正是 公平 的体现，后来的线程必须排队拿锁","link":"/2022/02/24/2022_02_24_Java_JUC_ReentrantLock/"},{"title":"ConcurrentHashMap 源码阅读笔记","text":"本文基于 JDK 1.8 分析 HashMap 是非线程安全的类，在多线程并发 put 导致 resize，在 transfer 过程中可能导致死锁或者数据丢失 而 ConcurrentHashMap 则是一个线程安全的 Map 类，在 HashMap 的基础上做了线程安全的处理 基础知识先大概对 ConcurrentHashMap 的数据结构模型有个大概的了解 跟 HashMap 一样，由一个数组和多个链表/红黑树组成 常量MAXIMUM_CAPACITY = 1 &lt;&lt; 30 最大的容量，因为 32 位的 hash 值的前两位为控制位，所以最大只到 1&lt;&lt;30 DEFAULT_CAPACITY = 16 默认初始容量，必须为2的次幂，最低位 1，最大为 MAXIMUM_CAPACITY DEFAULT_CONCURRENCY_LEVEL = 16 默认的并发级别 LOAD_FACTOR = 0.75 负载因子 TREEIFY_THRESHOLD = 8 MIN_TREEIFY_CAPACITY = 64 当插入时，链表上的节点数量超过 TREEIFY_THRESHOLD ，且 table 的长度也超过了 MIN_TREEIFY_CAPACITY，则会将链表转为树 否则进行扩容操作 sizeCtlsizeCtl 字段是用来表示 table 的初始化状态或者用来控制 table 数组的容量 如果 sizeCtl 为负数，则表示 table 正在初始化或者在调整容量 如果 sizeCtl 不为负数，如果 table 为 null，则保存初始化 ConcurrentHashMap 时的容量，为0或者默认值 初始化以后，则保存的是要进行扩容的阈值 sizeCtl = -1 表示正在初始化 sizeCtl &lt; 0 &amp;&amp; sizeCtl! = -1 表示正在扩容中，且 sizeCtl 的低16位的值表示正在扩容的线程数 + 1，高16位为扩容标识，是由数组长度计算得到的值 sizeCtl ≥ 0 &amp;&amp; table == null 表示初始化时计算出的默认容量 sizeCtl ≥ 0 &amp;&amp; table != null 表示需要扩容的阈值 Node&lt;K,V&gt;Node&lt;K,V&gt; 是 ConcurrentHashMap 的一个静态内部类，实现了 Map.Entry&lt;K,V&gt; 接口，用来保存键值对信息，注意这里的 val 和 next 字段都是用了 volatile 修饰，以保证其线程间的可见性 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next;} 构造方法 ConcurrentHashMap 有多个构造方法 1234567891011121314151617181920212223public ConcurrentHashMap() { }public ConcurrentHashMap(int initialCapacity) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;}public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap;} initialCapacity: 传入的初始容量 loadFactor: 负载因子 在构造方法中，实际上，是想通过传入的 initialCapacity 参数，并根据 loadFactor 计算出数组的初始化容量 cap，并且数组的阈值要大于 initialCapacity ，在 initTable() 方法中会使用这个 sizeCtl 值初始化 table 数组的容量 But，但是 这里的 public ConcurrentHashMap(int initialCapacity) 实际上是有 bug 的，在某些情况下，和下面三个参数的构造方法计算出来的 cap 值并不一致。 12new ConcurrentHashMap(22)new ConcurrentHashMap(22,0.75,1) 在一个参数的构造方法中，计算出来的 cap 值为 64，而三参数的构造方法计算所得到的 cap 为 32 这个问题直到 JDK 12 才被修复 value of ‘sizeCtl’ in ConcurrentHashMap varies with the constructor called tableSizeFor(int size)tableSizeFor(int size) 会返回大于等于 size 的最小的 2^n 的 例如：tableSizeFor(22) = 32 ; tableSizeFor(3) = 4 具体 tableSizeFor(size) 的方法可以参考 HashMap之tableSizeFor方法图解 添加元素put 方法final V putVal(K key , V value , boolean onlyIfAbsent) 💡 添加键值对，会进行初始化 table 数组、扩容、链表转树等操作 先看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697final V putVal(K key, V value, boolean onlyIfAbsent) { //如果 key 和 value 都为 null 则抛出空指针异常 if (key == null || value == null) throw new NullPointerException(); //计算 key 的 hash 值 int hash = spread(key.hashCode()); //记录链表中节点的数量，用来控制扩容或者由链表转变为树 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) { //死循环，直到满足某个条件后再退出 Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) //-------------①-------------------- //如果 tab 为空或者 tab 的长度为 0，则初始化 table tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { //-------------②-------------------- //如果 hash 对应的索引处 i 的桶为空，则尝试 cas 插入 //这里 i 被赋值为索引 //f 被赋值为索引处的 node 对象 if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null))) //插入数据成功，退出循环 break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) //-------------③-------------------- // i 处的 Node 不为 null 且其 hash 为 MOVED，即正在扩容中 // 这里将 fh 赋值为 Node f 的 hash 值 tab = helpTransfer(tab, f); else { //-------------④-------------------- //否则，即 i 处已经有 Node f 存在，并且不处于扩容中，那就应该插入到链表中 V oldVal = null; //多 f 加锁，多线程访问 synchronized (f) { if (tabAt(tab, i) == f) { //这里再次确认 i 处 Node 对象是否为 f if (fh &gt;= 0) { //如果 f 的 hash 大于等于 0 binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) { //开始遍历链表， //过程中如果找到 key 相同的，则替换 value 并退出遍历 //否则，遍历完链表，将节点插入链表尾部 K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { //如果 key 相等，则替换 value，退出循环 oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; } } } else if (f instanceof TreeBin) { //如果当前节点已经是树了，则将键值对插入树中 Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } else if (f instanceof ReservationNode) throw new IllegalStateException(&quot;Recursive update&quot;); } } if (binCount != 0) { //binCount 不为0，链表上的节点数量不为 0 ，即键值对插入了 if (binCount &gt;= TREEIFY_THRESHOLD) //节点上的数量超过了阈值，转为树 treeifyBin(tab, i); if (oldVal != null) //如果旧值不为 null，即替换了某个键值对 //则 return 旧值，结束整个 put 流程 return oldVal; //否则，即 oldVal == null 的情况下 //退出 for (Node&lt;K,V&gt;[] tab = table;;) 循环 //走 addCount(1L,binCount) 处的逻辑并返回 null break; } } } //增加计数，扩容等 addCount(1L, binCount); //返回 null，代表是新增的键值对，并非 key 相同替换旧的 value return null;} 总结一下： ①. 初始化数组 通过 spread 方法计算 hash 值，并开始死循环，直到插入成功后退出 如果 table 还未初始化，则先通过 initTable() 初始化数组 ②. index 处为 null 通过 spread() 方法计算出对应的索引 i ，如果数组 i 索引处的值为 null ，则通过 cas 的方式进行插入，如果 cas 失败，说明有别的线程在对该处进行操作，则进行下一次 for 循环，下一次 for 循环则会进入 3、4 步中 ③. 帮助扩容 如果 index 处节点不为 null 且 index 处的节点 hash 值为 MOVED ，则进行 helpTransfer() 方法 ④. 普通插入 上述几步都不满足，则说明 index 上有个普通的节点，或为链表，或为树，进行更新或者插入操作 这里需要注意的是，会将 f(即 index 处的节点) 进行加锁，并会再次检查此时的 table index 索引处的节点是否被改变了，如果改变了，则进入下一次循环，如果没有改变依旧为 f ，则进行更新或者插入操作 如果是链表，则遍历链表覆盖更新值或者在链表尾部插入新的键值对(binCount = 原链表长度) 如果是树，则将键值对插入树中 添加完成后，判断该节点上的链表长度，如果超过阈值，则调用 treeifyBin 转为树或者扩容数组，最后调用 addCount 添加计数，视机扩容数组等 initTable()💡 初始化 table 数组 接着看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private final Node&lt;K,V&gt;[] initTable() { Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) { //table 还没初始化，则进行初始化 if ((sc = sizeCtl) &lt; 0) // sizeCtl 小于 0 说明有别的线程在初始化，则让出 CPU 时间碎片 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { //否则，通过 cas 将 sc 和 -1 进行 cas 操作 //SIZECTL 是 sizeCtl 传入的对象 this //(即 sizeCtl 在 ConcurrentHashMap 这个对象中内存的偏移量) // sc 为期望值，此时值为 sizeCtl // -1 为要替换的值 //总结来说就是将 sizeCtl 和 sc 进行比较，如果相等就将 -1 赋值给 sizeCtl，返回 true //否则不赋值返回 false //走到这里说明 cas 成功了 try { if ((tab = table) == null || tab.length == 0) { //如果设置了容量大小则使用设置的容量，否则使用默认的容量 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(&quot;unchecked&quot;) //new 一个数组并赋值 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; //计算扩容的阈值 n - (n &gt;&gt;&gt; 2) 等同于 n * LOAD_FACTOR //只不过使用位运算更快 //即 n * 0.75 = n * 3/4 = n * (1 - 1/4) = n - n/4 sc = n - (n &gt;&gt;&gt; 2); } } finally { //将 sc 的值赋值给 sizeCtl sizeCtl = sc; } //退出循环 break; } } //返回新的 table 数组 return tab;}public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x};这个方法的作用是，读取传入的对象 o 在内存中偏移 offset 的值，并和 expected 比较如果相同，则将 x 赋值给内存中偏移 offset 位置的值，并返回 true否则不赋值返回 false 总结： 如果 sizeCtl 小于 0 则让出，则暂停自己的线程，以便其他线程去执行初始化操作 如果 sizeCtl 大于等于 0 则初始化一个 sizeCtl 大小的数组，并更新 sizeCtl 为自身的负载因子倍( * 0.75) 这里通过 Unsafe.compareAndSwapInt 保证了线程安全 假如有多个线程同时调用了 initTable 方法，只有一个线程的 U.compareAndSwapInt(this, SIZECTL, sc, -1) 会返回 true 走入该 if 中的代码去执行初始化操作，假如有第三个线程来了，则会走入到 Thread.yield() 这里去让出时间碎片 helpTransfer如果在某个线程在进行转移节点数据，则进行判断，满足条件就帮助转移，并返回 table 数组，以便在下次循环中进行插入 12345678910111213141516171819202122232425final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) { Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) { //如果 tab 不为空，且其头节点为 fwd 节点，说明正在扩容迁移 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) { //满足 while 中的条件这里说明正在扩容 //则循环，直到扩容结束 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) { //修改 sizeCtl 成功，修改扩容的线程数 +1，参与扩容 transfer(tab, nextTab); break; } } //扩容结束，返回新 table return nextTab; } //头节点非 fwd 节点，则返回旧 table return table;} resizeStamp(int n) 由于传入的参数 n 都是 2 的 n 次幂，这个方法实际上是用来将这个 n 通过算法将其记录在低16位中 TL;DR 返回值高16位记录为 0，低16位记录的是「扩容标识」，与数组长度有关 123static final int resizeStamp(int n) { return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS- 1));} 其中 Integer.numberOfLeadingZeros(n) 返回 n 在二进制中最高位的1前面0的个数 1234比方说 1 的二进制为 0000 0000 0000 0000 0000 0000 0000 0001则 `Integer.numberOfLeadingZeros(1)` = 31所以 Integer.numberOfLeadingZeros(int n) 的值的范围为 0-32 接着看后半段，*RESIZE_STAMP_BITS 值为 16，*所以 (1 &lt;&lt; (*RESIZE_STAMP_BITS - 1 )* 即1左移15位，得到 0000 0000 0000 0000 1000 0000 0000 0000 最后进行 | 运算*(有1则为1)* 我们以 resizeStamp(16) 为例 123456789(十进制 16) == 0000 0000 0000 0000 0000 0000 0001 0000Integer.numberOfLeadingZeros(16) = 27 == 0000 0000 0000 0000 0000 0000 0001 1001 | 或运算(1 &lt;&lt; (RESIZE_STAMP_BITS- 1) = 1&lt;&lt;15 == 0000 0000 0000 0000 1000 0000 0000 0000 = 等于 0000 0000 0000 0000 1000 0000 0001 1001 可见 resizeStamp 方法会返回一个 高16为都为0，低16位为传入的参数 n 的 「最高位的1前面0的个数」 即高16位记录为 0，第16位为1，低15位记录的是「最高位的1前面0的个数」低16位构成一个「扩容标识」 可见该方法返回的值的取值范围为 [32769,32799] treeifyBin(Node&lt;K,V&gt;[] tab,int index)在往 ConcurrentHashMap 中插入元素后，会调用该方法进行扩容或者将链表转为树 123456789101112131415161718192021222324252627282930private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) { Node&lt;K,V&gt; b; int n; if (tab != null) { if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //如果 tab 的长度小于 MIN_TREEIFY_CAPACITY(64)，则进行扩容操作 tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) { //否则，如果 index 处的节点 b 不为空且 hash 值大于0 synchronized (b) { //加锁 //再次判断，tab 的 index 处是否为 b if (tabAt(tab, index) == b) { //转为树，略过不表 TreeNode&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; e = b; e != null; e = e.next) { TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; } setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); } } } }} 总结： 当插入一个元素后，如果链表的长度超过TREEIFY_THRESHOLD == 8，但整个 table 数组长度小于 MIN_TREEIFY_CAPACITY==64，则进行扩容操作，如果超过了 MIN_TREEIFY_CAPACITY 则将链表转为树 tryPresize(int size)💡 尝试预处理 table 数组的容量以容纳给定的数量的元素 这个方法只在 treeifyBin() 以及 putAll() 中被调用 treeifyBin() 方法传入的 size 为 table.length &lt;&lt; 1 putAll() 传入的 size 为 m.size() 即原 Map 的节点数 以 table.length == 16 为例，调用该方法时候，size = table.length &lt;&lt; 1 即 32，计算出来的 c 为 64，直到 c ≤ sc 时才会退出循环，则 sc 至少需要为 128 * 0.75 = 96 才会退出循环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 尝试调整 table 数组的容量 * @param size 需要调整到的容量 * 这个方法只在 treeifyBin() 以及 putAll() 中被调用 */private final void tryPresize(int size) { //根据 size 的值计算约束出为一个正确的 2的次幂值 //为 MAXIMUM_CAPACITY 或者是大于等于 (size * 1.5 + 1) 的最小的 2次幂 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); // sc 为 sizeCtl 在本方法中的临时变量 int sc; while ((sc = sizeCtl) &gt;= 0) { Node&lt;K,V&gt;[] tab = table; int n; if (tab == null || (n = tab.length) == 0) { //-------①-------- //如果 table 还未初始化，则进行初始化操作 // n 为新的数组容量 n = (sc &gt; c) ? sc : c; //同理，if 中的语句会通过 cas 将 sizeCtl 更新为 -1，表示正在初始化 if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { try { if (table == tab) { @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = nt; //计算 sc，即 n - 0.25 * n = 0.75 * n sc = n - (n &gt;&gt;&gt; 2); } } finally { // 设置新的阈值 sizeCtl = sc; } } } else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) //-------②-------- // c &lt;= sc 说明数组的容量已经足够了 // n &gt;= MAXIMUM_CAPACITY 说明已经超过最大容量了 //则退出循环，不处理 break; else if (tab == table) { //-------③-------- //进行扩容操作 //走到这里说明①和②的情况已经被排除掉了，即已经 table 数组已经初始化过了 //并且c &lt;= sc不成立，即 sc &lt; c ，说明还没扩容完成 //n 为 table 的容量 int rs = resizeStamp(n); if (sc &lt; 0) { //sc &lt; 0 因为数组已经初始化了，说明有其他线程正在扩容 Node&lt;K,V&gt;[] nt; // //sc 右移16位后，高16位为0，低16位为数组长度计算出的扩容标识 //(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs:扩容标识不同 //说明数组长度发生了变化，可能是别的线程触发了第二次扩容 //sc == rs + MAX_RESIZERS:已经达到最大的扩容线程数量了 //(nt = nextTable) == null :nextTable 还没创建 //transferIndex &lt;= 0 需要迁移的区间已经被别的线程分完了 //实际上这里有两个 bug //1. sc == rs + 1 //sc 现在是个负数，rs 高16位都为 0，无论如何 rs + 1 都不会等于 sc //fix: //sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1 // // // //2. sc == rs + MAX_RESIZERS //MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = (1 &lt;&lt; 16) -1 = 65535 //rs 的取值范围为 [32769,32799] 而 rs + MAX_RESIZERS &gt; 0 并且还没溢出为负数 //也无论如何都不会相等 //fix: //sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS // //将 rs 左移 16位，其高16位才是扩容标识，低16为存储扩容的线程数 + 1 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; //下面这里对 sizeCtl 加一，表示参与迁移的线程数 +1，并进行迁移 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } //说明自己是第一个进行扩容的线程，则通过 cas 的方式，将 rs 左移 16位并加2，存储在 sizeCtl 中 //通过前面的 resizeStamp 方法我们直到 rs 的高16位为0，这里左移16位，则低16位都为0，再加2 //则用低16为表示正在扩容的线程数，并且用 2 表示第一个正在扩容的线程 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); } }} transfer()transfer(Node&lt;K,V&gt; tab, Node&lt;K,V&gt;[] nextTab)💡 将旧数组的数据迁移到新的数组中，支持多线程迁移 字段说明transferIndex 是个全局变量，通过 volatile 修饰，并通过 cas 的方式进行修改，用来表示当前线程应该从哪个地方开始往前遍历，如果 transferIndex &lt;= 0 说明对数组的转移已经到头了，不需要再继续处理了 i 字段表示当前线程在迁移的桶的索引 bound 字段表示当前线程的需要迁移的区间的上边界 总结即每个线程的迁移区间为 [bound,transferIndex)，并通过 i 在该区间从后往前遍历桶进行迁移处理，遍历区间完成后，会继续竞争下一个区间 为了高效的进行迁移数据，这里允许多个线程进入，但是给每个线程分配了旧数组的一段区间进行迁移，避免多个线程同时迁移同个区间，代码中通过 cas 的方式， 让多个线程通过 cas 的操作竞争 transferIndex 字段，并通过 transferIndex 字段和 stride 计算出每个线程的迁移区间，所以线程在处理完竞争到的某个区间后，会不停地往前竞争处理下一个区间，直到处理到数组最前面的区间，比如说[0,16) 的区间后，transferIndex 等于 0，所以 i = -1， 就会将 sizeCtl 中低16位中存储的线程数减1后 return，退出迁移，等到所有的线程对所有的区间处理完毕后，其他线程都退出迁移操作了，最后一个线程会将 finish 设置为 true， 再进行下一次循环后会将新的 nextTab 赋值给 table 并将 nextTable 置为空 从 HashMap 的迁移算法中我们也可以直到，对于一个节点，在扩容迁移后，要么还在原来的桶(假设索引为 index)中，要么就在索引为 2 * index 的桶处 同理在 ConcurrentHashMap 中也是这样子，所以不会造成多个线程同时转移到同一个桶中 首先会计算每个线程需要进行迁移的步长 stride，即迁移的桶的数量，至少为 16 在进行迁移时，会从后往前对 table 数组进行遍历，逐步对桶内的数据(链表或者树)进行迁移 由于篇幅太长，我们假设步长 stride 为4，举例进行说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//当第一个线程进行转移数据时，nextTab == null，否则为全局变量 nextTableprivate final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) { int n = tab.length, stride; //计算步长 stride，至少为 16 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) { // initiating //nextTab 为 null 说明是第一个线程进行转移 try { //创建一个容量为旧数组容量两倍的新数组，并赋值给 nextTab @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; } catch (Throwable ex) { // try to cope with OOME //如果产生 OOM 等异常，则直接退出，不转移了 sizeCtl = Integer.MAX_VALUE; return; } //将新数组赋值给 nextTable ，此时数组为一个没有数据的空数组 nextTable = nextTab; //transferIndex 记录旧数组的长度，表示转移开始的索引值 transferIndex = n; } //nextn 为新数组的容量 int nextn = nextTab.length; //fwd 是用来标识某个桶处正在转移的，存储了新数组 ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); //advance 是否前进，用来标记是否需要在区间内继续往前前进处理 boolean advance = true; //finishing 是否扫描结束了，用来标记是否将所有的区间都迁移完成了 boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) { //这里将 i 和 bound 初始化为 0，并开始死循环，直到数据转移成功后再退出循环 Node&lt;K,V&gt; f; int fh; //在第一个线程第一次执行到这里时 //--i == -1， bound == 0，第一个判断为 false //注意这里每次进入 while 循环都会做一次 --i 的操作，使得 i 不断的自减 //nextIndex = transferIndex == n == tab.length 即旧数组的长度，大于0，第二个判断为 false //则走到第三个判断中 //nextBound 为下一个线程需要进行转移的数组的下边界 //计算 nextBound 的值，如果 nextIndex(即就数组的长度)大于步长 stride， //则 nextBound = nextIndex - stride，并通过 cas 的方式赋值 //给全局变量 transferIndex，即下个线程需要转移的区间的下边界 //下面的代码主要就是在第一次循环时，计算出来 [bound,transferIndex) 这个区间 //在下一次 for 循环则会走到第一个判断中，直到 i &lt; bound 或者 finishing //当 i &lt; bound 时，即当前线程已经把分配给自己的区间里的桶都转移完毕了 //如果此时别的线程还没有将整个数组转移完毕(transferIndex &lt;= 0 不成立)， //则当前线程会继续往前竞争下一个区间，这也就是如果只有一个线程的话，也可以迁移完成 while (advance) { int nextIndex, nextBound; if (--i &gt;= bound || finishing) //某个线程的第二次循环时候才会走到这里来，说明 i 还在该线程需要转移的区间内 //[bound &lt;--&gt; i &lt;--&gt; transferIndex) advance = false; else if ((nextIndex = transferIndex) &lt;= 0) { //transferIndex &lt;= 0 说明将已经到最前面了，将 i 赋值为 -1 //则会走到 ③ 处执行，简单来说 ③ 处会做一些判断是否该线程要退出迁移操作 i = -1; advance = false; } else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) { //走到这里说明 i &lt; bound 且 transferIndex &gt; 0 (即整个 table 的转移还没处理完成) //通过 cas 继续认领一段区间进行转移 //计算出当前线程所需要处理的区间 //nextBound 就是下一个线程的下边界，也就是当先线程的上边界 bound = nextBound; //i 为索引值，所以需要 - 1 i = nextIndex - 1; advance = false; } } if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) { //-----③---- //如果 i &lt; 0 或者 i &gt;= n 说明已经超出了所需要处理的区间了 int sc; if (finishing) { //------①----- //如果 finishing 为 true ，说明所有的桶都处理完了 //则将新的数组赋值给 table 并将 nextTable 置为空 nextTable = null; table = nextTab; //并且设置新的阈值，新数组的长度为 2n，所以阈值应该为 0.75 * 2n，即 2n - 0.5n sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //返回，结束迁移 return; } //走到这里说明 finishing 为 false，即还未处理完所有的桶 //但当前线程需要处理的区间内的桶已经处理完了，所以将 sizeCtl 减一表示正在迁移的线程数 -1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) { if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) //if 中为 true 说明当前线程不是最后一个在进行迁移的线程，返回，结束本线程的迁移 return; //走到这里说明当前线程是第一个参与迁移的线程 //将 finishing 和 advance 均设为 true //并把 i 设置为 n(即旧数组 table 的长度) //这样下一次循环就会走入 ① 处的逻辑结束迁移 finishing = advance = true; i = n; // recheck before commit } } else if ((f = tabAt(tab, i)) == null) //如果索引为 i 的桶处为 null，则通过 cas 方式将 fwd 放在该桶处 //接着将 advance 设置为 true，退出循环继续往前 advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) //如果索引为 i 处的桶上的数据不为空，且其 hash 值为 MOVED //代表该处的数据已经迁移过了，将 advance 设置为 true，退出循环继续往前 advance = true; // already processed else { //否则，索引为 i 处的桶上有数据，则对桶处的头节点加锁 //进行迁移，迁移完成后会将 advance 设置为 true synchronized (f) { if (tabAt(tab, i) == f) { //二次确认索引为 i 处的桶的节点为 f //进行数据迁移，见后文细说 } } } } }} 链表/树的转移123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687if (tabAt(tab, i) == f) { Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) { //如果头节点 f 的 hash 值大于0，说明为链表 //计算出 fh 和 n 的与运算的结果，由于 n 为数组的长度，是2的次幂，所以只有最高位为1，其他都为0 //与运算计算出来后 runBit 要么为 0 ，要么为 n //如果 runBid == 0 说明扩容后 f 依旧在原来的 index 处，否则在 index + n 处 // int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) { //遍历链表，找到第一个后面全部为相同的 runBit 的节点 //举个例子 //链表 ： A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G //runBit 值： n-&gt;0-&gt;n-&gt;0-&gt;0-&gt;0-&gt;0 //则这个 for 循环跑完以后，lastRun 则为D，runBit = 0 //后续则可以将这个 D 后面的所有节点都一起挪动过去，就不需要再一个一个处理 int b = p.hash &amp; n; if (b != runBit) { runBit = b; lastRun = p; } } if (runBit == 0) { //如果 runBit == 0 说明这些节点还要放在相同 index 的桶里，赋值给 ln ln = lastRun; hn = null; } else { //否则 runBit == n 说明这些节点还要放在相同 index + n 的桶里，赋值给 hn hn = lastRun; ln = null; } for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) { //循环，构建两个链表，将节点插入对应的链表的尾部 int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); } //将 ln 插入新的 table 的 i 处 setTabAt(nextTab, i, ln); //将 ln 插入新的 table 的 i + n 处 setTabAt(nextTab, i + n, hn); //将旧的 table i 处置为 fwd setTabAt(tab, i, fwd); //更新 advance 为 true，准备下次 for 循环 advance = true; } else if (f instanceof TreeBin) { //同理对 TreeBin 进行迁移 TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) { int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) { if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; } else { if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; } } ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; }} 元素数量计数size() 获取 map 中键值对的数量 返回 sumCount 方法的值，如果小于0，则返回0，如果超过了 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE 123456public int size() { long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n); } sumCount()返回 baseCount 和 counterCells 列表中值的总和 的和 12345678910111213141516final long sumCount() { CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) { for (int i = 0; i &lt; as.length; ++i) { if ((a = as[i]) != null) sum += a.value; } } return sum;}@sun.misc.Contended static final class CounterCell { volatile long value; CounterCell(long x) { value = x; }} 那这个 baseCount 和 counterCells 是什么呢，我们在前面 putVal 的流程中还没有介绍 addCount(1L,binCount) 这个方法。通过名字我们也能看出来这是个用来增加计数的方法 我们先来看这个方法 addCount(long x,int check)x 表示新增的节点数 check 表示是否需要进行扩容检查，如果 &lt; 0 则不进行扩容 从前面 putVal 中我们可以知道，当一个键值对节点插入到链表中时， check 的值为链表的长度，当插入到红黑树中时，check 为 2 这个方法分为两个部分，前一部分是通过 LongAdder 的方式，进行计数，后半部分中会进行扩容迁移操作后，再进行计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private final void addCount(long x, int check) { CounterCell[] as; long b, s; //第一个判断：(as = counterCells) != null //表示 counterCells 已经被初始化了 //第二个判断：将 baseCount 通过 cas 的方式修改为 baseCount + x //如果修改成功说明没有竞争 //如果修改失败，说明存在竞争，则进入下面的逻辑对 counterCells 进行处理 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { CounterCell a; long v; int m; boolean uncontended = true; //前两个判断 as == null || (m = as.length - 1) &lt; 0 //判断 counterCells 是否初始化了，并且数组中是否有内容 //如果为还未初始化或者数组中没有内容，则调用 fullAddCount(x, true) //第三个判断是在前两个判断都为 false 的基础上 //进一步获取 counterCells 中当前线程所对应的 CounterCell 元素 //如果为空，则调用 fullAddCount(x, true) //如果不为空，则尝试对 CounterCell 通过 cas 进行累加，累加成功则进行下一步 //累加不成功说明存在竞争，则调用 fullAddCount(x, false) //uncontended 代表是否无竞争 if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { //详见后面的小节 fullAddCount(x, uncontended); return; } if (check &lt;= 1) return; s = sumCount(); } if (check &gt;= 0) { //当 check &gt;= 0，则尝试是否需要扩容 Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) { //当下面的三个条件都满足时，才会进入这里 //1. 当 s (节点数量) &gt;= 阈值 sizeCtl 了 //2. table 不为 null //3. table 的长度小于最大容量 // //rs 的高16位为0，低16为存储数组长度 n 计算出来的值 int rs = resizeStamp(n); if (sc &lt; 0) {( // //sc 右移16位后，高16位为0，低16位为数组长度计算出的扩容标识 //(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs:扩容标识不同， // 说明数组长度发生了变化，可能是别的线程触发了第二次扩容 //sc == rs + MAX_RESIZERS:已经达到最大的扩容线程数量了 //(nt = nextTable) == null :nextTable 还没创建 //transferIndex &lt;= 0 需要迁移的区间已经被别的线程分完了 //实际上这里有两个 bug //1. sc == rs + 1 //sc 现在是个负数，rs 高16位都为 0，无论如何 rs + 1 都不会等于 sc //fix: //sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 1 // // // //2. sc == rs + MAX_RESIZERS //MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1 = (1 &lt;&lt; 16) -1 = 65535 //rs 的取值范围为 [32769,32799] 而 rs + MAX_RESIZERS &gt; 0 且还没溢出为负数 //也无论如何都不会相等 //fix: //sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + MAX_RESIZERS // //将 rs 左移 16位，其高16位才是扩容标识，低16为存储扩容的线程数 + 1 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) //不需要扩容 break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) //此时有别的线程在扩容了，则帮助进行扩容 transfer(tab, nt); } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) //进行扩容，这里是第一个进行扩容的线程 transfer(tab, null); //进行计数 s = sumCount(); } }} fullAddCountprivate final void fullAddCount(long x, boolean wasUncontended) x表示新增的节点数量 wasUncontented 表示是否无竞争 true == 表示没有竞争 false == 表示有竞争 在 ConcurrentHashMap 中，其实是复制了一份 LongAdder 的源码，在 ConcurrentHashMap 中，由于并发情况多，如果使用 AtomicLong 的方式进行记录，如果 N 个线程同时对 AtomicLong 进行修改，只有一个线程能修改成功，其他线程则会处于自旋等待状态，而 LongAdder 的方式是使用一个变量 baseCount+数组 CounterCell[]，让每个线程去维护自己的一个变量，减少碰撞冲突，每个线程维护数组中的一个对象，对象中存储一个值；从 CounterCell[] 中获取到对应的值并进行修改，如果修改失败，则尝试修改 baseCount 的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104private final void fullAddCount(long x, boolean wasUncontended) { int h; if ((h = ThreadLocalRandom.getProbe()) == 0) { //如果还没有初始化，则进行初始化 ThreadLocalRandom.localInit(); // force initialization h = ThreadLocalRandom.getProbe(); //还没初始化，所以不存在竞争，将 wasUncontended 设置为 true wasUncontended = true; } //collide 表示是否多个线程 hash 到同一个 CounterCell 产生碰撞了 boolean collide = false; // True if last slot nonempty for (;;) { CounterCell[] as; CounterCell a; int n; long v; if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) { //如果 counterCells 不为 null 且 counterCells 长度大于 0 if ((a = as[(n - 1) &amp; h]) == null) { //取到 counterCells 中对应线程的 CounterCell 为空 //cellsBusy 字段为 1 说明 counterCells 正在初始化或者扩容 if (cellsBusy == 0) { // Try to attach new Cell //下面为尝试创建一个 CounterCell 对象并存到 counterCells 数组对应的索引处 CounterCell r = new CounterCell(x); // Optimistic create if (cellsBusy == 0 &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) { //counterCells 为正常状态且修改 cellsBusy 为1 成功 boolean created = false; try { // Recheck under lock CounterCell[] rs; int m, j; if ((rs = counterCells) != null &amp;&amp; (m = rs.length) &gt; 0 &amp;&amp; rs[j = (m - 1) &amp; h] == null) { //j 是当前线程的 hash 值计算得出的索引 //对 counterCells 中 j 处的元素进行替换 rs[j] = r; created = true; } } finally { cellsBusy = 0; } if (created) //创建成功，退出循环 break; //创建不成功，则进行下一次循环 //可能是因为 rs[j] != null，即该处有值了 continue; // Slot is now non-empty } } collide = false; } else if (!wasUncontended) // cas 失败了，则设置为 true，在下次循环的时候重新计算 hash 再进行分配 wasUncontended = true; // Continue after rehash else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x)) //修改当前 CounterCell 中的 value 成功，则退出 break; else if (counterCells != as || n &gt;= NCPU) //counterCells != as 说明 counterCells 被扩容了 //或者 as 大于等于 CPU 的数量了，等待下一轮重试 collide = false; // At max size or stale else if (!collide) //上述条件都不满足，说明产生了碰撞，且竞争失败了 //将值 collide 修改为 true，下一次循环就可以走到下个 if 中 collide = true; else if (cellsBusy == 0 &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) { //counterCells 处于正常状态，且修改 cellsBusy 值为1成功 //则对 counterCells 进行扩容并迁移数据， try { if (counterCells == as) {// Expand table unless stale CounterCell[] rs = new CounterCell[n &lt;&lt; 1]; for (int i = 0; i &lt; n; ++i) rs[i] = as[i]; counterCells = rs; } } finally { cellsBusy = 0; } collide = false; continue; // Retry with expanded table } //重新计算 hash 值 h = ThreadLocalRandom.advanceProbe(h); }//这里是 (as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0 这个条件结束的地方 else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp; U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) { //走到这里说明 counterCells 为空，则进行初始化，容量为2，并将 CounterCell 放进数组中 boolean init = false; try { // Initialize table if (counterCells == as) { CounterCell[] rs = new CounterCell[2]; rs[h &amp; 1] = new CounterCell(x); counterCells = rs; init = true; } } finally { cellsBusy = 0; } if (init) break; } //走到这里说明 counterCells 为空，且竞争初始化失败了，则尝试将 x 加到 baseCount 上 else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x)) break;// Fall back on using base }} 小结至此，我们就看完了 ConcurrentHashMap 中的 put 的方法 参考链接 通俗易懂的JUC源码剖析-LongAdder/LongAccumulator 从 LongAdder 中窥见并发组件的设计思路 精妙绝伦的并发艺术品 — ConcurrentHashMap是如何保证线程安全的 ConcurrentHashMap源码分析(1.8) 从死循环BUG来聊聊ConcurrentHashMap的执行内幕（上） Java容器探秘之旅 ConcurrentHashMap ConcurrentHashMap","link":"/2021/12/23/2021_12_23_concurrenthashmap/"},{"title":"Java 线程的中断机制","text":"简单回顾一下 Java 的中断机制 Java 中的线程 Thread 有以下三个方法 public void interrupt() 1234567891011121314public void interrupt() { if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) { Interruptible b = blocker; if (b != null) { interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; } } interrupt0();} public static boolean interrupted() 123public static boolean interrupted() { returncurrentThread().isInterrupted(true);} isInterrupted() 123public boolean isInterrupted() { return isInterrupted(false);} 方法 作用 interrupt() 中断线程 当线程处于 Runnable 状态时，调用该方法中断该线程，会使得 isInterrupted() 方法返回 true 当线程处于 Block 或者 Wait 阻塞状态时，如果是通过 thread.wait(),thread.join(),Thread.sleep() 方法处于阻塞状态时，则会抛出 InterruptedException,如果是通过 LockSupport.park() 方法使线程处于阻塞状态，则不会抛出 InterruptedException interrupted() 静态方法，作用于调用该方法的当前线程，这个方法的命名用的是一般过去时，所以返回的值代表的是「线程是否被中断过」并且会清除掉该线程的中断状态 isInterrupted() 公开方法，作用于调用该方法的线程对象，返回值代表的是「调用该方法的线程是否被中断过」，但不会清除该线程的中断状态","link":"/2022/02/17/2022_02_17_Java_Interrupt/"},{"title":"HTTPS 是如何保证安全的","text":"众所周知，HTTP 协议是明文传输的，在网络世界里用 HTTP 协议发送报文相当于裸奔，于是就有了 HTTPS这个 S 是什么呢，是如何保证我们发送的报文就不被窃取和篡改了呢，让我们慢慢道来 其实这个 S 指的就是 SSL/TLS我们知道 HTTP 在网络协议中属于应用层，在发送报文时会将报文交给 TCP 进行传输，而 TCP 层面则是明文的，于是 HTTPS 在将报文发给 TCP 之前，通过 TLS 将报文进行加密后再通过 TCP 进行传输 那么 HTTPS 是如何进行加密的呢 说到这里，我们需要先来了解一下加密算法 对称加密所谓对称加密，就是用来加密和解密的密钥都是同一个， 当我们使用对称加密的时候，就是用密钥将元数据通过加密算法，转变成密文，当另一方需要将密文转成原文的时候，需要用同一个密钥和相对应的解密算法，将密文给还原成原文。但对称加密的缺陷在于，如何保证密钥的安全性，如何保证只有通信的双方才持有该密钥而不被其他人窃取，而非对称加密就是来解决这个问题的 非对称加密非对称加密，是因为数学家们研究出了一种算法，这种算法两个不同的密钥，通过密钥 A 对原文进行加密后，只能通过密钥 B 进行解密。和对称加密不同的是，非对称加密只有一个算法，不需要『加密算法』和『解密算法』，也就是说同一个算法，经过密钥 A 加密过的密文只能由密钥 B 解密。 但所谓的『原文』和『密文』只是相对的，我们也可以将所谓的『原文』当做被加密过的数据，而把『密文』当做加密前的数据，所以从下图看，密钥 A 和密钥 B 其实也是可以相互交换的，密钥 B 可以用来当做加密用的密钥，而让密钥 A 当做解密用的密钥。但一般来说不会这么做，这是因为非对称加密的算法是有很多种的，而密钥 A 和密钥 B 是成对存在的，一般来说是不能相互推导的，即我不能通过密钥 A 计算出密钥 B，也不能通过密钥 B 计算出密钥 A，但也不是绝对的，其实也是可以推导出来的，只不过对于如今的计算运力来说不足以在短时间内推导出来，可能需要上百年上千年，所以我们姑且认为是无法推导出来的。但也有一些非对称加密算法是例外的，有些非对称加密的算法是可以通过密钥 A 计算出来密钥 B 的。所以这个时候，我们就不能用密钥 B 进行加密而把密钥 A 公开了。因为这样的话，就相当于所有人都知道了密钥 A 和 密钥 B 是什么，就相当于没有加密了。 而密钥 A ，我们把它称为私钥，密钥 B 称为公钥。所谓私钥，就是要对信息进行加密的持有者所持有的密钥，这个密钥只能自己持有，不能公开，而公钥是可以在任何地方公开的，只有持有私钥的一方才可以将被公钥加密过的信息解密得到原文。 也就是说，假如我要发送一个消息给对方，我需要先得到对方的公钥，然后用对方的公钥对信息进行加密后再发送给对方，而只有对方(公钥对应的私钥拥有者)才能将信息还原成原文 在消息的发送前，发送方需要获取到接收方的公钥，而在这个过程中，发送方是如何确定这个公钥就真的是接收方的公钥而不是被篡改过的呢。且听我娓娓道来。让我们先来看一个知识点(敲黑板) 非对称加密的应用数字签名所谓数字签名，就是证明这个东西是我发出的在网络世界里，所有的数据包都有可能被截获篡改，所以当我们收到某个消息时，如何确定这条消息就是我认为的那个人发出的呢，这就需要用到『非对称加密』的一个应用–『数字签名』了。通过上图可见，当接收方对比 摘要 和 摘要’ 相同时，就可以认为这条消息是没有被篡改过的，是来自于这个公钥所对应的私钥的拥有者发出的。 但在我们的消息发送的过程中还有个问题，接收方怎么就知道这个公钥就是我认为的消息的发送者的呢。万一中间有人把所有的信息(公钥修改了，同时用新的公钥计算出密文和 hash)都修改了，那接收方通过这种方式验证出来的结果都是正确的，那怎么办。 于是问题的痛点就落在了我们需要保证公钥的正确性上 这就需要证书了 数字证书为了解决无法证明公钥的正确性的问题，有了数字证书。数字证书是由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。 要得到一份数字证书，需要由服务器端的(或者说是信息的发送方)到数字证书认证机构去申请，而 CA 确认该身份后通过申请，则会给该申请者一个包含经过 CA 签名的公钥的数字证书。 数字证书中包括了「签名」+「csr 文件」 其中，csr 文件包括信息发送方的「公钥」、「申请者信息」、「域名」等CA 机构通过对这些信息通过摘要算法计算出摘要(记为摘要 A)，并用私钥进行加密，得到「签名 A」，并把「签名 A」 和 csr 文件内容打包成证书 在网络传输中，接收者就会拿到这个证书，进行验证 首先接收者的系统/浏览器中内置了 CA 机构的公钥，拿到公钥后对接收到的证书中的「签名 A」进行解密，得到「摘要 A」，再使用相同的摘要算法对 csr 文件进行计算，得到「摘要 B」，比对「摘要 A」和「摘要 B」，如果无法计算出「摘要 A」或者「摘要 A」和「摘要 B」不相同，则认为这个证书不可信，否则则认为这个证书可信，则可以获取到 csr 文件中信息发送者的公钥 至此就完成了信息发送者的公钥的安全传输过程(防止被篡改和替换) 图片来源于 数字证书、签名到底是什么？这篇文章讲得太好了 TLS 四次握手Client Hello 客户端向服务端发送 TLS 支持的版本 支持的加密算法以及版本 支持的压缩算法 Client Random A Server Hello、Certificate、Server Hello Done 服务器向客户端进行响应 选择的 TLS 版本 选择的加密算法 Client Random B Certificate 发送服务器的证书Client 在收到 Server 发送过来的证书后会对证书进行校验 Server Hello DoneClient Key Exchange,Change Clpher Spec,FinishClient Key Exchange 证书校验通过后，Client 会使用 Random A 和 Random B 生成一个 pre-master 的值，通过 Server 的 Public Key 对 pre-master 进行加密后发送给 Server Change Clpher Spec: 并告知服务端后续使用算法计算出来的 key 对通信内容进行加密 此时 Client 已经拥有了 Random A 、 Random B 和 pre-master，用这三个值可以计算出 session-key，用于作为对称加密的密钥 Finish: 对上述所有握手过程中的数据使用商量好的 Hash 算法计算 HashCode，并使用 session-key 进行加密 New Session Ticket,Change Cliper Spec,FinishServer 使用自己的私钥对上一步中发来加密过的 pre-master 进行解密，得到明文的 pre-master此时 Server 也拥有了 Random A 、 Random B 和 pre-master ，使用商量好的算法计算出 session-key并使用 session-key 对上一步中 Client 中发来的数据和 HashCode 进行校验，以用来证明 Client 计算的 session-key 是正确的 New Session TicketServer 发送给 Client 的 Session，用于下一次会话使用，Client 的下一次请求在 Client Hello 中带上 Session Ticket，Server 判断该 Session Ticket 有效且正确则可以跳过握手中的部分过程 Change Cliper Spec: 告知 Client 后续的信息都通过 session-key 进行加密 Finish: 对上述所有握手过程中的数据使用商量好的 Hash 算法计算 HashCode，并使用 session-key 进行加密 Application Data这一步不算是 TLS 的范畴了而是 HTTP 协议的范畴Client 使用商量出来的 session-key 对数据进行对称加密发送给 Server ，Server 接收到数据后使用 session-key 进行解密得到明文数据，再将结果进行加密后返回给 Client 总结 TLS 的握手示意过程如下 123456789101112131415161718|----------Client----------|----------Server----------|| Client Hello --&gt; ||-----------------------------------------------------|| | Server Hello || | Certificate || &lt;-- Server Hello Done ||-----------------------------------------------------|| Client Key Exchange | || Change Cipher Spec | || Finish --&gt; ||-----------------------------------------------------|| | New Session Ticket || | Change Cipher Spec || &lt;-- Finish ||-----------------------------------------------------|| Application Data &lt;-&gt; Application Data ||-----------------------------------------------------| Wireshark 抓包的握手过程 参考数字证书、签名到底是什么？这篇文章讲得太好了","link":"/2019/01/01/communication-with-https/"},{"title":"HashMap 源码阅读笔记","text":"基础知识位运算符 位与 &amp; 1 &amp; 1 = 1 ，其余都是 0 12345sample : 001110100010即 `3 &amp; 10 = 2` 位或 | 0 | 0 = 0 ，其余都是 1 12345sample : 001110101011即 `3 | 10 = 11` 位异或 ^ 相同为 0， 不同为1 12345sample : 001110101001即 `3 ^ 10 = 9` 非 ~ 按位取反 1234sample : 00111100即 `~3 = -4` Tips &amp; 是都得为1才能得到1 ，| 是只要有1就为1，^ 是相同则为 0，不同则为 1。 原码第一位是符号位，1 是负数，0是正数 121000,1000 是 -80000,1000 是 +8 因此可用的范围只是后七位，即8进制的数值范围是 [1111 1111,0111 1111]，用十进制表示是 -(2^7 -1) ~ (2^7 -1 ) 即 [-127,127] 反码 正数的反码是其原码本身负数的反码是在符号位不变，其余的按位取反 12+10：[0000 1010]原 == [0000 1010]反-10：[1000 1010]原 == [1111 0101]反 补码 正数的补码是其原码本身负数的补码是符号位不变，其余的按位取反，再加一。即 [负数的补码] = [负数的反码] + 1; 12+10：[0000 1010]原 == [0000 1010]反 == [0000 1010]补-10：[1000 1010]原 == [1111 0101]反 == [1111 0110]补 左移 &lt;&lt; 逻辑左移 N 位，空缺部分补 0 121 &lt;&lt; 3 == 8;即 0001 =&gt; 1000 无符号右移 &gt;&gt;&gt; 逻辑右移 N 位，空缺部分补 0 128 &gt;&gt;&gt; 3 == 1;即 1000 =&gt; 0001 有符号右移 &gt;&gt; 左边的空出的所有位数根据移位前原来的内容，原来为0就补0，原来为1就补1 注意：负数是使用补码进行计算 12345678910111213141516171819202122-8 &gt;&gt;&gt; 3 (-8 无符号右移 3 位)-8 ==[1000,0000,0000,0000,0000,0000,0000,1000]原[1111,1111,1111,1111,1111,1111,1111,0111]反[1111,1111,1111,1111,1111,1111,1111,1000]补右移三位(高位补充0) =&gt;[0001,1111,1111,1111,1111,1111,1111,1111]补[0001,1111,1111,1111,1111,1111,1111,1111]反[0001,1111,1111,1111,1111,1111,1111,1111]原== 2^29 -1-8 &gt;&gt; 3 (-8 有符号右移 3 位)-8 == [1000,0000,0000,0000,0000,0000,0000,1000]原[1111,1111,1111,1111,1111,1111,1111,0111]反[1111,1111,1111,1111,1111,1111,1111,1000]补右移三位(根据原内容补充) =&gt;[1111,1111,1111,1111,1111,1111,1111,1111]补[1111,1111,1111,1111,1111,1111,1111,1110]反[1000,0000,0000,0000,0000,0000,0000,0001]原== -1 Tips 对于正数 x 来说，左移 n 位&lt;&lt;相当于 x * 2^n，右移 n 位&gt;&gt;相当于 x mod 2^n，取余无符号右移 n 位 &gt;&gt;&gt;相当于 x mod 2^n，取余 对负数 y 来说，左移 n 位&lt;&lt;相当于 y * 2^n，右移 n 位&gt;&gt;相当于 HashMap 的基本原理源码解读全局变量 DEFAULT_INITIAL_CAPACITY 1234567/** * The default initial capacity - MUST be a power of two. * 默认初始化容量，必须是2的幂 */ static final int DEFAULT_INITIAL_CAPACITY = 4;//JDK7static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //即16 JDK8 MAXIMUM_CAPACITY 12345678/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * 最大的容量，必须是2的幂，并且在 [2,2^30]之间 * int 型的最大值为 2^31 -1 ，但 HashMap 的容量必须是 2 的幂，所以最大值只能是 2^30 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; DEFAULT_LOAD_FACTOR 12345/** * The load factor used when none specified in constructor. * 默认的负载因子值，用来计算扩容的临界值，0.75f */static final float DEFAULT_LOAD_FACTOR = 0.75f; EMPTY_TABLE 12345/** * An empty table instance to share when the table is not inflated. * 当 table 还没扩容时的实例，即一个空的table */static final HashMapEntry&lt;?,?&gt;[] EMPTY_TABLE = {}; table ;HashMap 中的存放键值对的单链表数组 12345/** * The table, resized as necessary. Length MUST Always be a power of two. * 可以随时调整的 table，长度必须是2的幂 */transient HashMapEntry&lt;K,V&gt;[] table = (HashMapEntry&lt;K,V&gt;[]) EMPTY_TABLE; size 12345/** * The number of key-value mappings contained in this map. * 这个 map 中键值对的数量 */transient int size; threshold 123456789/** * The next size value at which to resize (capacity * load factor). * 下一次进行扩容的值，即阈值，等于最大容量 * 负载因子 * @serial */// If table == EMPTY_TABLE then this is the initial capacity at which the// table will be created when inflated.//如果 table 是空的时候，即 table == EMPTY_TABLE ， threshold 的值就是 table 扩容时的初始容量int threshold; loadFactor 123456789/** * The load factor for the hash table. * hash table 的负载因子 * @serial */// Android-Note: We always use a load factor of 0.75 and ignore any explicitly// selected values.//Android-Note: 使用 0.75 这个固定的值，忽略其他明确的值final float loadFactor = DEFAULT_LOAD_FACTOR; modCount 12HashMap 的结构被修改的次数结构修改指的是那些 HashMap 中映射数量或者是其内部结构(比如 rehash)的修改 构造函数好了，现在开始来看构造函数 12345678910111213141516171819202122232425262728293031/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) { initialCapacity = MAXIMUM_CAPACITY; } else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) { initialCapacity = DEFAULT_INITIAL_CAPACITY; } if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // Android-Note: We always use the default load factor of 0.75f. // This might appear wrong but it's just awkward design. We always call // inflateTable() when table == EMPTY_TABLE. That method will take &quot;threshold&quot; // to mean &quot;capacity&quot; and then replace it with the real threshold (i.e, multiplied with // the load factor). threshold = initialCapacity; init();} 在构造函数中，接收两个参数，一个是初始容量(initialCapacity)，一个是负载因子(loadFactor) 从代码中可见，前面都是在进行判断这两个值的合法性，比如初始容量必须大于等于0，如果大于可容纳的最大容量，则赋值为最大值MAXIMUM_CAPACITY(2^30) ，如果小于默认的容量，则赋值为最小容量。负载因子的必须大于0，并且是个浮点数(Float) 最后一步将初始容量赋值给 thresholdinit() 方法是个空方法，忽略不计 put 方法向 HashMap 中添加一个键值对，并返回 value 12345678910111213141516171819202122232425262728293031 public V put(K key, V value) { //当 table 是空的时候，对 table 进行扩容 if (table == EMPTY_TABLE) { inflateTable(threshold);//① } //如果key 是 null，则放入 value并返回旧的值 if (key == null) return putForNullKey(value);//② //key 不为 null，计算 key 的 hash 值 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //通过 key 的 hash 值和数组 table 的长度计算出这个`键值对`应在数组中的索引值 int i = indexFor(hash, table.length);//③ //获取到当前索引值存放的链表，并进行循环 for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; //如果该链表上有一个键值对 e ，并且这个键值对 e 的 hash 值和新放入的键值对的hash相同，并且key值也相同，则将新的 value 替换旧的 value，并返回旧的 value 值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //否则，即当前链表上没有 key 值以及 hash 值相同的键值对，则 modCount 自增 modCount++; //新增一个键值对 addEntry(hash, key, value, i);//④ //返回 null return null; } ① 先看 inflateTable(int toSize) 方法 先计算 table 的容量 再计算新的阈值 创建 table 对象，即 HashMapEntry 数组 123456789101112131415161718192021/** * 扩容 table ，toSize 是要扩大到的容量 */private void inflateTable(int toSize) { // Find a power of 2 &gt;= toSize //计算 table 的容量，因为必须是2的幂，所以通过 roundUpToPowerOf2() 方法计算出大于等于 toSize 值的 2的幂 int capacity = roundUpToPowerOf2(toSize); // Android-changed: Replace usage of Math.min() here because this method is // called from the &lt;clinit&gt; of runtime, at which point the native libraries // needed by Float.* might not be loaded. //再计算新的阈值，即 table 容量 * 负载因子，如果超过了最大的容量，则将阈值设置为 table 最大值 + 1 float thresholdFloat = capacity * loadFactor; if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) { thresholdFloat = MAXIMUM_CAPACITY + 1; } threshold = (int) thresholdFloat; // 新建一个 HashMapEntry 对象，即 table table = new HashMapEntry[capacity];} ② 再接着看 putForNullKey(V value) 方法 可见 HashMap 是可以存入键值(key) 为 null 的键值对的，并且会将 key = null 的键值对放到数组的第一位，即 table[0] 12345678910111213141516171819202122/** * Offloaded version of put for null keys */private V putForNullKey(V value) { //取出数组中索引为 0 的链表，进行循环， for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) { //如果链表中有 key 为 null 的键值对，即该 HashMap 中有 key 为 null 的键值对，则将新值替换旧值，并返回旧值。 if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } //如果原来链表中没有 key 为 null 的键值对，将 modCount 自增 modCount++; //并向链表中添加一个键值对 addEntry(0, null, value, 0); //返回 null return null;} ③ 再看计算索引的方法 indexFor(int hash, int length)hash -&gt; hash 值length -&gt; 数组长度 12345678/** * Returns index for hash code h. */static int indexFor(int h, int length) { // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;; //即相当于 h % length，取余数 return h &amp; (length-1);} ④ 接着看 addEntry(int hash, K key, V value, int bucketIndex) 方法这个方法有四个入参分别是 入参 意义 hash key 的 hash 值 key key(键) value value(值) bucketIndex 该键值对应该放在 table 中的索引 12345678910111213void addEntry(int hash, K key, V value, int bucketIndex) { //判断当前的键值对数量是否超过阈值 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) { //当前的键值对数量大于阈值，且该键值对应放入的索引位置的链表不为空（即发生了 hash 碰撞），则进行扩容操作，扩容2倍 resize(2 * table.length);//⑤ //重新计算 hash 值 hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0; //重新计算在扩容后的 table 中的索引 bucketIndex = indexFor(hash, table.length); } //创建新的节点 createEntry(hash, key, value, bucketIndex);//⑥} ⑤ 下面看 resize(int newCapacity) 扩容的方法 12345678910111213141516171819void resize(int newCapacity) { //创建一个局部变量存放原来的 table 的引用 HashMapEntry[] oldTable = table; //算出旧 table 的长度，即旧 table 的容量 int oldCapacity = oldTable.length; //如果之前的容量已经达到最大了，修改阈值为最大值并返回 if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } //容量还没达到最大，新建一个 table (链表数组)，长度为新的容量(newCapacity) HashMapEntry[] newTable = new HashMapEntry[newCapacity]; //转移新的键值对，将原来的键值对转移到新的 table 中 transfer(newTable);//⑦ //将新的 table(newTable) 的引用赋值给 table table = newTable; //计算新的阈值，即（新的容量 * 负载因子）或者是（最大容量 + 1）的最小值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);} ⑦ transfer() 转移到新 table 的方法 注意，这个方法在转移键值对到新的table中时，会将链表的顺序给倒序了，插入时插到链表的最前面即原来链表是 [A] -&gt; [B] -&gt; [C]，转移到新的链表后变成 [C] -&gt; [B] -&gt; [A] {假设扩容后这三个键值对的 hash 索引还相同} 12345678910111213141516171819void transfer(HashMapEntry[] newTable) { //计算新的 table 的容量 int newCapacity = newTable.length; //对旧的 table 数组进行循环 for (HashMapEntry&lt;K,V&gt; e : table) { //下面对链表进行循环 while(null != e) { HashMapEntry&lt;K,V&gt; next = e.next; //计算当前节点在新 table 中的索引值 int i = indexFor(e.hash, newCapacity); //取新的 table 中第i个位置的链表中第一个键值对，赋值给 e.next e.next = newTable[i];//① //将当前的 键值对 放入新 table 的第一个位置 newTable[i] = e;//② //将原来的链表上的下一个节点赋值给 e e = next; } }} 图解 在 for 循环时，e 指向旧 table 数组中的某条链表 第一次循环时，e 指向该链表的第一个键值对，next 指向 e.next 即第二个键值对 PS.我们假设转移前后我们的这两个键值对的 hash 值计算出来的索引仍然相同 将新 table 数组第 i 个位置的链表接到 e 的后面，再把 e 放到 newTable[i] 的位置 将 next 赋值给 e ，继续循环，直到链表循环结束 ⑥ createEntry(int hash, K key, V value, int bucketIndex) 创建新的键值对 新插入的键值对会插入到链表最前面 123456789void createEntry(int hash, K key, V value, int bucketIndex) { //将该键值对对应的索引的位置的键值对table[bucketIndex] 的引用赋值给局部变量 e HashMapEntry&lt;K,V&gt; e = table[bucketIndex]; //新建一个键值对，即新放入的 hash，key，value，该键值对的 next 是原来的在这个索引位置的键值对 //可见插入键值对时会插入到链表的最前面 table[bucketIndex] = new HashMapEntry&lt;&gt;(hash, key, value, e);⑦ //对 size 自增，即键值对数量 + 1 size++;} ⑦ HashMapEntry 构造方法，可见传入的第四个参数 n 会被放到这个新的 entry 的 next ，即放到第四个参数在链表位置上的前面。 123456HashMapEntry(int h, K k, V v, HashMapEntry&lt;K,V&gt; n) { value = v; next = n; key = k; hash = h; } remove 方法从 HashMap 中通过 key 移除某个键值对，当这个键值对存在时，返回该 key 对应的 value，若不存在，则返回 null 1234public V remove(Object key) { Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.getValue());} 往下看 removeEntryForKey(key) 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344final Entry&lt;K,V&gt; removeEntryForKey(Object key) { if (size == 0) { //若该 HashMap 的长度为 0 ，说明没有键值对，直接返回 null return null; } //获取该 key 对应的 hash 值 int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); //获取该 hash 值所对应的索引 int i = indexFor(hash, table.length); //获取该索引处的链表 HashMapEntry&lt;K,V&gt; prev = table[i]; //将该链表赋值给 e HashMapEntry&lt;K,V&gt; e = prev; //对链表进行循环，当链表上的节点 e 不为 null 时 while (e != null) { 将链表的下一个节点赋值给 next HashMapEntry&lt;K,V&gt; next = e.next; Object k; //当该节点的 hash 值和所要删除的 key 的 hash 值相同，并且 key 值相同，或者 key 不为 null，则找到了所要删除的键值对 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { //自增修改次数 modCount++; //将 HashMap 键值对数量减一 size--; if (prev == e) //如果 prev == e ，即刚好链表中的第一个节点就是所要查找的节点，则直接将链表的 next 指向第二个节点，就把该节点删除了 table[i] = next; else //否则将 e 节点的下一个节点赋值给，prev 的下个节点，即将 prev 的 next 指向 e.next prev.next = next; e.recordRemoval(this); //返回删除的节点 e return e; } prev = e; e = next; } //返回 e ，这里已经循环链表完毕，e 为 null return e;} 当第一个节点就是所要查询的节点时候 此时 prev == e，则直接将 e.next(即 next)直接赋值给 table[i]，则把 node a 直接删除了 从链表中不能查到该节点 prev 和 e 是链表对象，每次循环后 e 会先往链表下走，直到查找到满足条件的节点，如果都不满足，则 e == null 此时会退出循环，并返回 e ，即返回 null。 从链表中能查到该节点 若找到了满足条件的节点 node b(即 e)，则将 prev.next = e.next ，等效于将 node b 从链表中删除了 Java 8 中的 put 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果当前 table 为 null 或者数组长度为 0 if ((tab = table) == null || (n = tab.length) == 0) //扩容，并将扩容后的数组赋值给 tab ，n 则为当前数组的长度 n = (tab = resize()).length; //下面的 `(n - 1) &amp; hash]` 就是 Java 7 中计算索引的方法 //如果计算出的索引处要插入的地方为 null ，则直接新增一个 Node 键值对 //此时将 tab[index] 赋值给了 p ，即 p = tab[index] if ((p = tab[i = (n - 1) &amp; hash]) == null) //如果走到这里，可以说明该键值对的 key 在原先的 HashMap 中是不存在的 tab[i] = newNode(hash, key, value, null); else { //要插入的索引处已经有 Node 了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //假如该索引处的 Node p 的 hash 值和新放入的键值对的hash相同，并且key值也相同 //将 p 赋值给 e e = p; else if (p instanceof TreeNode) //key 不相同的话，并且 p 是红黑树的一个节点，则直接插入红黑树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { //key 不相同，并且不为红黑树，即链表 for (int binCount = 0; ; ++binCount) { //进行循环 //如果 p 的下个节点为空(即 p 是最后一个节点) if ((e = p.next) == null) { //将该需要插入的节点插到链表尾部 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //如果链表长度超过 8 ，则转为红黑树 treeifyBin(tab, hash); //跳出循环 break; } //如果 p 的下个节点 e 不为空，且 e 的 hash 值等于插入的节点的 hash 并且 key 相同，即 e 就等于需要插入的节点，则直接跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //将链表的下个节点 `e` 在循环中赋值给 `p` p = e; } } if (e != null) { // existing mapping for key //如果 e 不为空，即原来的 table 中存在相同的 key ，e 为旧的 node V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //替换掉旧值 e.value = value; afterNodeAccess(e); //返回 key 对应的旧值 return oldValue; } } //如果 HashMap 中不存在该 key，会走到这里 //mod 次数自增 ++modCount; //如果键值对数量大于阈值，则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;} 总结下思路 在插入时，计算出 key 值对应的 hash 值，接着计算 hash 值对应的索引 判断该索引处是否为空 2.1 如果为空，则直接插入该键值对2.2 如果不为空，说明该索引处已经存在『链表』或者『红黑树』了2.2.1 如果『链表』的第一个节点或者『红黑树』的根节点的 key 值等于要插入的 key 并且 hash 值相同，则进行替换2.2.2 否则，如果是『红黑树』，则进行插入2.2.3 否则，如果是『链表』，则进行循环链表插入（如果链表长度超过 8，则转换为红黑树）2.2.4 经过 2.2.1 - 2.2.3 之后，如果原来中有相同的 key ，则直接 return 旧值2.3 原 HashMap 中没有插入的 key，则键值对数量自增，判断扩容，return null Java 8 中的 resize() 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() { //获取旧的数组引用 Node&lt;K,V&gt;[] oldTab = table; //计算旧数据的长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取旧阈值 int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { //如果旧数组长度大于等于最大容量，则直接返回旧数组 threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //新数据容量 = 旧数据容量左移一位，即 * 2 //如果新数组容量小于最大值，且旧数组容量大于等于默认长度（16） //同时将阈值扩大一倍 newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold // 如果原来的 threshold 大于0则将容量设为原来的 threshold // 在第一次带参数初始化时候会有这种情况 newCap = oldThr; } else { // 在默认无参数初始化会有这种情况 newCap = DEFAULT_INITIAL_CAPACITY;//16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//16 * 0.75 = 12 } if (newThr == 0) { //如果新的阈值为 0 //计算新的阈值 float ft = (float)newCap * loadFactor; //如果新的容量小于最大容量且新的阈值也小于最大容量 //则新的阈值等于 ft ，否则设置为 Integer.MAX_VALUE newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } //将新的阈值赋值给 threshold threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) //创建新的数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //将新数组赋值给 table table = newTab; //进行扩容复制 if (oldTab != null) { //旧数组不为 null ，进行循环 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; // 将当前索引处的第一个节点赋值给 e if ((e = oldTab[j]) != null) { //将旧数组的引用置为 null oldTab[j] = null; if (e.next == null) //如果当前索引处只有一个节点，则直接计算在新数组中的索引并赋值 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //如果 e 是红黑树，则调用红黑树的方法进行处理 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order //处理链表长度为 1 ~ 8 的情况 Node&lt;K,V&gt; loHead = null, loTail = null;//低位的链表头节点，低位的链表尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null;//高位的链表头节点，高位的链表尾节点 Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { //！！这里 e.hash &amp; oldCap 不是计算索引，计算索引应该是 e.hash &amp; (oldCap -1) //如果节点 e 的 hash 值和 oldCap 计算出来值为 0 ，说明在扩容后该节点的索引相同，不需要移动索引 if (loTail == null) //第一次才会走入这个地方 //如果低位尾部节点为 null，将 e 赋值给头部节点，即链表第一个节点 loHead = e; else //否则(即第二次以后)，将 e 赋值给尾部节点的 next，即 loTail.next loTail.next = e; //再将 e 赋值给尾部节点 loTail， loTail = e; } else { //否则，该节点需要移动索引位置到新的索引去 //方法同上 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null);// 将 next 赋值给 e，直到没有 next ，即链表循环完毕 if (loTail != null) { //如果低位的尾节点不为 null ，则将其 next 置为 null loTail.next = null; //并将低位的头节点放到该低位索引处 newTab[j] = loHead; } if (hiTail != null) { //如果高位的尾节点不为 null ，则将其 next 置为 null hiTail.next = null; //并将高位的头节点放到该高位索引处 newTab[j + oldCap] = hiHead; } } } } } return newTab;} 这里重点看一下处理链表长度为 1~ 8 的情况 首先我们知道，对于一个键值对节点，其索引的计算方式为 index = hash(key) &amp; (n - 1) 假设现在有两个节点 Node A 和 Node B ,其 key 的 hash 值分别为 hash(a)、hash(b)，n = 16 计算其索引过程如下 n - 1 0000 0000 0000 0000 0000 0000 0000 1111hash(a) 1111 1111 1111 1111 0000 1111 0000 0101hash(b) 1111 1111 1111 1111 0000 1111 0001 0101 计算索引 index = hash(key) &amp; (n - 1) index(a) 0000 0000 0000 0000 0000 0000 0000 0101 == 5index(b) 0000 0000 0000 0000 0000 0000 0000 0101 == 5 则 Node A 和 Node B 计算出来的索引相同，则放在同一个链表中，当进行扩容时，数组的长度会变为原来长度的两倍即 n = n * 2;扩容后要重新计算索引 n - 1 0000 0000 0000 0000 0000 0000 0001 1111hash(a) 1111 1111 1111 1111 0000 1111 0000 0101hash(b) 1111 1111 1111 1111 0000 1111 0001 0101计算索引 index = hash(key) &amp; (n - 1) index(a) 0000 0000 0000 0000 0000 0000 0000 0101 = 5index(b) 0000 0000 0000 0000 0000 0000 0001 0101 = 21 = 5 + 16 由此可见，当同一个链表中的节点在进行重新索引时，并不需要重新通过 index = hash(key) &amp; (n - 1) 方法计算索引，同一个链表中的节点在扩容后要么还在当前索引index处，要么在 index + oldCap处。 所以当扩容时重新计算索引，可以不需要重新计算 hash 值，节省了计算 hash 的时间，并且只需要看原来的 hash 值新增的那个高位的值是 1 还是 0 即可⑨，如果是 1 ，则新的索引为 index = index + olcCap，否则 index 不变 ⑨计算方法 e.hash &amp; oldCap 判断是否为 0 更简单来说， 第一次: e -&gt; A,next -&gt; B,loHead -&gt; e(A) ,loTail -&gt; e(A)e -&gt; next(B) 第二次: e -&gt; B,next -&gt; C,loTail -&gt; AloTail.next -&gt; e(B)此时 loHead 和 loTail 指向同一个内存地址，所以 loHead.next = e(B)loTail -&gt; e(B),e -&gt; next(C) 第三次: e -&gt; C,next -&gt; null,loTail -&gt; BloTail.next -&gt; e(C)则此时 B.next 指向了 C ,而 loHead.next 指向的也是 B ,即 loTail,所以此时 loHead.next.next -&gt; CloTail -&gt; e(C),e -&gt; next(null) 结束循环loHead = A -&gt; B -&gt; C 通过上面的分析也可以看出，Java 8 在扩容过程中，链表的顺序是不变的，链表在扩容后还保持原来的顺序，而 Java 7 是倒序的","link":"/2018/06/07/hashmap/"},{"title":"Java 并发编程之 AQS","text":"AQS，全称为 AbstractQueuedSynchronizer，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制其中封装了 FIFO(first in first out) 的队列 AQS 的「范式」继承 AQS 的实现 Sync 类都需要遵守一定的「范式」一般来说，一个锁的实现，要么是独占式的，要么是共享式的，AQS 中需要开发者 override 以下的方法，但对于某一种锁实现(独占式/共享式)来说，只需要 override 其中的一对即可 方法 作用 boolean tryAcquire(int arg) 独占式尝试获取锁状态，返回值表示是否获取到锁 boolean tryRelease(int arg) 独占式尝试释放锁状态，返回值表示锁状态是否完全被释放而非是否释放成功，因为在可重入锁的情况下，释放后当前线程可能还持有者该所状态 int tryAcquireShare(int arg) 共享式尝试获取锁状态 boolean tryReleaseShare(int arg) 共享式尝试释放锁状态 boolean isHeldExclusively() 是否独占式的，一般返回 true 表示当前的锁状态被当前线程持有 关于独占式和共享式独占式和共享式的区别在于，在同一个时刻是否能有多个线程获取所状态顾名思义，独占式就是锁状态只能被一个线程获取到，而共享式可以被多个线程获取锁(例如读锁，可以多个线程同时读) 对于一个锁框架来说，需要做到 对锁状态的维护 对锁竞争时候，无法竞争到锁的线程的处理 而在 AQS 中，以上的两个问题是这样解决的 AQS 提供一个 volatile int state 变量，用来标识锁的状态，并且提供了以下三个方法进行读和取 方法 作用 final int getState() 获取 state 的值 final void setState(int newState) 设置 state 的值 final boolean compareAndSetState(int expect, int update) 原子地修改 state 的值，返回值表示是否修改成功 而对于第二个问题，AQS 提供了一个 FIFO 的队列对无法获取到锁的线程进行入队等待的处理 在 AQS 中维护了一个 head 和 tail 两个字段，其类型为 AQS 的内部类 Node，Node 的数据结构如下表格，可见通过 head 和 tail 则构成了一个双向的链表 其结构大概表现为： 字段 作用 int waitStatus 表示当前 Node 的等待状态，具体见下面的表格 Node prev 表示当前 Node 的前置节点 Node next 表示当前 Node 的后置节点 Thread thread 表示将这个 node 加入队列中的线程，在构造函数中赋值，并在Node使用完毕后会置为 null Node nextWaiter 指向下一个在 condition 上等待的 Node，或者共享式的 Node waitStatus: 枚举 值 含义 CANCELLED 1 表示线程获取锁的请求已经被取消 SIGNAL -1 表示线程在等待锁资源，也表示其后续的节点的线程在等待唤醒 CONDITION -2 表示线程正在等待 condition PROPAGATE -3 表示下一个 acquireShared 应该无条件传播 独占式机制在独占锁机制中，waitStatus 只会使用到 CANCELLED 和 SIGNAL 两个状态 lock.tryLock() 会调用 sync.tryAcquire(int arg) 方法，tryAcquire() 方法会通过 cas 的方式设置 state 的值，如果设置成功则返回 true，否则说明无法获取同步状态，则返回 false lock.lock() 方法，调用 sync.acquire(int arg) 方法 tryAcquire() 方法：尝试获取锁(修改标志位)，无论成功与否立即返回acquire() 方法：获取锁(修改标志位)，获取成功则返回，失败则进入队列等待，直到获取到锁 acquire123456public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();} 可见 acquire() 方法也会调用 tryAcquire() 方法先尝试获取同步状态，如果能获取到(即 tryAcquire() 返回 true)，则不会走后续的 acquireQueued() 以及 selfInterrupt() 方法 如果无法获取同步状态(即 tryAcquire() 返回 false)，调用 addWaiter() 方法以及 acquireQueued() 方法 addWaiter接着看 addWaiter() 方法，顾名思义，添加一个等待节点，将新建的 Node 加入链表的队尾，并返回该节点 12345678910111213141516171819202122private Node addWaiter(Node mode) { //先构造一个 Node 对象，包含当前线程对象，以及 mode (即传入的 Node.EXCLUSIVE 独占式) Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure //将 pred 指向 tail 节点 Node pred = tail; if (pred != null) { //如果 pred 不为空，即队尾有节点 //设置 node 的前置节点为 pred(即 tail) node.prev = pred; //通过 cas 将 node 设置为链表队尾 if (compareAndSetTail(pred, node)) { //设置成功后，将 tail 的后置节点设置为 node，并返回 pred.next = node; return node; } } //走到这里说明 tail 为 null，即链表为空 //或者通过 cas 设置链表队尾失败，说明有多个线程在竞争设置队尾 enq(node); return node;} 接着看 enq() 方法 将 node 插入到链表的队尾，并返回 node 的前序节点 在 AQS 中，FIFO 队列中的 head 是个哨兵节点，当一个入队的线程获取到锁之后，会将自己对应的节点设置为头节点 head，并将 head 中的 prev 和 thead 都置空，独占式见 acquireQueued -&gt; setHead，共享式见 doAcquireShared-&gt;setHeadAndPropagate 123456789101112131415161718private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // Must initialize // t == null 说明还未初始化，则先创建一个哨兵节点并设置为 head，接着将 tail 指向哨兵节点 //即 head -&gt; new Node() 0= &lt;- tail if (compareAndSetHead(new Node())) tail = head; } else { //将 node 插入到 tail 后，并组成双向链表后返回 node 的前序节点(即旧的 tail) node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } }} 再回到 acquire() 方法中 if 中的 acquireQueued() 方法 acquireQueuedacquireQueued 方法会建立一个死循环，不断地从队列中获取独占式的线程进行处理，方法的返回值代表是否需要中断该线程 12345678910111213141516171819202122232425262728293031323334final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { //死循环 //获取 node 的前序节点 p final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { //如果 p 是头节点且成功获取锁状态 //将 node 设置为头节点并将原来的头节点 p 从链表中删除 setHead(node); p.next = null; // help GC failed = false; //返回 interrupted //这个死循环只有在这才会返回退出 //即只有当 node 的前续节点是头节点时 //并且当前线程尝试获取锁成功了才会退出循环 return interrupted; } //走到这里说明 p 不是头节点，或者是头节点但是尝试获取同步状态失败(tryAcquire 返回 false) //这里会将获取不到锁的线程进行挂起，避免循环自旋造成 CPU 性能的无谓消耗 //shouldParkAfterFailedAcquire 返回的是该线程是否需要挂起 //parkAndCheckInterrupt 方法会将线程挂起，并且返回是否在挂起期间线程被中断了 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) // cancelAcquire(node); }} shouldParkAfterFailedAcquirenode: 当前线程对应的节点pred: 当前线程对应的节点 node 的前序节点 当一个线程尝试获取锁失败后，会调用这个方法判断是否需要挂起，方法返回值表示是否需要挂起该线程 这里讲一下 Node 中 waitStatus 这个字段的 SIGNAL 这个状态SIGNAL 字段表示下一个节点处于挂起或者快要进行挂起的操作了，但这个状态不是节点给自己设置的，而是由后序节点修改的 在 AQS 中，当一个节点入队，说明自己需要等待锁，则会修改前序节点的 waitStatus 为 SIGNAL，代表「喂，我在你后面排队，等你处理好事情了叫醒我，我先睡会(挂起)」 1234567891011121314151617181920212223242526272829303132333435private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { //获取 pred 节点的 waitStatus int ws = pred.waitStatus; if (ws == Node.SIGNAL) //如果前序节点的 waitStatus 已经为 Signal，返回 true /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) { //如果前序节点的 waitStauts &gt; 0 （即 CANCELLED） //则往前遍历找到非 CANCELLED 状态的节点，并删除 CANCELLED 状态的节点 //最后 return false /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus &gt; 0); pred.next = node; } else { //走到这里说明前序节点的 waitStatus 为 0 或者 PROPAGATE(-3) //则将前置节点的 waitStatus 设置为 SIGNAL //最后 return false /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false;} parkAndCheckInterrupt这个方法中通过 LockSupport.park() 方法将当前线程挂起，并阻塞在该行代码处，直到被唤醒响应通过这个方法挂起的线程在被中断后，不会抛出 InterruptException 的异常 1234private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted();} 总结一下: 调用 acquire() 方法的线程首先会先尝试获取锁状态，如果获取成功，则执行后续代码，不表主要是在多个线程竞争同一个锁时，存在竞争状态的情况下 调用 tryAcquire() 返回 false，即该线程获取锁状态不成功，则会在双向链表最后面插入一个 node 节点(持有该线程对象)并通过 acquireQueued() 方法开启一个死循环 如果 node 节点的前序节点为 head 节点说明这个 node 节点已经排队排到最前面了，可以尝试获取锁状态，获取成功后则将该 node 节点置为 head，并跳出循环(跳出循环说明该线程已经获取到锁，可以执行其需要执行的代码)如果获取锁状态失败，则进入下一步判断该线程是否需要挂起 实际上在这个双向链表中，head 节点只是充当一个哨兵的作用，并没有其他作用 如果 node 节点的前序节点不为 head 节点，则判断该线程是否能够挂起 如果当前节点的前置节点的 waitStatus 为 Signal，说明前面的节点也在等待中，那自己理所应当的就该挂起阻塞等待了 如果当前节点的前置节点的 waitStatus 为 Canceled，则往前遍历并修改链表，跳过并删除 canceled 的节点 否则，将当前节点的前置节点的 waitStatus 置为 Signal 在 shouldParkAfterFailedAcquire() 方法中，除非 pred.waitStatus == Signal 则直接返回 true，会将当前线程挂起，否则会继续循环，「将 canceled 的节点删除」或者「将前序节点的 waitStatus 置为 Signal」，当完成「将前序节点的 waitStatus 置为 Signal」这一步(即compareAndSetWaitStatus(pred, ws, Node.SIGNAL)) 后，下次循环如果 就会走到 pred.waitStatus == Signal 的 case 中返回 true，后续的 parkAndCheckInterrupt() 方法会将该线程挂起 如果一个节点是头节点的下一个节点，且头节点的线程还在占用着锁状态，则会不停地自旋去调用 tryAcquire() 方法尝试获取锁 中断机制从前文我们知道，acquireQueued() 的返回值代表是否要中断线程，如果返回 true ，则会走到 if 的 case 中调用 selfInterrupt() 方法中断当前线程而在 acquireQueued() 方法中，只有在 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt() 方法都返回 true 的情况下，才会将 interrupted 的值置为 true，并在循环结束的时候返回 回看一下 parkAndCheckInterrupt() 方法，这个方法中回调用 LockSupport.park(this) 将线程挂起，由于这个方法将线程挂起时，不同于 thread.wait() 和 Thread.sleep() ，通过 LockSupport.park() 方法将线程挂起期间，不会抛出中断异常，所以在被唤醒后，需要通过 Thread.interrupted() 方法的返回值来决定是否需要中断当前线程 Thread.interrupted() 返回的是线程是否被中断过，并清除中断状态 如果线程在等待过程中被中断过(thread.interrupt()) 则 Thread.interrupted() 会返回 true ，将 acquireQueued() 方法中的 interrupted 的值修改为 true ，直到循环退出，调用 selfInterrupt() 方法将线程中断 解锁过程release12345678910111213public final boolean release(int arg) { //先尝试释放锁状态，由实现类自定义 if (tryRelease(arg)) { //释放锁状态成功 Node h = head; //头节点不为空且其 waitStatus 不为初始状态 if (h != null &amp;&amp; h.waitStatus != 0) //唤醒后序节点 unparkSuccessor(h); return true; } return false;} unparkSuccessorunparkSuccessor() 方法是为了唤醒 node 节点的后序节点对应的线程 12345678910111213141516171819202122232425262728293031private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) //将头节点的 waitStatus 值置为 0 compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) { //如果头节点的后序节点为空，或者其 waitStatus 为 Canceled 状态，则将其删除 s = null; //从链表的尾巴向前查找，找到链表中第一个 waitStatus &lt; 0 的节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) //找到了链表中最靠前的 waitStatus &lt; 0 的节点，将其唤醒 LockSupport.unpark(s.thread); //唤醒后则会回到 parkAndCheckInterrupt 方法中被挂起阻塞的地方，继续执行后续的代码尝试获取锁状态等} 共享式机制在 AQS 中，共享式的方法都以 Shared 结尾，同样的，我们先来看 acquireShared() 方法 acquireSharedacquireShare 方法在共享模式中获取锁，会忽略掉中断，会先调用一次 tryAcquireShared 方法获取锁，成功后返回，否则，线程会进行入队等待 1234public final void acquireShared(int arg) { if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);} tryacquireSharedtryacquireShared 方法中直接抛出了异常，说明这是需要共享式锁的实现类自行实现的方法返回值为 int 值，返回值是重点所在 123protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException();} 返回值 意义 &lt;0 表示尝试获取共享锁状态失败 0 表示获取共享锁状态成功，但不需要唤醒后序的处于等待共享锁的节点 &gt;0 表示尝试获取共享锁状态成功，如果后序节点处于等待中，则需要将其唤醒 doAcquireShared从上文知道，当尝试获取共享锁失败后，会调用 doAcquireShared 方法这段代码和上文的独占式锁的机制很类似，也是将节点入队后，通过循环不断的获取队列中的线程进行处理这里我们只看下不同的地方，即 setHeadAndPropagate 方法 12345678910111213141516171819202122232425262728293031private void doAcquireShared(int arg) { //新建一个 node 节点，并将其加入等待队列的队尾 //注意这里的 node 为 Node.SHARED //所以创建的 node 对象中的 nextWaiter == Node.SHARED final Node node = addWaiter(Node.SHARED); boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); if (p == head) { int r = tryAcquireShared(arg); if (r &gt;= 0) { //r &gt;= 0 说明获取共享锁成功 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); }} setHeadAndPropagatesetHeadAndPropagate 方法用来将 node 设置为头结点，并根据 propagate 的值等条件判断是否进行传播回顾一下独享锁，独享式锁是在 release() 方法中通过 unparkSuccessor() 唤醒后序节点起来获取锁后执行代码而在共享式锁中，锁状态可以被多个线程所持有，所以当某个线程获取锁后，可以告知队列中的线程可以起来获取锁而不需要等到当前线程释放锁的时候再进行获取锁 当然也取决于 propagate 的值propagate 即 tryAcquireShare() 方法的返回值 从代码中可见，当满足第一个 if 中的条件后，会获取 node.next(即头结点的后一个节点)，如果其为空，即等待队列中没有等待的节点了，或者其为共享式的节点，则会调用 doReleaseShared() 方法 1234567891011121314151617181920212223242526272829303132private void setHeadAndPropagate(Node node, int propagate) { //先记录一下当前的 head 的引用 Node h = head; // Record old head for check below //更新 node 为新的 head setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ //propagate &gt; 0 表示调用者告知信号量需要往后传播 //h == null || h.waitStauts &lt; 0 说明旧的 head 为空或者为 Canceled 状态 //h = head == null || h.waitStauts &lt; 0 说明新的的 head 为空或者为 Canceled 状态 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) { Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); }} 共享锁的释放在看 doReleaseShared 方法前，先来看一下 tryReleaseShared 和 releaseShared 方法，有助于理解后面的 doReleaseShared 方法 tryReleaseSharedtryReleaseShared 方法需要子类自行实现但规范了返回值代表「这次共享锁的释放是否需要唤醒后续等待的节点」，如果需要唤醒后续的节点则返回 true，否则返回 false 123protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException();} releaseSharedreleaseShared 方法先调用 tryReleaseShared 方法尝试释放了锁，如果返回值为 true，则 调用 doReleaseShared 方法 1234567public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false;} doReleaseShared顾名思义，做释放共享锁的事情这里需要明白一个事情，就是 doReleaseShared 方法可能在同一时间有多个线程在访问因为是共享锁，所以可能有的线程正在释放锁，有的线程刚获得锁成为头节点，需要唤醒后续节点 12345678910111213141516171819202122232425262728293031323334353637private void doReleaseShared() { /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) { Node h = head; //&lt;1&gt; //判断 h 不为空(即头节点 head) 且 h!=tail(即链表至少有两个节点，才需要唤醒下一个节点) if (h != null &amp;&amp; h != tail) { int ws = h.waitStatus; //判断 h 的 waitStatus 是否为 SIGNAL if (ws == Node.SIGNAL) { //h 的 waitStaus 为 SIGNAL 则通过 cas 设置为 0，如果设置失败则进入下一个循环 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases //如果 cas 修改 h 的 waitStatus 成功，则唤醒 h 的后序节点 unparkSuccessor(h); } else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) //如果 ws 为 0，说明 head 是刚刚成为了头结点，因为如果有后序节点进入 continue; // loop on failed CAS } //&lt;/1&gt; if (h == head) // loop if head changed //只有满足 h == head 这个条件时才会退出循环 break; }} 这段代码有点难以理解 关于如何退出循环 if (h == head) 的判断 先来解释一下 if(h == head) 的这个判断，在 doReleaseShared 方法的死循环中，只有满足了这个条件才会退出循环，也就是说在 1—的这段代码执行期间，head 的引用没有发生改变，即没有新的节点成为头结点，则当前线程退出此死循环。那什么情况下 head 会发生变化呢，答案自然是有其他的节点(可能是新加入来的节点)获取到了锁，会将 head 修改掉举个例子，假设线程 A 调用了 doReleaseShared 方法， 此时 head == NodeA，在执行到 &lt;1&gt;&lt;/1&gt; 中的代码时，因为是共享锁，这时候另一个线程 B 尝试获取锁成功，将 head 修改为 NodeB，当线程 A 执行完 中间的代码后，发现 h != NodeA 了，则会继续进行循环，将此刻的头结点 head(即NodeB) 的后序节点唤醒。直到 h == head ，说明 head 在执行期间没有发生变化，说明已经完成了唤醒头节点后序节点的任务，那么就可以退出循环去做自己的事情了 也就是说这里如果有多个线程在同时执行的时候，多个线程都会帮助唤醒 head 节点的后序节点，这个思想就和 ConcurrentHashMap 中多个线程在 put 数据时，如果发现正在扩容，则会一起帮忙扩容，而不是傻傻的等待。妙啊 小结至此，差不多将 AQS 中的重点源码都过了一遍，其他的方法大多大同小异，稍微看一下即可理解，不再赘述，读者阅读时若发现纰漏，望来信斧正，感谢 致谢在学习 AQS 的过程中，从 B站寒食君、日拱一兵、ChiuCheng 中学到了很多知识，感谢 附上链接： 【Java并发】并发编程的意义是什么？月薪30K必知必会的Java AQS机制 Java AQS队列同步器以及ReentrantLock的应用 逐行分析AQS源码(3)——共享锁的获取与释放","link":"/2022/02/19/2022_02_19_Java_JUC_AQS/"},{"title":"Charles 使用","text":"本文简单介绍 Charles 的使用 Rewrite 功能 几乎可以用来修改 HTTP 请求中的所有数据例如 Request 中的 path、query param 等等 这样的好处是只需要篡改请求中的数据，而不需要修改代码，避免重新编译，可以节省时间，也不会污染代码，造成发版时忘记修改回来的问题。 具体操作如下，我们以 将请求中的 versionCode=46 修改为 1111111为例 点击 Tools - Rewrite 新增规则 在面板上分成了三个区域，如下 第一个区域为 配置区 ，用来管理各种配置 第二个区域为 匹配区 用来匹配 Location 第三个区域为 重写规则区 在这里新增各种重写规则 编辑 Location 这里一共有五个地方，分别是 Protocol 填写协议 Host 填写域名 Prot 填写端口 Path 填写路径 Query 填写查询的值 如果不填写将会匹配所有的值，这里可以填写 * 和 ? 通配符 修改 Request 填写 Rewrite 规则 首先选择 Type(类型) Modify Query Param 即修改 Query 参数 在 Match 中填写需要修改的参数的 name 以及对应的 value 在我们的例子中，就是 versionCode 及 46 3. 在 Replace 中填写相对应要修改的参数名和值 在我们的这个例子中，我们只需要将 versionCode 的值改成 1111111，所以只需要将 Replace 中的 Value 填写为 1111111 这样就可以将 HTTP 请求中的数据进行修改了，不需要修改代码和重新编译。节省了大量的时间 修改 Response同理，我们也可以修改 HTTP 请求中的 Response 中的数据，修改成我们调试所需要的信息 只需要在 Rewrite Rule 中的 Type 中选择所需要修改的类型，例如 Response Status、Modify Header、Body 等 并在 Where 中选择是修改 Request 还是 Response ，下面的规则同理。 Location Match 包含了可用于匹配请求URL的协议，主机，端口和路径字段。任何字段都可以留空，这种情况下会匹配上任何值。 通配符(Wildcards)通配符支持使用 * 、**?** 和 […] * 匹配0个或者多个字符，**?匹配一个字符，字符范围[…]** 匹配范围内的一个字符，例如 [a-z] 或者 [aeiou] 路径(Paths)要匹配子路径，必须使用/*结尾注意：在之前的 Charles 版本中这是隐含的，但现在是必须的 查询值(Query)查询字段和查询字符串内容相匹配，并不匹配以 ? 开头的字符，要注意到？是一个通配符查询字段和其他字段一样可以包含通配符，因此你可以像这样，在 Query 中任何地方使用 *page=1* 去匹配 page=1 常见用途要将每个请求和给定的 host 匹配，填入 host 并将其他字段留空 要将每个请求和给定的 host 以及路径匹配，填入 host 并把路径已 / 结尾，并把其他字段留空 要将每个文件和给定的 host 上的后缀(suffix)相匹配，则填入 host 和 /*.suffix，并将其他字段留空 Host Path Result charlesproxy.com 匹配所有到 charlesproxy.com 的请求 *.charlesproxy.com 匹配所有 host 以 .charlesproxy.com 结尾的请求 charlesproxy.com /charles/ 只会匹配所有到 charlesproxy.com/charles/ 的请求 charlesproxy.com /charles/* 匹配所有到 charlesproxy.com/charles/ 的请求，包括文件和子路径 charlesproxy.com /charles 只会匹配所有到 charlesproxy.com/charles 的请求 charlesproxy.com /index.html 只会匹配所有到 charlesproxy.com/charles.html 的请求 charlesproxy.com /*.html 匹配所有到 charlesproxy.com 并且以 .html 结尾的所有请求 /charles/*.html 匹配任何 host 的所有在路径(包括子路径) /charles/ 中以 .html 结尾的所有请求 可以将协议和端口匹配添加到上面以进一步缩小位置匹配。","link":"/2019/03/13/how_to_used_charles/"},{"title":"Android View 的测量","text":"Android 中 view 的测量机制 MeasureSpec MeasureSpec 使用一个 32位的 int 数值用来存放 mode 和 size 前2位存放 mode ，后30位存放 size 其中，mode 的类型一共有三种，分别是 mode 值 解释 UNSPECIFIED 0 &lt;&lt; 30(即00,000..[一共30个0]..000) 未指定模式，不对子 view 的尺寸进行限制 EXACTLY 1 &lt;&lt; 30(即01,000..[一共30个0]..000) 精确模式，子 view 的尺寸为具体的数值(xxdp)或者父 view 的大小(match_parent) AT_MOST 2 &lt;&lt; 30(即10,000..[一共30个0]..000) 最大模式，子 view 的尺寸可以在指定范围内要多大就多大(wrap_content) UNSPECIFIED 和 AT_MOST 的区别在于 UNSPECIFIED 不限制 子 view 的大小 同时，MeasureSpec 提供了两个方法，用来获取 mode 和 size PS. private static final int MODE_MASK = 0x3 &lt;&lt; 30;即11,000..[一共30个0]..000 获取 mode android.view.View.MeasureSpec#getMode 通过「&amp;」方法保留前两位数，将后30位变为0 12345@MeasureSpecModepublic static int getMode(int measureSpec) { //noinspection ResourceType return (measureSpec &amp; MODE_MASK);} 获取 size 先将 MODE_MASK 按位取反，得到00,111…[一共30个1]…111再通过「&amp;」方法保留后30位数，将前两位变为0，则获得 sizeandroid.view.View.MeasureSpec#getSize 123public static int getSize(int measureSpec) { return (measureSpec &amp; ~MODE_MASK);} View 的测量onMeasure先来看 android.view.View#onMeasure 方法 通过 getDefaultSize 方法获取 view 默认的宽/高后进行设置 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));} getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 方法是获取该 view 的最小宽度/高度 12345678/** * 如果没有背景，则返回设置的最小宽度(minWidth) * 否则返回背景最小宽度和设置的最小宽度(minWidth)的大者 */protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());} 接着看 getDefaultSize 方法 1234567891011121314151617181920212223/** * @param size view 的默认大小 * @param measureSpec 父 view 对子 view 的约束 * @return 返回大小 */public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { //父 view 对子 view 不做限制，则使用默认的大小 case MeasureSpec.UNSPECIFIED: result = size; break; //父 view 对子 view 限制，则使用特定的大小 case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result;} 那么问题来了，调用子 view 的 onMeasure() 方法里的参数是怎么来的呢，我们回到 ViewGroup.measureChild() 方法 在这个方法中，会调用子 view 的 measure 方法，在 measure 方法中会调用 onMeasure 方法去测量自己的宽/高，也就是上面讲过的 android.view.View#onMeasure 方法 代码如下： 12345678910111213141516/** * @param child 子 view * @param parentWidthMeasureSpec 父 view 宽的 MeasureSpec * @param parentHeightMeasureSpec 父 view 高的 MeasureSpec */protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);} 可见，在这个方法中，根据parentWidthMeasureSpec、padding 以及子 view 的 LayoutParams 的设置，通过 getChildMeasureSpec() 该方法确定了子 view的 MeasureSpec，后再调用 child.measure 方法对子 view 进行测量 下来重点看一下 getChildMeasureSpec() 这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * @param spec 父 view 的 MeasureSpec * @param padding 父 view 设置的 padding * @param childDimension 该 view 希望设置的大小(即 LayoutParam 的 width/height or xml 中设置的 layout_width/layout_height) * @return 返回该 view 的 MeasureSpec */public static int getChildMeasureSpec(int spec, int padding, int childDimension) { //获取父 view 的 mode int specMode = MeasureSpec.getMode(spec); //获取父 view 的 size int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us //父 view 的大小是固定的 case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { //如果子 view 设置了大小，则使用子 view 自己设置的大小和，mode 为 EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //子 view 设置为 MATCH_PARENT，则使用父 view 的大小，mode 为 EXACTLY resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //子 view 要决定自己的大小(设置为 WRAP_CONTENT)，不能超过父 view，则使用父 view 的大小，mode 为 AT_MOST(最大不能超过 size) // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us //父 view 没有固定大小，但有上限 case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it //如果子 view 设置了大小，则使用子 view 自己设置的大小，mode 为 EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //子view 要求跟父 view 一样大，但父 view 是不固定的 //只能约束子 view 不超过父 view，则使用父 view 的大小，mode 为 AT_MOST(最大不能超过 size) // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //子 view 要决定自己的大小(设置为 WRAP_CONTENT)，不能超过父 view，则使用父 view 的大小，mode 为 AT_MOST(最大不能超过 size) // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be //父 view 没有限制，可以为任何大小 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { //如果子 view 设置了大小，则使用子 view 自己设置的大小，mode 为 EXACTLY // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { //子view 要求跟父 view 一样大，则继续看看子 view应该多大 //在 Api 23 以下设置 size 为 0，Api 23以上为父 view 的 size //mode 设置为 UNSPECIFIED resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { //子 view 要决定自己的大小(设置为 WRAP_CONTENT)， //在 Api 23 以下设置 size 为 0，Api 23以上为父 view 的 size //mode 设置为 UNSPECIFIED resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType //最后将 size 和 mode 组装并返回 return MeasureSpec.makeMeasureSpec(resultSize, resultMode);} 该方法是通过父 view对子 view的限制来进行计算子 view应有的 size 和 mode 也可以通过另一种角度来确定子 view的 size 和 mode 123456789101112131415161718192021222324252627282930313233343536public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec), specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0, resultMode = 0; if (childDimension &gt;= 0) { // 子元素指定了具体的大小，就用子元素的大小，mode 使用 EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { // 子元素希望和父控件一样大，需要设置其上限，然后测量模式与父控件一致即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = specMode; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23以下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { // 子元素希望自己决定大小，设置其大小的上限是父控件的大小即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23以下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}作者：HelloDev链接：https://juejin.cn/post/6844903694073331720来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2021/01/01/measure_view/"},{"title":"使用 tools 命名空间实现 View 的预览","text":"使用 tools 命名空间实现 View 的预览 官方文档 在开发过程中，有时候需要对 View 进行预览，以前需要把 application run 到手机或者是模拟器上后才能看到效果，现在，我们有了更加方便快捷的方法。 对于一个 \bRecyclerView 来说，一般来说，我们会在 xml 文件中写下面这样的代码 1234&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 这时候会在Android Studio 右边的预览窗口中看到这样的画面 这时候我们会在想，能不能把我们的 item 的布局文件也给展示出来呢，这样就可以预览效果了。 当然可以，我们可以借助 tools 命名空间来实现这个想法。要使用 tools 的\b一些 xml 属性，我们需要在 xml 文件的根布局中添加 tools 的命名空间，如下 12&lt;RootTag xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; &gt; 这个时候我们就可以开始使用一些属性了。 我们给 RecyclerView 添加 tools:listitem=&quot;@layout/xxxx&quot; 的话，我们就可以预览到每个 Item 在 RecyclerView 中的样子了。如下图所示 但这时候你会发现，我们每一个 item 都是一模一样的，没法预览和模拟真实的情景呀。不用怕，Android Studio 3.0 给我们提供了这么一个功能。 |“@tools:sample/*” resources 我们可以在每个 Item 中使用这些提供给我们使用的资源文件，这些属性允许您将占位符数据或图像插入到视图中。例如，如果要测试布局如何与文本行为相关，但尚未为应用程序定制UI文本，则可以使用占位符文本，如下所示： 12345&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;@tools:sample/lorem&quot; /&gt; 效果如下图所示 系统给我们提供了很多的 sample resource ，如下表所示 Attribute value Description of placeholder data @tools:sample/full_names Full names that are randomly generated from the combination of @tools:sample/first_names and @tools:sample/last_names. @tools:sample/first_names Common first names. @tools:sample/last_names Common last names. @tools:sample/cities Names of cities from across the world. @tools:sample/us_zipcodes Randomly generated US zipcodes. @tools:sample/us_phones Randomly generated phone numbers with the following format: (800) 555-xxxx. @tools:sample/lorem Placeholder text that is derived from Latin. @tools:sample/date/day_of_week Randomized dates and times for the specified format. @tools:sample/date/ddmmyy @tools:sample/date/mmddyy @tools:sample/date/hhmm @tools:sample/date/hhmmss @tools:sample/avatars Vector drawables that you can use as profile avatars. @tools:sample/backgrounds/scenic Images that you can use as backgrounds. 但是我们还会发现，我们其实远远不满足于系统提供的这些模拟资源文件，我们需要自己定义一些数据来源怎么办？ 当然也没问题 在 Android Studio 中，我们可以新建一个 Sample Data Directory 文件夹，在这个文件夹里，我们可以自己定义一些 json 数据来源，并且更重要的是，这个文件夹里的资源文件并不会被打包到我们的 apk 文件中。例如我们\b新建一个 mockData.json 文件，用来存放我们这个 RecyclerView 所对应的模拟数据，比如说 1234567891011121314151617181920{ &quot;menus&quot;: [ { &quot;menuUrl&quot;: &quot;&quot;, &quot;menuIcon&quot;: &quot;&quot;, &quot;menuName&quot;: &quot;&quot;, &quot;showOrder&quot;: 0, &quot;iconUrl&quot;: &quot;&quot;, &quot;avatar&quot;:&quot;@tools:sample/avatars&quot; }, { &quot;menuUrl&quot;: &quot;&quot;, &quot;menuIcon&quot;: &quot;&quot;, &quot;menuName&quot;: &quot;&quot;, &quot;showOrder&quot;: 1, &quot;iconUrl&quot;: &quot;&quot;, &quot;avatar&quot;:&quot;@tools:sample/avatars&quot; } ]} 注意，在这个文件编辑完毕后，我们需要 build 一下工程，才能引用到这里的数据 在 build 完毕后，我们就可以\b通过 tools:text=&quot;@sample/mockdata.json/menus/menuName&quot; 这样的方式引用我们自定义的 json 里的数据了 例如，我们的 item 布局是这样的 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;94dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/item_work_icon&quot; android:layout_width=&quot;42dp&quot; android:layout_height=&quot;42dp&quot; tools:src=&quot;@sample/mockdata.json/menus/avatar&quot; android:scaleType=&quot;centerCrop&quot;/&gt; &lt;TextView android:id=&quot;@+id/item_work_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;9dp&quot; android:gravity=&quot;center&quot; tools:text=&quot;@sample/mockdata.json/menus/menuName&quot; /&gt;&lt;/LinearLayout&gt; 这个时候我们可以在预览窗看到我们的预览页面是这样的，\b已经将文字替换成我们自定义的 \bjson 文件里的数据了。 接着再来看我们的 RecyclerView 的预览窗口，我们把 RecyclerView 的 tools:listitem 的值换成我们上面的这个布局，可以看到我们的预览窗口变成了这样默认的 RecyclerView 是\b使用垂直的LinearLayoutManager，那如果我们想修改成九宫格的呢，也没问题。 RecyclerView \b中提供了下面的几个属性可供我们修改。 属性 介绍 值 itemCount 设置展示 item 的数量 数字，例如6 layoutManager 设置布局方式，三种方式可供选择 GridLayoutManager、LinearLayoutManager 以及 StaggeredGridLayoutManager listitem item 的布局 @layout/xxxx orientation 布局的方向 horizontal vertical spanCount 布局横、纵\b的列数 数字，例如3 举个例子，假如我们的 RecyclerView 是要作为九宫格菜单使用的，平时我们只能在 Java 代码中设置其 LayoutManager 以及 spanCount ，\b等到跑在手机上以后我们才能预览到效果，但现在，我们可以使用 tools 将这个步骤在开发阶段就提前，在编写 xml 文件时候就可以直接预览了，例如 1234567&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv_third_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:listitem=&quot;@layout/item_menu&quot; tools:layoutManager=&quot;GridLayoutManager&quot; tools:spanCount=&quot;3&quot; /&gt; 预览图如下图所示","link":"/2019/01/01/preview_recyclerview_in_preview_window/"},{"title":"记录一次 Android 内嵌 WebView 白屏无法加载内容的事故","text":"昨天下午，产品经理突然发来了一张截图，内容是我们的 APP 因为违反了 Google Play 的某些规定被下架了。 这当然是马上排查原因并 fix 然后打包给测试同事重新测试一遍然后再提审啦。但是问题来了，测试的同事发现 App 内的所有 HTML5 的页面都无法打开了，而主包(国内版本)却是正常的。 这怎么可能会发生呢，fix 被下架的问题并没有修改到 WebView 业务相关的代码，这就百思不得其解了。甚至一度以为是前端同事刚上线的代码影响到了海外版本的业务想甩锅。 拿起自己的手机装上 Google Play 版本的包打开对应的页面一看，基本上是第一次能正常加载，退出后再次点击进入 WebView 页面就无法加载了。 调试 先抓包看 HTTP Request 是否有返回数据，由于是 HTTPS 的页面，尝试使用 Charles 的 Enable SSL Proxy 解开 SSL 加密，无法解开(这里为自己挖了个坑)，查看其他 HTTP 的页面也发现 HTML5 的页面 URL 返回的 Response 都是正常的。 尝试对比主包和海外版的 HTML5 页面的 HTTP Request 的区别，发现只有 User Agent 有所区别，试着将海外版的 User Agent 修改成和主包一样，结果相同，还是无法加载 只好尝试着调试 WebView首先打开 WebView 的 debug 模式 1WebView.setWebContentsDebuggingEnabled(true); 将手机连接到电脑，打开 Chrome，输入 chrome://inspect 通过 Chrome DevTools 调试手机上的 WebView 页面进入 Devices Tab，看到自己的手机设备和当前打开的 HTML5 页面，点击 inspect 打开 DevTools ，此时可以看到有一个提示’安全错误’，并且在刷新重新加载的时候发现页面偶尔会一闪而过一个红色的页面。 一开始不以为然，以为是自己为了解开 HTTPS 而导致的就没放在心上，这时前端的同事让我给他装个可以调试的包给他排查一下问题，我把 apk 文件给到他后，在他的手机上打开 HTML5 的页面是都正常可以访问的。 这就更让人百思不得其解了。 排查后来经测试的另一个同事提醒，说会不会是因为什么原因导致访问会提示不安全了 于是乎上网 Google 了一下 “您要访问的网站包含有害应用” 这个关键字无果，紧接着在其前面加上 WebView，搜出来了一篇 CSDN 上的 Blog，终于找到了问题所在。 自 2018 年 4 月起，随着 WebView 66 发布，Google Play 保护机制，将在 WebView 中默认开始此安全浏览策略。而 Android 开发者在使用 WebView 时，无需再进行任何更改，即可享受此项保护服务。自 Android 8.0 开始，WebView 中即已经集成安全浏览功能，并且与 Android 版的 Chrome 采用相同的底层技术。一旦触发 WebView 的安全机制，就会出现类似这样的“红屏”警告。 作者：承香墨影链接：https://juejin.im/post/5c8899c56fb9a049b41d5432 来源：掘金 原来在 Android O 以后，WebView 的安全浏览策略(Google Safe Browsing) 会在 WebView 中默认开启，Google 自己会维护一份清单判断哪些网站是”有害的“提醒用户，并通过 Google Play Service 同步到用户设备中，而我们的域名刚好被 Google 认为是”有害的“，导致了我们的 HTML5 业务的页面无法打开。 而这也正好解决了我的疑问：为什么前端同事的手机可以正常打开，而我和测试同事的手机却不行，因为我和测试同事的手机为了测试海外版的支付功能都安装了 Google Play Service 而前端同事的手机没有安装 Google Play Service 。所以没有同步”有害网站“ 知道了原因后解决起来就很容易了 解决申诉管理有关不安全网站的警告 请求审核的地址 代码中强制设置不使用『安全浏览策略』 Android O 以上 webviewSetting.setSafeBrowsingEnabled(false) 但这个方法只能用于 API 26 以上，如果在 API 26 一下，则需要在 AndroidManifest 中进行声明 Android O 以下 1234567&lt;manifest&gt; &lt;application&gt; &lt;meta-data android:name=&quot;android.webkit.WebView.EnableSafeBrowsing&quot; android:value=&quot;false&quot; /&gt; ... &lt;/application&gt;&lt;/manifest&gt; 如果觉得这样一刀切的方案有点简单粗暴，WebView 还提供了一个设置白名单的方法，可以将业务上用到的域名列入应用的白名单1WebView.setSafeBrowsingWhitelist(List&lt;String&gt; hosts, ValueCallback&lt;Boolean&gt; callback) 甚至还可以在 WebView 中设置是否被安全机制拦截的监听回调，在接收到被安全拦截后，进行处理123456789101112131415161718class MyWebViewClient : WebViewClient() { // Automatically go &quot;back to safety&quot; when attempting to load a website that // Google has identified as a known threat. An instance of WebView calls // this method only after Safe Browsing is initialized, so there's no // conditional logic needed here. override fun onSafeBrowsingHit( view: WebView, request: WebResourceRequest, threatType: Int, callback: SafeBrowsingResponse ) { // The &quot;true&quot; argument indicates that your app reports incidents like // this one to Safe Browsing. //在这里处理被安全浏览机制拦截 callback.backToSafety(true) Toast.makeText(view.context, &quot;Unsafe web page blocked.&quot;, Toast.LENGTH_LONG).show() }} 最后感谢测试同事，又让我涨知识了 参考链接： Android webview（安全策略） 出现 您要访问的网站包含有害应用(PS. 这篇文章最后的 AndroidManifest 中的写法是错误的) WebView，我已经长大了，知道自己区分是否安全了！ 最重要的！！！还是 Google 官方文档啊 管理 WebView 对象 Android 8.1 Features and APIs","link":"/2019/08/09/record-an-white-screen-accident-for-webview-safe-browse/"},{"title":"ViewModel 原理","text":"ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。 如何使用1private val viewModel = ViewModelProvider(this).get(MyCustomViewModeClass::class.java) ViewModelProvider#构造方法123456789public ViewModelProvider(@NonNull ViewModelStoreOwner owner) { this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory() : NewInstanceFactory.getInstance());}public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) { mFactory = factory; mViewModelStore = store;} 传入一个 ViewModelStoreOwnder 对象，可以是 androidx.activity.ComponentActivity 、androidx.fragment.app.FragmentActivity 或者 androidx.fragment.app.Fragment ，因为这几个类都实现了 ViewModelStoreOwner 接口 在这个构造方法中，会调用双参数的构造方法ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) 第一个参数传入的是 owner.getViewModelStore() 即由实现 ViewModelStoreOwnder 接口的类返回的 ViewModelStore 对象第二个参数传入的是一个 Factory 对象，是用来创建 viewmodel 的工厂类 ViewModelProvider#get()接着看 get(@NonNull Class&lt;T&gt; modelClass) 方法 会先通过开发者传入的 modelClass 的 canonicalName 字符串，并拼接上 DEFAULT_KEY 和 「:」作为前缀先从 mViewModelStore 中判断是否有该 viewmodel 的缓存，如果有则返回缓存否则，通过 Factory 创建该 viewmodel 后进行缓存，最后返回该 viewmodel 对象 123456789101112131415161718192021222324252627282930public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) { String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); } return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);}public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) { ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) { if (mFactory instanceof OnRequeryFactory) { ((OnRequeryFactory) mFactory).onRequery(viewModel); } return (T) viewModel; } else { //noinspection StatementWithEmptyBody if (viewModel != null) { // TODO: log a warning. } } if (mFactory instanceof KeyedFactory) { viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); } else { viewModel = (mFactory).create(modelClass); } mViewModelStore.put(key, viewModel); return (T) viewModel;} ViewModelStore顾名思义，就是存放 ViewModel 的类，很简单的一个类，内部维护了一个 HashMap，以String 为 key，value 为对应的 viewModel ，并对外提供 put()、set()、keys()、clear() 方法对 viewmodel 进行增删改查 1234567891011121314151617181920212223242526272829public class ViewModelStore { private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) { oldViewModel.onCleared(); } } final ViewModel get(String key) { return mMap.get(key); } Set&lt;String&gt; keys() { return new HashSet&lt;&gt;(mMap.keySet()); } /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); }} ViewModel 的恢复对于 Activity 的配置修改，比方说屏幕旋转等行为，我们知道 Activity 可能被重建，但是为什么 viewmodel 缺没有被销毁而重新实例化，而是能拿到先前的实例对象呢 从上文我们知道 FragmentActivity 和 ComponentActivity 中都实现了 ViewModelStoreOwnder 接口并在 getViewModelStore()方法中返回了 ViewModelStore 对象很容易理解，如果全局变量 mViewModelStore 为空，则从 getLastNonConfigurationInstance() 中获取 viewModelStore 并赋值给 mViewModelStore，如果此时还为空，则新建一个 ViewModel 对象，赋值给 mViewModelStore 并返回 123456789101112131415161718public ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot; + &quot;Application instance. You can't request ViewModel before onCreate call.&quot;); } if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } return mViewModelStore;} 那这个 getLastNonConfigurationInstance() 是什么呢 根据注释可以看到，这个方法返回是 onRetainNonConfigurationInstance() 方法保存的 non-configuration 实例数据，我们接着看 onRetainNonConfigurationInstance() 方法 1234Activity#onRetainNonConfigurationInstance()public Object onRetainNonConfigurationInstance() { return null;} 这个方法由系统调用，子类会 override 这个方法，通过源码可以看到是在 Activity#retainNonConfigurationInstances() 中调用的，而这个方法会把onRetainNonConfigurationInstance() 的返回值存到 NonConfigurationInstances 对象的 activity 属性中 1234567891011121314151617181920212223242526272829NonConfigurationInstances retainNonConfigurationInstances() { Object activity = onRetainNonConfigurationInstance(); HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); // We're already stopped but we've been asked to retain. // Our fragments are taken care of but we need to mark the loaders for retention. // In order to do this correctly we need to restart the loaders first before // handing them off to the next activity. mFragments.doLoaderStart(); mFragments.doLoaderStop(true); ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig(); if (activity == null &amp;&amp; children == null &amp;&amp; fragments == null &amp;&amp; loaders == null &amp;&amp; mVoiceInteractor == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity; nci.children = children; nci.fragments = fragments; nci.loaders = loaders; if (mVoiceInteractor != null) { mVoiceInteractor.retainInstance(); nci.voiceInteractor = mVoiceInteractor; } return nci;} 当 Activity 的配置发生变化，例如屏幕旋转后，会创建一个新的 Activity 实例，调用 ActivityThread#performDestroyActivity() 方法销毁旧的 Activity，该方法中会调用 retainNonConfigurationInstances() 方法，将其返回的 NonConfigurationInstances 对象存放到 ActivityClientRecord 的 lastNonConfigurationInstances 属性中，在启动下一个 Activity 的时候，会将该值赋予下一个 Activity，于是通过 getLastNonConfigurationInstance() 方法就可以获取到 retainNonConfigurationInstances() 保存的数据 再回到刚才的 onRetainNonConfigurationInstance() 方法，这个方法需要由子类 override 实现需要保存的数据 12345678910111213141516171819202122232425@Override@Nullablepublic final Object onRetainNonConfigurationInstance() { Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) { // No one called getViewModelStore(), so see if there was an existing // ViewModelStore from our last NonConfigurationInstance NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { viewModelStore = nc.viewModelStore; } } if (viewModelStore == null &amp;&amp; custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci;} 可见这里会将 mViewModelStore 对象进行保存到 NonConfigurationInstances 的实例中并返回，于是下次重建的时候即可拿到上次的实例，从而达到 viewmodel 为同个实例的目的 流程图 疑问😳那为什么正常关闭的 Activity 缺不会使用上一个同个类型的 Activity 的 ViewModel 呢? 我们从 ViewModelStore#clear()方法看起 通过调用方法链可以看到 clear() 被调用的地方为 ComponentActivity 的构造方法，也就是当 Activity Destroy 后会清除掉该 Activity 实例的 ViewModelStore 中存储的 viewmodel，但是这里有个判断条件 !isChangingConfigurations() 也就是说只有非因为配置变化而导致 Activity 被 destroy 的情况下才会调用 viewmodelstore 的 clear 方法 1234567891011getLifecycle().addObserver(new LifecycleEventObserver() { @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) { if (event == Lifecycle.Event.ON_DESTROY) { if (!isChangingConfigurations()) { getViewModelStore().clear(); } } }}); 参考ViewModel 概览","link":"/2022/03/19/2022_03_19_viewmodel/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"设备","slug":"设备","link":"/tags/%E8%AE%BE%E5%A4%87/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Retrofit","slug":"Retrofit","link":"/tags/Retrofit/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"组件化","slug":"组件化","link":"/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"Trick","slug":"Trick","link":"/tags/Trick/"},{"name":"Lint","slug":"Lint","link":"/tags/Lint/"},{"name":"效率","slug":"效率","link":"/tags/%E6%95%88%E7%8E%87/"},{"name":"FixBug","slug":"FixBug","link":"/tags/FixBug/"},{"name":"WebView","slug":"WebView","link":"/tags/WebView/"},{"name":"Storage","slug":"Storage","link":"/tags/Storage/"},{"name":"Encode","slug":"Encode","link":"/tags/Encode/"},{"name":"Bitmap","slug":"Bitmap","link":"/tags/Bitmap/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"Proxy","slug":"Proxy","link":"/tags/Proxy/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Map","slug":"Map","link":"/tags/Map/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"ViewModel","slug":"ViewModel","link":"/tags/ViewModel/"},{"name":"JetPack","slug":"JetPack","link":"/tags/JetPack/"}],"categories":[{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"},{"name":"产品","slug":"产品","link":"/categories/%E4%BA%A7%E5%93%81/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}