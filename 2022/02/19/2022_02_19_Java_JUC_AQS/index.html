<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java 并发编程之 AQS - PPTing&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="PPTing&#039;s Blog"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="PPTing&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="AQS，全称为 AbstractQueuedSynchronizer，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制其中封装了 FIFO(first in first out) 的队列"><meta property="og:type" content="blog"><meta property="og:title" content="Java 并发编程之 AQS"><meta property="og:url" content="https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/"><meta property="og:site_name" content="PPTing&#039;s Blog"><meta property="og:description" content="AQS，全称为 AbstractQueuedSynchronizer，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制其中封装了 FIFO(first in first out) 的队列"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2022/02/19/FhD5tUV1kx6wqJI.png"><meta property="article:published_time" content="2022-02-19T13:13:26.000Z"><meta property="article:modified_time" content="2022-02-24T08:40:59.322Z"><meta property="article:author" content="PPTing"><meta property="article:tag" content="Thread"><meta property="article:tag" content="并发"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.loli.net/2022/02/19/FhD5tUV1kx6wqJI.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/"},"headline":"Java 并发编程之 AQS","image":["https://s2.loli.net/2022/02/19/FhD5tUV1kx6wqJI.png"],"datePublished":"2022-02-19T13:13:26.000Z","dateModified":"2022-02-24T08:40:59.322Z","author":{"@type":"Person","name":"PPTing"},"publisher":{"@type":"Organization","name":"PPTing's Blog","logo":{"@type":"ImageObject","url":"https://ppting.me/favicon.ico"}},"description":"AQS，全称为 AbstractQueuedSynchronizer，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制其中封装了 FIFO(first in first out) 的队列"}</script><link rel="canonical" href="https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-51029889-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-51029889-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
        <script>
            function switchTab(element) {
                const id = element.parentElement.id;
                const tabElements = element.parentElement.parentElement.children;
                const contentElements = element.parentElement.parentElement.parentElement.parentElement.children[1].children;
                for (let i = 0; i < tabElements.length; i++) {
                    const $tab = tabElements[i];
                    const $content = contentElements[i];
                    if ($tab.id === id) {
                        $tab.classList.add('is-active');
                    } else {
                        $tab.classList.remove('is-active');
                    }
                    if ($content.id === id) {
                        $content.classList.remove('is-hidden');
                    } else {
                        $content.classList.add('is-hidden');
                    }
                }
            }
        </script>
        <!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="PPTing's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-19T13:13:26.000Z" title="2/19/2022, 9:13:26 PM">2022-02-19</time>发表</span><span class="level-item"><time dateTime="2022-02-24T08:40:59.322Z" title="2/24/2022, 4:40:59 PM">2022-02-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span> / </span><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></span><span class="level-item">37 分钟读完 (大约5493个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java 并发编程之 AQS</h1><div class="content"><br>

<p>AQS，全称为 <strong>AbstractQueuedSynchronizer</strong>，是 JUC 包中的一个抽象类，为开发者提供了编写同步锁的机制<br>其中封装了 FIFO(first in first out) 的队列</p>
<span id="more"></span>

<h3 id="AQS-的「范式」"><a href="#AQS-的「范式」" class="headerlink" title="AQS 的「范式」"></a>AQS 的「范式」</h3><p>继承 AQS 的实现 <em>Sync 类</em>都需要遵守一定的「范式」<br>一般来说，一个锁的实现，要么是独占式的，要么是共享式的，AQS 中需要开发者 override 以下的方法，但对于某一种锁实现(独占式&#x2F;共享式)来说，只需要 override 其中的一对即可</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean tryAcquire(int arg)</td>
<td>独占式尝试获取锁状态，返回值表示是否获取到锁</td>
</tr>
<tr>
<td>boolean tryRelease(int arg)</td>
<td>独占式尝试释放锁状态，返回值表示<strong>锁状态是否完全被释放</strong>而非是否释放成功，因为在可重入锁的情况下，释放后当前线程可能还持有者该所状态</td>
</tr>
<tr>
<td>int tryAcquireShare(int arg)</td>
<td>共享式尝试获取锁状态</td>
</tr>
<tr>
<td>boolean tryReleaseShare(int arg)</td>
<td>共享式尝试释放锁状态</td>
</tr>
<tr>
<td>boolean isHeldExclusively()</td>
<td>是否独占式的，一般返回 true 表示当前的锁状态被当前线程持有</td>
</tr>
</tbody></table>
<h3 id="关于独占式和共享式"><a href="#关于独占式和共享式" class="headerlink" title="关于独占式和共享式"></a>关于独占式和共享式</h3><p>独占式和共享式的区别在于，在同一个时刻是否能有多个线程获取所状态<br>顾名思义，独占式就是锁状态只能被一个线程获取到，而共享式可以被多个线程获取锁(例如读锁，可以多个线程同时读)</p>
<p>对于一个锁框架来说，需要做到</p>
<ol>
<li>对锁状态的维护</li>
<li>对锁竞争时候，无法竞争到锁的线程的处理</li>
</ol>
<p>而在 AQS 中，以上的两个问题是这样解决的</p>
<ol>
<li>AQS 提供一个 <code>volatile int state</code> 变量，用来标识锁的状态，并且提供了以下三个方法进行读和取</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>final int getState()</td>
<td>获取 state 的值</td>
</tr>
<tr>
<td>final void setState(int newState)</td>
<td>设置 state 的值</td>
</tr>
<tr>
<td>final boolean compareAndSetState(int expect, int update)</td>
<td>原子地修改 state 的值，返回值表示是否修改成功</td>
</tr>
</tbody></table>
<ol start="2">
<li>而对于第二个问题，AQS 提供了一个 FIFO 的队列对无法获取到锁的线程进行入队等待的处理</li>
</ol>
<p>在 AQS 中维护了一个 <code>head</code> 和 <code>tail</code> 两个字段，其类型为 AQS 的内部类 <code>Node</code>，<code>Node</code> 的数据结构如下表格，可见通过 <code>head</code> 和 <code>tail</code> 则构成了一个双向的链表</p>
<p>其结构大概表现为：</p>
<p><img src="https://s2.loli.net/2022/02/19/FhD5tUV1kx6wqJI.png" alt="aqs_queue.png"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int waitStatus</td>
<td>表示当前 Node 的等待状态，具体见下面的表格</td>
</tr>
<tr>
<td>Node prev</td>
<td>表示当前 Node 的前置节点</td>
</tr>
<tr>
<td>Node next</td>
<td>表示当前 Node 的后置节点</td>
</tr>
<tr>
<td>Thread thread</td>
<td>表示将这个 node 加入队列中的线程，在构造函数中赋值，并在Node使用完毕后会置为 null</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td>指向下一个在 condition 上等待的 Node，或者共享式的 Node</td>
</tr>
</tbody></table>
<p>waitStatus:</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>1</td>
<td>表示线程获取锁的请求已经被取消</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>-1</td>
<td>表示线程在等待锁资源，也表示其后续的节点的线程在等待唤醒</td>
</tr>
<tr>
<td>CONDITION</td>
<td>-2</td>
<td>表示线程正在等待 condition</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>-3</td>
<td>表示下一个 acquireShared 应该无条件传播</td>
</tr>
</tbody></table>
<h2 id="独占式机制"><a href="#独占式机制" class="headerlink" title="独占式机制"></a>独占式机制</h2><p>在独占锁机制中，waitStatus 只会使用到 CANCELLED 和 SIGNAL 两个状态</p>
<p><code>lock.tryLock()</code> 会调用 <code>sync.tryAcquire(int arg)</code> 方法，<code>tryAcquire()</code> 方法会通过 cas 的方式设置 state 的值，如果设置成功则返回 true，否则说明无法获取同步状态，则返回 false</p>
<p><code>lock.lock()</code> 方法，调用 <code>sync.acquire(int arg)</code> 方法</p>
<p><code>tryAcquire()</code> 方法：尝试获取锁(修改标志位)，无论成功与否立即返回<br><code>acquire()</code> 方法：获取锁(修改标志位)，获取成功则返回，失败则进入队列等待，直到获取到锁</p>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 <code>acquire()</code> 方法也会调用 <code>tryAcquire()</code> 方法先尝试获取同步状态，如果能获取到(即 tryAcquire() 返回 true)，则不会走后续的 <code>acquireQueued()</code> 以及 <code>selfInterrupt()</code> 方法</p>
<p>如果无法获取同步状态(即 tryAcquire() 返回 false)，调用 <code>addWaiter()</code> 方法以及 <code>acquireQueued()</code> 方法</p>
<h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>接着看 <code>addWaiter()</code> 方法，顾名思义，添加一个等待节点，将新建的 Node 加入链表的队尾，并返回该节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先构造一个 Node 对象，包含当前线程对象，以及 mode (即传入的 Node.EXCLUSIVE 独占式)</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">//将 pred 指向 tail 节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 pred 不为空，即队尾有节点</span></span><br><span class="line">        <span class="comment">//设置 node 的前置节点为 pred(即 tail)</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//通过 cas 将 node 设置为链表队尾</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//设置成功后，将 tail 的后置节点设置为 node，并返回</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明 tail 为 null，即链表为空</span></span><br><span class="line">    <span class="comment">//或者通过 cas 设置链表队尾失败，说明有多个线程在竞争设置队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看 <code>enq()</code> 方法</p>
<p>将 node 插入到链表的队尾，并返回 node 的前序节点</p>
<blockquote>
<p>在 AQS 中，FIFO 队列中的 head 是个哨兵节点，当一个入队的线程获取到锁之后，会将自己对应的节点设置为头节点 head，并将 head 中的 prev 和 thead 都置空，独占式见 <code>acquireQueued -&gt; setHead</code>，共享式见 <code>doAcquireShared-&gt;setHeadAndPropagate</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// t == null 说明还未初始化，则先创建一个哨兵节点并设置为 head，接着将 tail 指向哨兵节点</span></span><br><span class="line">            <span class="comment">//即 head -&gt; new Node() 0= &lt;- tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将 node 插入到 tail 后，并组成双向链表后返回 node 的前序节点(即旧的 tail)</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到 <code>acquire()</code> 方法中 if 中的 <code>acquireQueued()</code> 方法</p>
<h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3><p>acquireQueued 方法会建立一个死循环，不断地从队列中获取独占式的线程进行处理，方法的返回值代表是否需要中断该线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="comment">//获取 node 的前序节点 p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果 p 是头节点且成功获取锁状态</span></span><br><span class="line">                <span class="comment">//将 node 设置为头节点并将原来的头节点 p 从链表中删除</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//返回 interrupted</span></span><br><span class="line">                <span class="comment">//这个死循环只有在这才会返回退出</span></span><br><span class="line">                <span class="comment">//即只有当 node 的前续节点是头节点时</span></span><br><span class="line">                <span class="comment">//并且当前线程尝试获取锁成功了才会退出循环</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这里说明 p 不是头节点，或者是头节点但是尝试获取同步状态失败(tryAcquire 返回 false)</span></span><br><span class="line">            <span class="comment">//这里会将获取不到锁的线程进行挂起，避免循环自旋造成 CPU 性能的无谓消耗</span></span><br><span class="line">            <span class="comment">//shouldParkAfterFailedAcquire 返回的是该线程是否需要挂起</span></span><br><span class="line">            <span class="comment">//parkAndCheckInterrupt 方法会将线程挂起，并且返回是否在挂起期间线程被中断了</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3><p><code>node</code>: 当前线程对应的节点<br><code>pred</code>: 当前线程对应的节点 node 的前序节点</p>
<blockquote>
<p>当一个线程尝试获取锁失败后，会调用这个方法判断是否需要挂起，方法返回值表示是否需要挂起该线程</p>
</blockquote>
<p>这里讲一下 Node 中 waitStatus 这个字段的 SIGNAL 这个状态<br>SIGNAL 字段表示下一个节点处于挂起或者快要进行挂起的操作了，但这个状态不是节点给自己设置的，而是由后序节点修改的</p>
<p>在 AQS 中，当一个节点入队，说明自己需要等待锁，则会修改前序节点的 waitStatus 为 SIGNAL，代表「喂，我在你后面排队，等你处理好事情了叫醒我，我先睡会(挂起)」</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取 pred 节点的 waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果前序节点的 waitStatus 已经为 Signal，返回 true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果前序节点的 waitStauts &gt; 0 （即 CANCELLED）</span></span><br><span class="line">        <span class="comment">//则往前遍历找到非 CANCELLED 状态的节点，并删除 CANCELLED 状态的节点</span></span><br><span class="line">        <span class="comment">//最后 return false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//走到这里说明前序节点的 waitStatus 为 0 或者 PROPAGATE(-3)</span></span><br><span class="line">        <span class="comment">//则将前置节点的 waitStatus 设置为 SIGNAL</span></span><br><span class="line">        <span class="comment">//最后 return false</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3><p>这个方法中通过 <code>LockSupport.park(</code>) 方法将当前线程挂起，并阻塞在该行代码处，直到被唤醒响应<br>通过这个方法挂起的线程在被中断后，不会抛出 InterruptException 的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下:</p>
<p>调用 <code>acquire()</code> 方法的线程首先会先尝试获取锁状态，如果获取成功，则执行后续代码，不表<br>主要是在多个线程竞争同一个锁时，存在竞争状态的情况下</p>
<p>调用 <code>tryAcquire()</code> 返回 false，即该线程获取锁状态不成功，则会在双向链表最后面插入一个 node 节点(持有该线程对象)<br>并通过 <code>acquireQueued()</code> 方法开启一个死循环</p>
<ol>
<li>如果 node 节点的前序节点为 head 节点<br>说明这个 node 节点已经排队排到最前面了，可以尝试获取锁状态，获取成功后则将该 node 节点置为 head，并跳出循环(跳出循环说明该线程已经获取到锁，可以执行其需要执行的代码)<br>如果获取锁状态失败，则进入下一步判断该线程是否需要挂起</li>
</ol>
<blockquote>
<p>实际上在这个双向链表中，head 节点只是充当一个哨兵的作用，并没有其他作用</p>
</blockquote>
<ol start="2">
<li><p>如果 node 节点的前序节点不为 head 节点，则判断该线程是否能够挂起<br> 如果当前节点的前置节点的 waitStatus 为 Signal，说明前面的节点也在等待中，那自己理所应当的就该挂起阻塞等待了<br> 如果当前节点的前置节点的 waitStatus 为 Canceled，则往前遍历并修改链表，跳过并删除 canceled 的节点<br> 否则，将当前节点的前置节点的 waitStatus 置为 Signal</p>
</li>
<li><p>在 <code>shouldParkAfterFailedAcquire()</code> 方法中，除非 pred.waitStatus &#x3D;&#x3D; Signal 则直接返回 true，会将当前线程挂起，否则会继续循环，「将 canceled 的节点删除」或者「将前序节点的 waitStatus 置为 Signal」，当完成「将前序节点的 waitStatus 置为 Signal」这一步(即<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>) 后，下次循环如果 就会走到 pred.waitStatus &#x3D;&#x3D; Signal 的 case 中返回 true，后续的 <code>parkAndCheckInterrupt()</code> 方法会将该线程挂起</p>
</li>
<li><p>如果一个节点是头节点的下一个节点，且头节点的线程还在占用着锁状态，则会不停地自旋去调用 <code>tryAcquire()</code> 方法尝试获取锁</p>
</li>
</ol>
<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p>从前文我们知道，<code>acquireQueued()</code> 的返回值代表是否要中断线程，如果返回 true ，则会走到 if 的 case 中调用 <code>selfInterrupt()</code> 方法中断当前线程<br>而在 <code>acquireQueued()</code> 方法中，只有在 <code>shouldParkAfterFailedAcquire()</code> 和 <code>parkAndCheckInterrupt()</code> 方法都返回 true 的情况下，才会将 interrupted 的值置为 true，并在循环结束的时候返回</p>
<p>回看一下 <code>parkAndCheckInterrupt()</code> 方法，这个方法中回调用 <code>LockSupport.park(this)</code> 将线程挂起，由于这个方法将线程挂起时，不同于 thread.wait() 和 Thread.sleep() ，通过 <code>LockSupport.park()</code> 方法将线程挂起期间，不会抛出中断异常，所以在被唤醒后，需要通过 <code>Thread.interrupted()</code> 方法的返回值来决定是否需要中断当前线程</p>
<blockquote>
<p><code>Thread.interrupted()</code> 返回的是线程是否被中断过，并清除中断状态</p>
</blockquote>
<p>如果线程在等待过程中被中断过(thread.interrupt()) 则 Thread.interrupted() 会返回 true ，将 acquireQueued() 方法中的 interrupted 的值修改为 true ，直到循环退出，调用 selfInterrupt() 方法将线程中断</p>
<h3 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a>解锁过程</h3><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先尝试释放锁状态，由实现类自定义</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">//释放锁状态成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//头节点不为空且其 waitStatus 不为初始状态</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后序节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><p><code>unparkSuccessor()</code> 方法是为了唤醒 node 节点的后序节点对应的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将头节点的 waitStatus 值置为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果头节点的后序节点为空，或者其 waitStatus 为 Canceled 状态，则将其删除</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//从链表的尾巴向前查找，找到链表中第一个 waitStatus &lt; 0 的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//找到了链表中最靠前的 waitStatus &lt; 0 的节点，将其唤醒</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">        <span class="comment">//唤醒后则会回到 parkAndCheckInterrupt 方法中被挂起阻塞的地方，继续执行后续的代码尝试获取锁状态等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享式机制"><a href="#共享式机制" class="headerlink" title="共享式机制"></a>共享式机制</h2><p>在 AQS 中，共享式的方法都以 <code>Shared</code> 结尾，同样的，我们先来看 <code>acquireShared()</code> 方法</p>
<h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><p><code>acquireShare</code> 方法在共享模式中获取锁，会忽略掉中断，会先调用一次 tryAcquireShared 方法获取锁，成功后返回，否则，线程会进行入队等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tryacquireShared"><a href="#tryacquireShared" class="headerlink" title="tryacquireShared"></a>tryacquireShared</h3><p><code>tryacquireShared</code> 方法中直接抛出了异常，说明这是需要共享式锁的实现类自行实现的方法<br>返回值为 int 值，返回值是重点所在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>返回值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;0</td>
<td>表示尝试获取共享锁状态失败</td>
</tr>
<tr>
<td>0</td>
<td>表示获取共享锁状态成功，但不需要唤醒后序的处于等待共享锁的节点</td>
</tr>
<tr>
<td>&gt;0</td>
<td>表示尝试获取共享锁状态成功，如果后序节点处于等待中，则需要将其唤醒</td>
</tr>
</tbody></table>
<h3 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h3><p>从上文知道，当尝试获取共享锁失败后，会调用 <code>doAcquireShared</code> 方法<br>这段代码和上文的独占式锁的机制很类似，也是将节点入队后，通过循环不断的获取队列中的线程进行处理<br>这里我们只看下不同的地方，即 <code>setHeadAndPropagate</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个 node 节点，并将其加入等待队列的队尾</span></span><br><span class="line">    <span class="comment">//注意这里的 node 为 Node.SHARED </span></span><br><span class="line">    <span class="comment">//所以创建的 node 对象中的 nextWaiter == Node.SHARED</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//r &gt;= 0 说明获取共享锁成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3><p>setHeadAndPropagate 方法用来将 node 设置为头结点，并根据 propagate 的值等条件判断是否进行传播<br>回顾一下独享锁，独享式锁是在 <code>release()</code> 方法中通过 <code>unparkSuccessor()</code> 唤醒后序节点起来获取锁后执行代码<br>而在共享式锁中，锁状态可以被多个线程所持有，所以当某个线程获取锁后，可以告知队列中的线程可以起来获取锁而不需要等到当前线程释放锁的时候再进行获取锁</p>
<blockquote>
<p>当然也取决于 propagate 的值<br>propagate 即 tryAcquireShare() 方法的返回值</p>
</blockquote>
<p>从代码中可见，当满足第一个 if 中的条件后，会获取 node.next(即头结点的后一个节点)，如果其为空，即等待队列中没有等待的节点了，或者其为共享式的节点，则会调用 doReleaseShared() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先记录一下当前的 head 的引用</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">//更新 node 为新的 head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">        *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">        *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">        *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">        *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">        *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">        * and</span></span><br><span class="line"><span class="comment">        *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">        *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">        * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">        * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">        * anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//propagate &gt; 0 表示调用者告知信号量需要往后传播</span></span><br><span class="line">    <span class="comment">//h == null || h.waitStauts &lt; 0 说明旧的 head 为空或者为 Canceled 状态</span></span><br><span class="line">    <span class="comment">//h = head == null || h.waitStauts &lt; 0 说明新的的 head 为空或者为 Canceled 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共享锁的释放"><a href="#共享锁的释放" class="headerlink" title="共享锁的释放"></a>共享锁的释放</h2><p>在看 doReleaseShared 方法前，先来看一下 <code>tryReleaseShared</code> 和 <code>releaseShared</code> 方法，有助于理解后面的 doReleaseShared 方法</p>
<h3 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h3><p>tryReleaseShared 方法需要子类自行实现<br>但规范了返回值代表「这次共享锁的释放是否需要唤醒后续等待的节点」，如果需要唤醒后续的节点则返回 true，否则返回 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><p><code>releaseShared</code> 方法先调用 tryReleaseShared 方法尝试释放了锁，如果返回值为 true，则 调用 <code>doReleaseShared</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h3><p>顾名思义，做释放共享锁的事情<br>这里需要明白一个事情，就是 doReleaseShared 方法可能在同一时间有多个线程在访问<br>因为是共享锁，所以可能有的线程正在释放锁，有的线程刚获得锁成为头节点，需要唤醒后续节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//&lt;1&gt;</span></span><br><span class="line">        <span class="comment">//判断 h 不为空(即头节点 head) 且 h!=tail(即链表至少有两个节点，才需要唤醒下一个节点)</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">//判断 h 的 waitStatus 是否为 SIGNAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//h 的 waitStaus 为 SIGNAL 则通过 cas 设置为 0，如果设置失败则进入下一个循环</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//如果 cas 修改 h 的 waitStatus 成功，则唤醒 h 的后序节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="comment">//如果 ws 为 0，说明 head 是刚刚成为了头结点，因为如果有后序节点进入</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//&lt;/1&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="comment">//只有满足 h == head 这个条件时才会退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有点难以理解</p>
<p><strong>关于如何退出循环 if (h &#x3D;&#x3D; head) 的判断</strong></p>
<p>先来解释一下 <code>if(h == head)</code> 的这个判断，在 doReleaseShared 方法的死循环中，只有满足了这个条件才会退出循环，也就是说在 1—的这段代码执行期间，head 的引用没有发生改变，即没有新的节点成为头结点，则当前线程退出此死循环。<br>那什么情况下 head 会发生变化呢，答案自然是有其他的节点(可能是新加入来的节点)获取到了锁，会将 head 修改掉<br>举个例子，假设线程 A 调用了 doReleaseShared 方法， 此时 head &#x3D;&#x3D; NodeA，在执行到 <code>&lt;1&gt;&lt;/1&gt;</code> 中的代码时，因为是共享锁，这时候另一个线程 B 尝试获取锁成功，将 head 修改为 NodeB，当线程 A 执行完 中间的代码后，发现 h !&#x3D; NodeA 了，则会继续进行循环，将此刻的头结点 head(即NodeB) 的后序节点唤醒。直到 h &#x3D;&#x3D; head ，说明 head 在执行期间没有发生变化，说明已经完成了唤醒头节点后序节点的任务，那么就可以退出循环去做自己的事情了</p>
<p>也就是说这里如果有多个线程在同时执行的时候，多个线程都会帮助唤醒 head 节点的后序节点，这个思想就和 ConcurrentHashMap 中多个线程在 put 数据时，如果发现正在扩容，则会一起帮忙扩容，而不是傻傻的等待。妙啊</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，差不多将 AQS 中的重点源码都过了一遍，其他的方法大多大同小异，稍微看一下即可理解，不再赘述，读者阅读时若发现纰漏，望<a href="mailto:zhengkejian0@gmail.com">来信</a>斧正，感谢</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>在学习 AQS 的过程中，从 <a target="_blank" rel="noopener" href="https://space.bilibili.com/1578320">B站寒食君</a>、<a target="_blank" rel="noopener" href="https://dayarch.top/">日拱一兵</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/u/chiucheng">ChiuCheng</a> 中学到了很多知识，感谢</p>
<p>附上链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12K411G7Fg">【Java并发】并发编程的意义是什么？月薪30K必知必会的Java AQS机制</a></p>
<p><a target="_blank" rel="noopener" href="https://dayarch.top/p/java-aqs-and-reentrantlock.html">Java AQS队列同步器以及ReentrantLock的应用</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016447307">逐行分析AQS源码(3)——共享锁的获取与释放</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java 并发编程之 AQS</p><p><a href="https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/">https://ppting.me/2022/02/19/2022_02_19_Java_JUC_AQS/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>PPTing</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-02-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Thread/">Thread</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/02/24/2022_02_24_Java_JUC_ReentrantLock/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java 并发编程之 ReentrantLock</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/17/2022_02_17_Java_Interrupt/"><span class="level-item">Java 线程的中断机制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "a591b67664aeeed8ec988766d49e3fa4",
            repo: "ppting.github.io",
            owner: "PPTing",
            clientID: "8ee6c32324c60fd9fe83",
            clientSecret: "caabfe4dc60fd4b19575bcb4b754d5068a0f7a41",
            admin: ["PPTing"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/f10df62c29905b9b4ba7aaa81b28f152?s=128" alt="PPTing"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">PPTing</p><p class="is-size-6 is-block">Android Developer | Former Frisbee Player</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guangzhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">48</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">24</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PPTing" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:zhengkejian0@gmail.com"><i class="fas fa-inbox"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#AQS-的「范式」"><span class="level-left"><span class="level-item">AQS 的「范式」</span></span></a></li><li><a class="level is-mobile" href="#关于独占式和共享式"><span class="level-left"><span class="level-item">关于独占式和共享式</span></span></a></li></ul><li><a class="level is-mobile" href="#独占式机制"><span class="level-left"><span class="level-item">独占式机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#acquire"><span class="level-left"><span class="level-item">acquire</span></span></a></li><li><a class="level is-mobile" href="#addWaiter"><span class="level-left"><span class="level-item">addWaiter</span></span></a></li><li><a class="level is-mobile" href="#acquireQueued"><span class="level-left"><span class="level-item">acquireQueued</span></span></a></li><li><a class="level is-mobile" href="#shouldParkAfterFailedAcquire"><span class="level-left"><span class="level-item">shouldParkAfterFailedAcquire</span></span></a></li><li><a class="level is-mobile" href="#parkAndCheckInterrupt"><span class="level-left"><span class="level-item">parkAndCheckInterrupt</span></span></a></li></ul></li><li><a class="level is-mobile" href="#中断机制"><span class="level-left"><span class="level-item">中断机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#解锁过程"><span class="level-left"><span class="level-item">解锁过程</span></span></a></li><li><a class="level is-mobile" href="#release"><span class="level-left"><span class="level-item">release</span></span></a></li><li><a class="level is-mobile" href="#unparkSuccessor"><span class="level-left"><span class="level-item">unparkSuccessor</span></span></a></li></ul></li><li><a class="level is-mobile" href="#共享式机制"><span class="level-left"><span class="level-item">共享式机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#acquireShared"><span class="level-left"><span class="level-item">acquireShared</span></span></a></li><li><a class="level is-mobile" href="#tryacquireShared"><span class="level-left"><span class="level-item">tryacquireShared</span></span></a></li><li><a class="level is-mobile" href="#doAcquireShared"><span class="level-left"><span class="level-item">doAcquireShared</span></span></a></li><li><a class="level is-mobile" href="#setHeadAndPropagate"><span class="level-left"><span class="level-item">setHeadAndPropagate</span></span></a></li></ul></li><li><a class="level is-mobile" href="#共享锁的释放"><span class="level-left"><span class="level-item">共享锁的释放</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#tryReleaseShared"><span class="level-left"><span class="level-item">tryReleaseShared</span></span></a></li><li><a class="level is-mobile" href="#releaseShared"><span class="level-left"><span class="level-item">releaseShared</span></span></a></li><li><a class="level is-mobile" href="#doReleaseShared"><span class="level-left"><span class="level-item">doReleaseShared</span></span></a></li></ul></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">小结</span></span></a></li><li><a class="level is-mobile" href="#致谢"><span class="level-left"><span class="level-item">致谢</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 PPTing</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>