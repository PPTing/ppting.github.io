<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Android 存储访问框架 Storage Access Framework - PPTing&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="PPTing&#039;s Blog"><meta name="msapplication-TileImage" content="/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="PPTing&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取&amp;#x2F;保存&amp;#x2F;修改手机中的文件等"><meta property="og:type" content="blog"><meta property="og:title" content="Android 存储访问框架 Storage Access Framework"><meta property="og:url" content="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/"><meta property="og:site_name" content="PPTing&#039;s Blog"><meta property="og:description" content="在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取&amp;#x2F;保存&amp;#x2F;修改手机中的文件等"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://developer.android.google.cn/images/providers/storage_dataflow.png"><meta property="og:image" content="https://i.loli.net/2020/04/19/6vy3JM7LxtSRbBC.jpg"><meta property="og:image" content="https://i.loli.net/2020/04/19/hs9CGO3q7u5KxLm.png"><meta property="og:image" content="https://i.loli.net/2020/04/19/gFfYa7u5jnqLOlp.png"><meta property="article:published_time" content="2020-04-18T16:00:00.000Z"><meta property="article:modified_time" content="2022-03-29T13:55:01.176Z"><meta property="article:author" content="PPTing"><meta property="article:tag" content="Storage"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://developer.android.google.cn/images/providers/storage_dataflow.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/"},"headline":"Android 存储访问框架 Storage Access Framework","image":["https://developer.android.google.cn/images/providers/storage_dataflow.png","https://i.loli.net/2020/04/19/6vy3JM7LxtSRbBC.jpg","https://i.loli.net/2020/04/19/hs9CGO3q7u5KxLm.png","https://i.loli.net/2020/04/19/gFfYa7u5jnqLOlp.png"],"datePublished":"2020-04-18T16:00:00.000Z","dateModified":"2022-03-29T13:55:01.176Z","author":{"@type":"Person","name":"PPTing"},"publisher":{"@type":"Organization","name":"PPTing's Blog","logo":{"@type":"ImageObject","url":"https://ppting.me/favicon.ico"}},"description":"在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取&#x2F;保存&#x2F;修改手机中的文件等"}</script><link rel="canonical" href="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-51029889-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-51029889-1');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start -->
        <script>
            function switchTab(element) {
                const id = element.parentElement.id;
                const tabElements = element.parentElement.parentElement.children;
                const contentElements = element.parentElement.parentElement.parentElement.parentElement.children[1].children;
                for (let i = 0; i < tabElements.length; i++) {
                    const $tab = tabElements[i];
                    const $content = contentElements[i];
                    if ($tab.id === id) {
                        $tab.classList.add('is-active');
                    } else {
                        $tab.classList.remove('is-active');
                    }
                    if ($content.id === id) {
                        $content.classList.remove('is-hidden');
                    } else {
                        $content.classList.add('is-hidden');
                    }
                }
            }
        </script>
        <!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="PPTing's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-18T16:00:00.000Z" title="4/19/2020, 12:00:00 AM">2020-04-19</time>发表</span><span class="level-item"><time dateTime="2022-03-29T13:55:01.176Z" title="3/29/2022, 9:55:01 PM">2022-03-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span> / </span><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">15 分钟读完 (大约2208个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Android 存储访问框架 Storage Access Framework</h1><div class="content"><p>在 Android Kitkat (Android 4.4 Api 19)开始，Android 提供了一套存储访问框架(Storage Access Framework)，简称 SAF。开发者可以在应用内使用该框架，通过用户的操作获取&#x2F;保存&#x2F;修改手机中的文件等</p>
<span id="more"></span>

<p>SAF 包括三个部分</p>
<ul>
<li><strong>DocumentsProvider</strong><br>  内容提供程序，提供内容存储服务的应用可以实现该类，例如 Google Driver，Dropbox，OneDriver 等云存储服务甚至是本地存储服务，实现后用户可以在 <strong>Picker</strong> 中找到该程序所提供的内容</li>
<li><strong>Client</strong><br>  客户端程序，即发起存储访问请求的客户端</li>
<li><strong>Picker</strong><br>  一个系统界面，用户可以在该页面上操作符合条件的文件</li>
</ul>
<p>这里有一张 Google 文档上的图，展示了如何通过 SAF 访问存储数据</p>
<p><img src="https://developer.android.google.cn/images/providers/storage_dataflow.png" alt="通过 SAF 访问存储数据"></p>
<blockquote>
<p>通过 SAF 读写文件并不需要申请 <code>WRITE_EXTERNAL_STORAGE</code> 和 <code>READ_EXTERNAL_STORAGE</code> 权限</p>
</blockquote>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>了解了 SAF 大致的工作原理后，我们还是回归到实践中，这里演示一下在应用开发中，如何通过 SAF 去访问用户手机上的内容</p>
<p>其实最主要的就是通过 Intent 唤起 Picker，交给用户去操作，然后在 onActivityResult 中获取到相对应的数据再由客户端进行处理</p>
<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><blockquote>
<p>创建文件需要让用户先通过 Picker 创建一个文件，再将该写入的路径提供给 Client 以供写入<br>Intent.ACTION_CREATE_DOCUMENT</p>
</blockquote>
<p>那如何让用户打开 Picker 呢，则需要 Client 通过 Intent 唤起 Picker 页面，由用户选择保存的位置和文件名后，点击确认后返回应用内。由客户端获取到 Uri 后对该文件进行写入等</p>
<p><img src="https://i.loli.net/2020/04/19/6vy3JM7LxtSRbBC.jpg"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重点在于这里的 Intent Action</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply &#123;</span><br><span class="line">    addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    <span class="comment">//告知要保存的文件的 MIME 类型</span></span><br><span class="line">    type = <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="comment">//提供保存的文件名，可选</span></span><br><span class="line">    putExtra(Intent.EXTRA_TITLE,<span class="string">&quot;myPicture.png&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">startActivityForResult(intent, REQUEST_CODE_FOR_WRITE_IMAGE)</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><blockquote>
<p>读取文件需要用户选择文件后提供给 Client<br><strong>Intent.ACTION_OPEN_DOCUMENT</strong></p>
</blockquote>
<p>比方说，我需要用户选择一张图片作为头像</p>
<p>则需要通过 Intent 唤起 Picker </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_FOR_IMAGE = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply&#123;</span><br><span class="line">    <span class="comment">//对结果进行过滤，只显示可打开的文件</span></span><br><span class="line">    addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">    <span class="comment">//过滤非 image 类型的文件</span></span><br><span class="line">    type = <span class="string">&quot;image/*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startActivityForResult(intent,REQUEST_CODE_FOR_IMAGE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再在 Activity 的 onActivityResult() 回调中获取用户选择的文件的 Uri(即 data.data)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (resultCode == Activity.RESULT_OK)&#123;</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            REQUEST_CODE_FOR_IMAGE -&gt;&#123;</span><br><span class="line">                <span class="keyword">data</span>?.<span class="keyword">data</span>?.let &#123; showImage(it) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到该 Uri 后则可以将该 Uri 转成 Bitmap 展示在 ImageView 中</p>
<h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><blockquote>
<p>编辑文件，同样的道理，你只需要通过 Intent 唤起 Picker，让用户选取文件后进行读写即可</p>
</blockquote>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><blockquote>
<p>同样的，删除文件也需要获取到该文件的 uri 后才能进行操作<br>通过 Picker 获取 Uri 的代码可以参考上文的<strong>获取文件</strong></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentsContract.deleteDocument(contentResolver, uri)</span><br></pre></td></tr></table></figure>

<h2 id="获取文件夹权限"><a href="#获取文件夹权限" class="headerlink" title="获取文件夹权限"></a>获取文件夹权限</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE)</span><br><span class="line">startActivityForResult(intent,REQUEST_CODE_FOR_DIR)</span><br></pre></td></tr></table></figure>

<p>通过唤起 Picker ，让用户选择目录授予 Client 该文件夹的完整访问权限，包括当前存储在该文件夹下的文件以及日后存储在该文件夹下的文件</p>
<p>同理，在 <code>onActivityResult</code> 中可以获取到该文件夹的 <code>Uri</code> 并进行读写操作。</p>
<p>在用户点击「允许访问 xx 」时，会弹出一个授权提示，如下图<br><img src="https://i.loli.net/2020/04/19/hs9CGO3q7u5KxLm.png" alt="Screenshot_20200418-221258"></p>
<p>如果用户授权之后，在应用管理中，我们也可以看到该 APP 多了一个「取消访问权限」的按钮</p>
<p><img src="https://i.loli.net/2020/04/19/gFfYa7u5jnqLOlp.png" alt="Screenshot_20200418-221628"></p>
<p>一旦用户点击「取消访问限制」，上图中「总计」下面所罗列出来的存储位置的权限都会被取消，并且 App 不会像点击应用管理中的 「清除缓存」那样被杀死，而是还会继续在运行，所以对于应用来说，要处理好对于文件夹 Uri 的权限处理</p>
<h2 id="Uri-权限"><a href="#Uri-权限" class="headerlink" title="Uri 权限"></a>Uri 权限</h2><h3 id="权限时间"><a href="#权限时间" class="headerlink" title="权限时间"></a>权限时间</h3><p>根据官方文档所述，我们通过上述的方式获取到的 Uri ，事实上系统会对该 Uri 对我们的 Client 进行授权，直到用户重启设备(正常情况下是这样)</p>
<p><em>因为事实上还可能有上述取消访问权限的情况</em></p>
<p>例如说，如果我们将获取到的 Uri 进行保存(存为字符串形式)，后续再通过 <code>Uri.parse(String urlString)</code> 方法构建出来的对象，也是可以对文件进行访问的(在用户授权后至重启之间)</p>
<p>如果需要在设备重启后还拥有对该 Uri 的权限，则需要获取系统提供的 Uri 持久授权，这样用户则可以在设备重启后继续在该 App Client 中持续访问该文件</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 Uri 权限进行持久化</span></span><br><span class="line"><span class="keyword">val</span> takeFlags: <span class="built_in">Int</span> = intent.flags and</span><br><span class="line">        (Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION)</span><br><span class="line">contentResolver.takePersistableUriPermission(uri, takeFlags)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Caution: Even after calling takePersistableUriPermission(), your app doesn’t retain access to the URI if the associated document is moved or deleted. In those cases, you need to ask permission again to regain access to the URI.<br>还有最后一个步骤。应用最近访问的 URI 可能不再有效，原因是另一个应用可能删除或修改了文档。因此，您应始终调用 getContentResolver().takePersistableUriPermission()，以检查有无最新数据。</p>
</blockquote>
<p>官方文档上还有上述这一段描述，但是我的理解中，如果一个文件被移动或者删除了，那它所对应的 Uri 即便通过 <code>takePersistableUriPermission</code> 方法再次授权了，也是没有多大作用的呀？？这个方法本身不会有返回值告知开发者该 Uri 是否还能继续用，通过我的实验，在获取到 Uri 后，通过文件管理器等将文件进行删除，调用 <code>takePersistableUriPermission</code> 方法也不会 throw  Exception，所以官方文档上的这个 <code>move or deleted</code> 我抱有疑问，望赐教</p>
<h3 id="运行时权限处理"><a href="#运行时权限处理" class="headerlink" title="运行时权限处理"></a>运行时权限处理</h3><p>如果用户在应用管理中取消了访问权限，在 App 中通过 <code>contentResolver.takePersistableUriPermission</code>方法对该 Uri 进行权限申请则会 throw 下面的 Exception </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: No persistable permission grants found <span class="keyword">for</span> UID <span class="number">10200</span> and Uri  [user <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>所以我们可以通过 try catch 判断是否拥有对该目录的访问权限？</p>
<p>其实大可不必，通过 <code>contentResolver.getPersistedUriPermissions</code> 方法可以获取到该应用当前所拥有的权限列表，判断要使用的权限是否在列表当中即可</p>
<p>另外，授予了的 Uri 权限也可以通过 <code>contentResolver.releasePersistableUriPermission</code> 方法主动释放</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SAF 其实就是通过用户在 Picker 获取 DocumentProvider 提供的内容，转为 Uri 对象提供给 Client 对其进行操作，而不是 Client 直接通过 File Api 操作 External Storage ，通过将权限由开发者申请转变为了让用户自行通过系统改的 Picker 选择，从而避免了申请 <code>WRITE_EXTERNAL_STORAGE</code> 和 <code>READ_EXTERNAL_STORAGE</code> 权限 </p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p>官方文档:<br>中文版:<a target="_blank" rel="noopener" href="https://developer.android.google.cn/guide/topics/providers/document-provider#kotlin">使用存储访问框架打开文件</a><br>英文版:<a target="_blank" rel="noopener" href="https://developer.android.com/training/data-storage/shared/documents-files">Access documents and other files from shared storage</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>对于 <code>Uri</code> 来说，可以通过 <code>ContentResolver</code> 的 Api 对文件进行处理</p>
<p>例如上文中提到的将 Uri 处理为 Bitmap 的方法<br>后续有空再来研究一下这些 api 以及 FileStream 的使用</p>
<p>下文代码大多转载于上述参考文章中的 Google 官方文档</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将图片 Uri 转为 Bitmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showImage</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>&#123;</span><br><span class="line">    GlobalScope.launch(Dispatchers.Main)&#123;</span><br><span class="line">        imageView.setImageBitmap(getBitmapFromUri(<span class="keyword">this</span><span class="symbol">@SAFActivity</span>,uri))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBitmapFromUri</span><span class="params">(context: <span class="type">Context</span>,uri: <span class="type">Uri</span>)</span></span>: Bitmap&#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.IO)&#123;</span><br><span class="line">        <span class="keyword">val</span> parcelFileDescriptor = context.contentResolver.openFileDescriptor(uri,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> fileDescriptor = parcelFileDescriptor?.fileDescriptor</span><br><span class="line">        <span class="keyword">val</span> image = BitmapFactory.decodeFileDescriptor(fileDescriptor)</span><br><span class="line">        parcelFileDescriptor?.close()</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编辑文本文件 Uri 的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">alterDocument</span><span class="params">(uri: <span class="type">Uri</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//&quot;w&quot; 指写(write)权限</span></span><br><span class="line">        <span class="comment">//如果仅需要读(read)权限，传入 &quot;r&quot; 即可</span></span><br><span class="line">        contentResolver.openFileDescriptor(uri, <span class="string">&quot;w&quot;</span>)?.use &#123;</span><br><span class="line">            <span class="comment">// use&#123;&#125; lets the document provider know you&#x27;re done by automatically closing the stream</span></span><br><span class="line">            FileOutputStream(it.fileDescriptor).use &#123;</span><br><span class="line">                it.write(</span><br><span class="line">                    (<span class="string">&quot;Overwritten by MyCloud at <span class="subst">$&#123;System.currentTimeMillis()&#125;</span>\n&quot;</span>).toByteArray()</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: FileNotFoundException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本 Uri 中的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getTextFromUri</span><span class="params">(uri: <span class="type">Uri</span>)</span></span>: String&#123;</span><br><span class="line">    <span class="keyword">val</span> text = StringBuilder()</span><br><span class="line">    contentResolver.openFileDescriptor(uri,<span class="string">&quot;r&quot;</span>)?.use &#123;</span><br><span class="line">        FileInputStream(it.fileDescriptor).use&#123;</span><br><span class="line">            BufferedReader(InputStreamReader(it)).use &#123; bufferedReader-&gt;</span><br><span class="line">                <span class="keyword">var</span> line: String? = bufferedReader.readLine()</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">null</span> != line)&#123;</span><br><span class="line">                    text.append(line)</span><br><span class="line">                    line = bufferedReader.readLine()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>Android 存储访问框架 Storage Access Framework</p><p><a href="https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/">https://ppting.me/2020/04/19/2020_04_19_about_Storage_Access_Framework/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>PPTing</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-04-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-03-29</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Storage/">Storage</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/01/measure_view/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android View 的测量</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/19/2020_04_19_how_to_use_Android_MediaStore_Api/"><span class="level-item">Android MediaStore Api 使用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f0c102d6c54aa8262e19e8d62a68c3de",
            repo: "ppting.github.io",
            owner: "PPTing",
            clientID: "8ee6c32324c60fd9fe83",
            clientSecret: "caabfe4dc60fd4b19575bcb4b754d5068a0f7a41",
            admin: ["PPTing"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/f10df62c29905b9b4ba7aaa81b28f152?s=128" alt="PPTing"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">PPTing</p><p class="is-size-6 is-block">Android Developer | Former Frisbee Player</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Guangzhou,China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PPTing" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:zhengkejian0@gmail.com"><i class="fas fa-inbox"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PPTing"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#代码示例"><span class="level-left"><span class="level-item">代码示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建文件"><span class="level-left"><span class="level-item">创建文件</span></span></a></li><li><a class="level is-mobile" href="#读取文件"><span class="level-left"><span class="level-item">读取文件</span></span></a></li><li><a class="level is-mobile" href="#编辑文件"><span class="level-left"><span class="level-item">编辑文件</span></span></a></li><li><a class="level is-mobile" href="#删除文件"><span class="level-left"><span class="level-item">删除文件</span></span></a></li></ul></li><li><a class="level is-mobile" href="#获取文件夹权限"><span class="level-left"><span class="level-item">获取文件夹权限</span></span></a></li><li><a class="level is-mobile" href="#Uri-权限"><span class="level-left"><span class="level-item">Uri 权限</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#权限时间"><span class="level-left"><span class="level-item">权限时间</span></span></a></li><li><a class="level is-mobile" href="#运行时权限处理"><span class="level-left"><span class="level-item">运行时权限处理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#参考文章："><span class="level-left"><span class="level-item">参考文章：</span></span></a></li><li><a class="level is-mobile" href="#附录"><span class="level-left"><span class="level-item">附录</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/favicon.ico" alt="PPTing&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 PPTing</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PPTing"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>